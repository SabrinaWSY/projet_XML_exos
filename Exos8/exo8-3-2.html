<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta charset="UTF-8">
<title>Exercice 8 : Exploration d’une recommandation W3C taggée</title>
<style>
                    div.header{
                    margin: auto;
                    text-align: center;
                    border-style: solid;
                    border-top-width: 3px;
                    border-bottom-width: 3px;
                    border-left-width: 0;
                    border-right-width:0;
                    }
                    div.p {
                    margin-left: 10px;
                    text-align: justify;
                    }
                    det.fem{color:red;}
                    det.masc{color:blue;}
                </style>
</head>
<body>
<div class="header">Mise en forme par Lara DUNUAN et
                    Siyu WANG 
                    , M1 TAL.</div>
<h1>Recommandation XSLT 1.0</h1>
<div class="p">
<det class="masc">Ce </det>document est <det class="fem">une </det>traduction de <det class="fem">la </det>recommandation XSL Transformations ( XSLT ) 1.0 <det class="masc">du </det>W3C , datée <det class="masc">du </det>16 novembre 1999 . </div>
<div class="p">
<det class="fem">Cette </det>version traduite peut contenir <det class="fem">des </det>erreurs absentes de <det class="masc">l' </det>original , dues à <det class="fem">la </det>traduction elle -même . </div>
<div class="p">
<det class="fem">La </det>version originale en anglais , seule normative , se trouve à <det class="masc">l' </det>adresse http : / / www . w3 . org / TR / 1999 / REC-xslt-19991116 . </div>
<div class="p">Traduction : Ramzi Guetari Jean-Jacques Thomasson Yves Bazin Traduction hébergée par XMLfr . </div>
<div class="p">Copyright © 1998 W3C ( MIT , INRIA , Keio ) , tous droits réservés . </div>
<div class="p">
<det class="fem">Les </det>règles <det class="masc">du </det>W3C sur <det class="fem">la </det>responsabilité , <det class="fem">les </det>marques de commerce , <det class="masc">les </det>droits d' auteur et <det class="fem">les </det>licences de logiciels sont applicables . </div>
<div class="p">Note de traduction : <det class="masc">L' </det>entité ISO LATIN I de " oe " ligaturé n' étant pas supportée par certains navigateurs , il sera écrit oe . Transformations XSL ( XSLT ) Version 1.0 Recommandation W3C 16 Novembre 1999 <det class="fem">Cette </det>version a été traduite à partir de <det class="fem">la </det>version : http : / / www . w3 . org / TR / 1999 / REC-xslt-19991116 ( existe en XML ou HTML ) Dernière version : http : / / www . w3 . org / TR / xslt Versions précédentes : http : / / www . w3 . org / TR / 1999 / PR-xslt-19991008 http : / / www . w3 . org / 1999 / 08 / WD-xslt-19990813 http : / / www . w3 . org / 1999 / 07 / WD-xslt-19990709 http : / / www . w3 . org / TR / 1999 / WD-xslt-19990421 http : / / www . w3 . org / TR / 1998 / WD-xsl-19981216 http : / / www . w3 . org / TR / 1998 / WD-xsl-19980818 Éditeur <det class="masc">du </det>document original : James Clark &lt;jjc@jclark.com&gt; Copyright © 1998 W3C ( MIT , INRIA , Keio ) , tous droits réservés . </div>
<div class="p">
<det class="fem">Les </det>règles <det class="masc">du </det>W3C sur <det class="fem">la </det>responsabilité , <det class="fem">les </det>marques de commerce , <det class="masc">les </det>droits d' auteur et <det class="fem">les </det>licences de logiciels sont applicables . </div>
<div class="p">Sommaire <det class="fem">Cette </det>spécification définit <det class="fem">la </det>syntaxe et <det class="fem">la </det>sémantique de XSLT , qui est <det class="masc">un </det>langage permettant de transformer <det class="masc">des </det>documents XML en d' autres documents XML . XSLT est conçu pour être utilisé comme <det class="fem">une </det>partie de XSL , <det class="masc">le </det>langage <det class="fem">des </det>feuilles de style de XML . En plus de XSLT , XSL inclus <det class="masc">un </det>vocabulaire XML pour <det class="fem">la </det>spécification de formatage . </div>
<div class="p">XSL spécifie <det class="fem">les </det>règles de présentation d' <det class="masc">un </det>document XML en utilisant XSLT pour décrire comment <det class="masc">le </det>document peut être transformé en <det class="masc">un </det>autre document qui utilise <det class="masc">le </det>vocabulaire de formatage . </div>
<div class="p">XSLT est aussi conçu pour être utilisé indépendamment de XSL . Cependant , XSLT n' est pas censé être utilisé comme <det class="masc">un </det>langage de transformation XML à vocation générale . </div>
<div class="p">Il a surtout été conçu pour <det class="masc">les </det>types de transformations nécessaires lorsque XSLT est utilisé comme <det class="fem">une </det>partie de XSL . État de <det class="masc">ce </det>document <det class="fem">La </det>version originale de <det class="masc">ce </det>document a été examinée par <det class="masc">les </det>Membres <det class="masc">du </det>W3C ainsi que d' autres parties concernées , elle a été approuvée par <det class="masc">le </det>directeur comme étant <det class="fem">une </det>Recommandation <det class="masc">du </det>W3C . C' est <det class="masc">un </det>document stable pouvant être utilisé comme document de référence ou cité comme <det class="fem">une </det>référence normative par d' autres documents . </div>
<div class="p">
<det class="masc">Le </det>rôle <det class="masc">du </det>W3C en mettant à disposition <det class="fem">cette </det>Recommandation est de promouvoir <det class="masc">son </det>déploiement <det class="masc">le </det>plus large possible . </div>
<div class="p">Ceci dans <det class="masc">le </det>but d' améliorer et d' accroître <det class="fem">la </det>fonctionnalité et <det class="masc">l' </det>interopérabilité <det class="masc">du </det>Web . </div>
<div class="p">
<det class="fem">La </det>liste <det class="fem">des </det>erreurs répertoriées dans <det class="fem">cette </det>spécification est disponible à : http : / / www . w3 . org / 1999 / 11 / REC-xslt-19991116-errata . </div>
<div class="p">
<det class="masc">Les </det>commentaires sur <det class="fem">cette </det>spécification peuvent être adressés à xsl-editors@w3 . org ; <det class="fem">les </det>archives <det class="masc">des </det>commentaires sont disponibles . </div>
<div class="p">
<det class="fem">Les </det>discussions publiques sur XSL , y compris <det class="fem">les </det>Transformations XSL , se tiennent sur <det class="fem">la </det>mailing liste XSL-List . </div>
<div class="p">
<det class="fem">La </det>version anglaise de <det class="fem">cette </det>spécification est <det class="fem">la </det>seule version normative ( http : / / www . w3 . org / TR / 1999 / REC-xslt-19991116 ) . </div>
<div class="p">Cependant , pour <det class="fem">les </det>traductions de <det class="masc">ce </det>document , consulter http : / / www . w3 . org / Style / XSL / translations . html . </div>
<div class="p">
<det class="fem">Une </det>liste <det class="fem">des </det>Recommandations courantes <det class="masc">du </det>W3C ainsi que d' autres documents techniques peut être trouvée à : http : / / www . w3 . org / TR . <det class="fem">Cette </det>spécification a été produite comme <det class="fem">une </det>partie de <det class="masc">l' </det>activité Style <det class="masc">du </det>W3C . Table <det class="masc">des </det>matières 1 Introduction 2 Structure <det class="fem">des </det>feuilles de style 2.1 Espace de noms XSLT 2.2 Éléments de feuilles de styles 2.3 Feuille de style sous forme d' élément littéral résultat 2.4 Noms qualifiés 2.5 Traitement de <det class="fem">la </det>compatibilité ascendante 2.6 Combinaison de feuilles de style 2.6.1 Inclusion de feuilles de style 2.6.2 Import de feuilles de style 2.7 Feuilles de style encapsulées 3 Modèle de données 3.1 <det class="masc">Les </det>fils <det class="masc">du </det>noeud racine 3.2 URI base 3.3 Entités non valides 3.4 Suppression de caractères espace 4 Expressions 5 Règles modèle 5.1 Modèle de traitement 5.2 Modèles 5.3 Définition de règles modèle 5.4 Application <det class="fem">des </det>règles modèle 5.5 Résolution de conflits <det class="fem">des </det>règles modèle 5.6 Outrepasser <det class="fem">des </det>règles modèles 5.7 Modes 5.8 Règles modèle encastrées 6 Modèles nommés 7 Créer <det class="masc">l' </det>arbre résultat 7.1 Créer <det class="masc">des </det>éléments et <det class="masc">des </det>attributs 7.1.1 Éléments résultats littéraux 7.1.2 Créer <det class="masc">des </det>éléments avec xsl : element 7.1.3 Créer <det class="masc">des </det>attributs avec xsl : attribute 7.1.4 Ensembles d' attributs nommés 7.2 Créer de texte 7.3 Créer <det class="fem">des </det>instructions de traitement 7.4 Créer <det class="fem">des </det>commentaires 7.5 Copier 7.6 Calculer <det class="masc">le </det>texte généré 7.6.1 Générer <det class="masc">du </det>texte avec xsl : value-of 7.6.2 <det class="masc">Les </det>modèles de valeurs d' attributs 7.7 Calculer 7.7.1 Attributs de conversion de nombres en chaînes de caractères 8 Répétition 9 Traitement conditionnel 9.1 Traitement conditionnel par xsl : if 9.2 Traitement conditionnel par xsl : choose 10 tri 11 Variables et Paramètres 11.1 Fragments d' arbre résultat 11.2 Valeurs <det class="fem">des </det>Variables et <det class="fem">des </det>Paramètres 11.3 Utilisation <det class="fem">des </det>valeurs <det class="masc">des </det>Variables et <det class="masc">des </det>Paramètres avec xsl : copy-of 11.4 Variables et paramètres de haut niveau 11.5 <det class="masc">Les </det>Variables et <det class="masc">les </det>Paramètres dans <det class="masc">les </det>modèles 11.6 Passage de paramètres <det class="fem">aux </det>modèles 12 Fonctions additionnelles 12.1 Documents avec sources multiples 12.2 Clés 12.3 Formatage de nombres 12.4 Fonctions additionnelles diverses 13 Messages 14 Extensions 14.1 Eléments extension 14.2 Fonctions extension 15 Reprise 16 Sorties 16.1 <det class="fem">La </det>méthode de sortie XML 16.2 <det class="fem">La </det>méthode de sortie HTML 16.3 <det class="fem">La </det>méthode de sortie texte 16.4 Désactivation de <det class="fem">la </det>production littérale <det class="masc">des </det>caractères en sortie 17 Conformité 18 Notation Annexes A Références A.1 Références normatives A.2 Autres références B Récapitulatif de <det class="fem">la </det>syntaxe <det class="masc">des </det>éléments C Fragment de <det class="fem">la </det>DTD <det class="fem">des </det>feuilles de style XSLT ( non normatif ) D Exemples ( non normatifs ) D.1 Exemple de document D.2 Exemple avec <det class="fem">des </det>données E Avertissements ( non normatif ) F Changement depuis <det class="fem">la </det>recommandation proposée ( non normatif ) G Fonctionnalités à <det class="masc">l' </det>étude pour <det class="fem">une </det>future version de XSLT ( non normatif ) 1 Introduction <det class="fem">Cette </det>spécification définit <det class="fem">la </det>syntaxe et <det class="fem">la </det>sémantique <det class="masc">du </det>langage XSLT . <det class="fem">Une </det>transformation dans XSLT est exprimée comme <det class="masc">un </det>document XML bien formé [ XML ] conformément <det class="masc">aux </det>espaces de noms définis dans <det class="fem">la </det>recommandation XML [ Noms XML ] , pouvant aussi bien contenir <det class="masc">des </det>éléments définis par XSLT que d' autres éléments non définis par XSLT . <det class="masc">Les </det>éléments définis par XSLT se distinguent par <det class="fem">leur </det>appartenance à <det class="masc">un </det>espace de nom XML spécifique ( voir [ 2.1 Espace de noms XSLT ] ) , qui est référencé dans <det class="fem">cette </det>spécification par Espace de noms . </div>
<div class="p">Ainsi <det class="fem">cette </det>spécification est <det class="fem">une </det>définition de <det class="fem">la </det>syntaxe et de <det class="fem">la </det>sémantique de <det class="masc">l' </det>Espace de noms XSLT . <det class="fem">Une </det>transformation exprimée en XSLT décrit <det class="fem">les </det>règles pour transformer <det class="masc">un </det>arbre source en <det class="masc">un </det>arbre résultat . </div>
<div class="p">
<det class="fem">La </det>transformation est obtenue en associant <det class="masc">des </det>motifs à <det class="masc">des </det>modèles . </div>
<div class="p">
<det class="masc">Les </det>motifs sont appliqués <det class="masc">aux </det>éléments de <det class="masc">l' </det>arbre source . </div>
<div class="p">
<det class="masc">Le </det>modèle est instancié pour créer <det class="fem">une </det>partie de <det class="masc">l' </det>arbre résultat . </div>
<div class="p">
<det class="masc">L' </det>arbre résultat est distinct de <det class="masc">l' </det>arbre source . </div>
<div class="p">
<det class="fem">La </det>structure de <det class="masc">l' </det>arbre résultat peut être complètement différente de <det class="fem">la </det>structure de <det class="masc">l' </det>arbre source . </div>
<div class="p">Pendant <det class="fem">la </det>construction de <det class="masc">l' </det>arbre résultat , <det class="masc">des </det>éléments de <det class="masc">l' </det>arbre source peuvent être filtrés et réordonnés , et <det class="fem">des </det>structures arbitraires peuvent être ajoutées . </div>
<div class="p">
<det class="fem">Une </det>transformation exprimée en XSLT est appelée feuille de styles . </div>
<div class="p">Ceci parce que quand XSLT est transformé dans <det class="masc">le </det>vocabulaire de formatage XSL , <det class="fem">la </det>transformation fonctionne comme <det class="fem">une </det>feuille de styles . </div>
<div class="p">
<det class="masc">Ce </det>document ne spécifie pas comment <det class="fem">une </det>feuille de styles XSLT est associée à <det class="masc">un </det>document XML . Il est recommandé que <det class="masc">les </det>processeurs XSL supportent <det class="masc">le </det>mécanisme décrit dans [ Feuilles de style XML ] . </div>
<div class="p">Lorsque <det class="masc">ce </det>mécanisme ou n' importe quel autre mécanisme rencontre <det class="fem">une </det>séquence de plus d' <det class="fem">une </det>seule feuille de styles XSLT qu' il faut appliquer simultanément à <det class="masc">un </det>document XML , alors <det class="masc">le </det>résultat doit être <det class="masc">le </det>même que si l' on appliquait <det class="fem">une </det>seule feuille de styles qui importerait chaque membre de <det class="fem">la </det>séquence dans <det class="masc">l' </det>ordre ( voir [ 2.6.2 Import <det class="fem">des </det>feuilles de style ] ) . </div>
<div class="p">
<det class="fem">Une </det>feuille de styles contient <det class="masc">un </det>ensemble de règles modèles . </div>
<div class="p">
<det class="fem">Une </det>règle modèle est constituée de deux parties : <det class="masc">un </det>motif qui sert à identifier <det class="masc">des </det>noeuds de <det class="masc">l' </det>arbre source et <det class="masc">un </det>modèle pouvant être instancié afin de constituer <det class="fem">une </det>partie de <det class="masc">l' </det>arbre résultat . </div>
<div class="p">Ceci permet à <det class="fem">une </det>feuille de styles d' être applicable à <det class="fem">une </det>large catégorie de documents ayant <det class="fem">des </det>structures d' arbres source similaires . </div>
<div class="p">
<det class="masc">Un </det>modèle est instancié pour <det class="masc">un </det>élément source particulier afin de créer <det class="fem">une </det>partie de <det class="masc">l' </det>arbre résultat . </div>
<div class="p">
<det class="masc">Un </det>modèle peut contenir <det class="masc">des </det>éléments permettant de spécifier littéralement <det class="masc">les </det>éléments de <det class="fem">la </det>structure résultante . </div>
<div class="p">
<det class="masc">Un </det>modèle peut aussi contenir <det class="masc">des </det>éléments de <det class="masc">l' </det>espace de noms XSLT représentant <det class="fem">des </det>instructions pour <det class="fem">la </det>création de fragments de <det class="masc">l' </det>arbre résultat . </div>
<div class="p">Lorsqu' <det class="masc">un </det>modèle est instancié , chaque instruction est exécutée et remplacée par <det class="masc">le </det>fragment d' arbre résultat qu' elle aura crée . </div>
<div class="p">
<det class="fem">Les </det>instructions peuvent sélectionner et traiter <det class="masc">les </det>descendants <det class="masc">des </det>éléments source . </div>
<div class="p">
<det class="fem">La </det>création d' <det class="masc">un </det>fragment de <det class="masc">l' </det>arbre résultat par <det class="masc">le </det>traitement <det class="masc">des </det>éléments descendants se fait en trouvant <det class="fem">la </det>règle modèle applicable et en instanciant <det class="masc">son </det>modèle . </div>
<div class="p">Il faut noter que <det class="masc">les </det>éléments ne sont traités que lorsqu' ils sont sélectionnés par <det class="masc">l' </det>exécution d' <det class="fem">une </det>instruction . </div>
<div class="p">
<det class="masc">L' </det>arbre résultat est construit en prenant <det class="fem">la </det>règle modèle <det class="masc">du </det>noeud racine et en instanciant <det class="masc">son </det>modèle . </div>
<div class="p">Lors de <det class="fem">la </det>recherche d' <det class="fem">une </det>règle modèle applicable , plusieurs autre règles modèle peuvent avoir <det class="masc">un </det>motif correspondant à <det class="masc">un </det>élément donné . </div>
<div class="p">Cependant , <det class="fem">une </det>seule et unique règle modèle sera appliquée . </div>
<div class="p">
<det class="fem">La </det>méthode permettant de déterminer quelle est <det class="fem">la </det>règle modèle à appliquer est décrite dans [ 5.5 Résolution de conflits <det class="fem">des </det>règles modèle ] . </div>
<div class="p">
<det class="masc">Un </det>modèle possède à lui tout seul <det class="fem">une </det>puissance considérable : il peut créer <det class="fem">des </det>structures de n' importe quel niveau de complexité ; il peut accéder et récupérer <det class="fem">les </det>valeurs de chaînes de caractères situées à n' importe quel endroit de <det class="masc">l' </det>arbre source ; il peut générer <det class="fem">des </det>structures répétées <det class="masc">au </det>fur et à mesure que <det class="fem">les </det>occurrences d' éléments sont rencontrées dans <det class="masc">l' </det>arbre source . </div>
<div class="p">Pour <det class="fem">les </det>transformations simples où <det class="fem">la </det>structure de <det class="masc">l' </det>arbre résultat est indépendante de <det class="fem">la </det>structure de <det class="masc">l' </det>arbre source , <det class="fem">une </det>feuille de styles peut souvent être réduite à <det class="masc">un </det>seul modèle , valable pour <det class="fem">la </det>génération de <det class="fem">la </det>totalité de <det class="masc">l' </det>arbre résultat . </div>
<div class="p">
<det class="fem">Les </det>transformations appliquées à <det class="masc">des </det>documents XML représentant <det class="fem">des </det>données sont souvent de <det class="masc">ce </det>type ( voir [ D.2 Exemple de données ] ) . </div>
<div class="p">XSLT offre <det class="fem">la </det>possibilité d' utiliser <det class="fem">une </det>syntaxe simplifiée pour <det class="masc">ce </det>type de feuilles de style ( voir [ 2.3 Feuille de style sous forme d' élément littéral résultat ] ) . </div>
<div class="p">
<det class="masc">L' </det>instanciation d' <det class="masc">un </det>modèle se fait toujours par rapport à <det class="masc">un </det>noeud courant et <det class="fem">une </det>liste de noeuds courante . </div>
<div class="p">
<det class="masc">Le </det>noeud courant est toujours membre de <det class="fem">la </det>liste de noeuds courante . </div>
<div class="p">Plusieurs opérations dans XSLT sont relatives <det class="masc">au </det>noeud courant . </div>
<div class="p">Seules quelques instructions permettent de changer <det class="fem">la </det>liste de noeuds courante ou <det class="masc">le </det>noeud courant ( voir [ 5 Règles modèle ] et [ 8 Répétition ] ) ; Durant <det class="masc">l' </det>instanciation de <det class="masc">l' </det>une de <det class="fem">ces </det>instructions , <det class="fem">la </det>liste de noeuds courante est modifiée et forme <det class="fem">une </det>nouvelle liste de noeuds courante dont <det class="masc">les </det>éléments deviennent , chacun à <det class="fem">leur </det>tour , <det class="masc">le </det>noeud courant . </div>
<div class="p">A <det class="fem">la </det>fin de <det class="masc">ce </det>processus , <det class="masc">le </det>noeud courant et <det class="fem">la </det>liste de noeuds courante redeviennent <det class="masc">ce </det>qu' ils étaient avant instanciation de <det class="masc">l' </det>instruction . </div>
<div class="p">XSLT utilise <det class="masc">le </det>langage d' expression défini par [ XPath ] pour sélectionner <det class="masc">les </det>éléments à traiter , <det class="masc">les </det>traitements conditionnels et <det class="fem">la </det>génération de texte . </div>
<div class="p">XSLT fournit deux ouvertures pour étendre <det class="masc">le </det>langage , <det class="masc">l' </det>une pour étendre <det class="masc">le </det>jeu d' instructions d' utilisables dans <det class="masc">les </det>modèles et une autre pour étendre <det class="masc">l' </det>ensemble <det class="fem">des </det>fonctions utilisables dans <det class="masc">les </det>expressions XPath . </div>
<div class="p">
<det class="fem">Ces </det>ouvertures reposent toutes <det class="masc">les </det>deux sur <det class="masc">l' </det>utilisation <det class="masc">des </det>espaces <det class="masc">des </det>noms XML . <det class="fem">Cette </det>version de XSLT ne définit pas <det class="masc">le </det>mécanisme d' implémentation de <det class="fem">ces </det>ouvertures . </div>
<div class="p">Voir [ 14 Extensions ] . </div>
<div class="p">NOTE : <det class="masc">Le </det>groupe de travail XSL prévoit de définir <det class="masc">ce </det>mécanisme soit dans <det class="fem">une </det>future version de <det class="fem">cette </det>spécification soit dans <det class="fem">une </det>spécification séparée . </div>
<div class="p">
<det class="fem">La </det>signification <det class="fem">des </det>règles d' écriture <det class="masc">des </det>éléments spécifiques à <det class="fem">la </det>syntaxe XSLT est fournie <det class="masc">au </det>chapitre [ 18 Notation ] . </div>
<div class="p">
<det class="masc">Les </det>types MIME text / xml et application / xml [ RFC2376 ] devraient être utilisés pour <det class="fem">les </det>feuilles de style XSLT . Il est possible qu' <det class="masc">un </det>type de média soit spécifiquement associé à <det class="fem">une </det>feuille de style XSLT ; dans <det class="masc">ce </det>cas , <det class="masc">ce </det>type de média est également autorisé . </div>
<div class="p">2 Structure <det class="fem">des </det>feuilles de style 2.1 Espace de noms XSLT <det class="masc">L' </det>URI de <det class="masc">l' </det>espace de noms XSLT est : http : / / www . w3 . org / 1999 / XSL / Transform . </div>
<div class="p">NOTE : <det class="fem">La </det>valeur 1999 se trouvant dans <det class="masc">l' </det>URI indique <det class="masc">l' </det>année d' attribution de <det class="masc">l' </det>URI par <det class="masc">le </det>W3C . Cela n' indique pas <det class="fem">la </det>version de XSLT utilisée ; <det class="fem">cette </det>dernière étant spécifiée par <det class="masc">des </det>attributs ( voir [ 2.2 <det class="masc">L' </det>élément de feuille de styles ] et [ 2.3 Feuille de style sous <det class="fem">la </det>forme d' élément littéral résultat ] ) . </div>
<div class="p">
<det class="masc">Les </det>processeurs XSLT doivent utiliser <det class="masc">le </det>mécanisme <det class="masc">des </det>espaces de noms [ Noms XML ] pour reconnaître <det class="masc">les </det>éléments et <det class="masc">les </det>attributs de <det class="masc">cet </det>espace de noms . </div>
<div class="p">
<det class="masc">Les </det>éléments de <det class="masc">l' </det>espace de noms XSLT sont reconnus uniquement dans <det class="fem">la </det>feuille de styles et non dans <det class="masc">le </det>document source . </div>
<div class="p">
<det class="fem">La </det>liste complète <det class="masc">des </det>éléments XSLT prédéfinis est spécifiée dans [ B Récapitulatif <det class="masc">des </det>éléments de syntaxe ] . </div>
<div class="p">
<det class="masc">Les </det>constructeurs informatique ne doivent pas étendre <det class="masc">l' </det>espace de noms XSLT avec <det class="masc">des </det>éléments ou <det class="masc">des </det>attributs nouveaux . </div>
<div class="p">Toute extension doit se présenter sous <det class="fem">la </det>forme d' <det class="masc">un </det>nouvel espace de noms séparé . </div>
<div class="p">Chaque espace de noms utilisé pour <det class="fem">des </det>instructions additionnelles doit être identifié <det class="masc">au </det>moyen <det class="masc">du </det>mécanisme d' extension d' élément spécifié dans [ 14.1 Éléments extension ] . </div>
<div class="p">
<det class="fem">Cette </det>spécification utilise <det class="masc">le </det>préfixe xsl : pour référencer <det class="masc">les </det>éléments de <det class="masc">l' </det>espace de noms XSLT . Cependant , <det class="fem">les </det>feuilles de style XSLT sont libres d' utiliser n' importe quel préfixe , à condition qu' il y ait <det class="fem">une </det>déclaration d' espace de noms liant <det class="masc">le </det>préfixe à <det class="masc">l' </det>URI de <det class="masc">l' </det>espace de noms XSLT . <det class="masc">Un </det>élément appartenant à <det class="masc">l' </det>espace de noms XSLT peut avoir n' importe quel attribut n' appartenant pas à <det class="masc">l' </det>espace de noms XSLT , à condition que <det class="masc">le </det>nom étendu de <det class="masc">l' </det>attribut ne soit pas <det class="fem">une </det>URI d' espace de noms nulle . </div>
<div class="p">
<det class="fem">La </det>présence de tels attributs ne doit pas modifier <det class="masc">le </det>comportement <det class="masc">des </det>éléments XSLT et <det class="fem">des </det>fonctions définies dans <det class="masc">ce </det>document . </div>
<div class="p">Ainsi , <det class="masc">un </det>processeur XSLT est toujours libre d' ignorer de pareils attributs , et , ce faisant , n' a pas à signaler d' erreur quand il ne reconnaît pas <det class="masc">l' </det>URI de <det class="masc">l' </det>espace <det class="masc">des </det>noms . </div>
<div class="p">De tels attributs peuvent fournir , par exemple , <det class="masc">des </det>identificateurs uniques , <det class="fem">des </det>indications d' optimisation ou de <det class="fem">la </det>documentation . </div>
<div class="p">
<det class="fem">Une </det>erreur doit être produite quand <det class="masc">des </det>éléments de <det class="masc">l' </det>espace de noms XSLT ont <det class="masc">des </det>attributs dont <det class="masc">les </det>noms étendus ont <det class="fem">des </det>URI nulles ( par exemple : <det class="masc">des </det>attributs sans noms préfixés ) , exception faite <det class="masc">des </det>noms d' attributs définis dans <det class="fem">la </det>présente spécification . </div>
<div class="p">NOTE : <det class="fem">Les </det>conventions utilisées pour <det class="masc">les </det>noms <det class="masc">des </det>éléments XSLT , <det class="masc">les </det>attributs et <det class="fem">les </det>fonctions font que tous <det class="masc">les </det>noms tous écrits en lettres minuscules , utilisent <det class="masc">le </det>trait d' union pour séparer <det class="masc">les </det>mots et n' utilisent <det class="fem">les </det>abréviations que si elles existent déjà dans <det class="fem">la </det>syntaxe <det class="masc">du </det>langage en question , comme par exemple XML ou HTML . 2.2 <det class="masc">L' </det>élément feuille de styles <det class="masc">Un </det>élément fils de <det class="masc">l' </det>élément xsl : stylesheet est appelé élément de haut niveau . </div>
<div class="p">
<det class="masc">L' </det>exemple suivant montre <det class="fem">la </det>structure d' <det class="fem">une </det>feuille de styles . </div>
<div class="p">
<det class="masc">Les </det>points de suspension ( ... ) indiquent où <det class="fem">les </det>valeurs et <det class="masc">les </det>contenus d' attributs ont été omis . </div>
<div class="p">Bien que <det class="masc">cet </det>exemple montre <det class="masc">un </det>cas d' utilisation de chacun <det class="masc">des </det>éléments autorisés , <det class="fem">les </det>feuilles de style peuvent en contenir de zéro à plusieurs occurrences . </div>
<div class="p">
<det class="masc">L' </det>ordre avec lequel <det class="masc">les </det>fils de <det class="masc">l' </det>élément xsl : stylesheet apparaissent n' est significatif que pour <det class="masc">les </det>éléments xsl : import et <det class="fem">les </det>récupérations d' erreurs . </div>
<div class="p">
<det class="masc">Les </det>utilisateurs ont <det class="fem">la </det>liberté d' ordonner <det class="masc">les </det>éléments selon <det class="fem">leurs </det>préférences et <det class="masc">les </det>outils de création de feuilles de styles n' ont pas besoins de contrôler <det class="masc">l' </det>ordre dans lequel apparaissent <det class="masc">les </det>éléments . </div>
<div class="p">De plus , <det class="masc">l' </det>élément xsl : stylesheet peut contenir n' importe quel élément n' appartenant pas à <det class="masc">l' </det>espace de noms XSLT , à <det class="fem">la </det>condition que <det class="masc">l' </det>URI de <det class="masc">l' </det>espace de noms <det class="masc">du </det>nom étendu de <det class="masc">l' </det>élément soit non nulle . </div>
<div class="p">
<det class="fem">La </det>présence de tels éléments de haut niveau ne doit changer <det class="masc">le </det>comportement ni <det class="masc">des </det>éléments ni <det class="fem">des </det>fonctions XSLT définis dans <det class="masc">ce </det>document ; ainsi , il ne doit pas être permis de permettre <det class="fem">la </det>modification <det class="fem">des </det>règles d' <det class="masc">un </det>élément de haut niveau comme xsl : apply-templates pour résoudre , par exemple , <det class="masc">des </det>conflits . </div>
<div class="p">Ainsi , <det class="masc">un </det>processeur XSLT est toujours libre d' ignorer <det class="masc">ces </det>éléments de haut niveau , et il doit ignorer <det class="masc">un </det>élément de haut niveau sans générer d' erreur s' il ne reconnaît pas <det class="masc">l' </det>URI de <det class="masc">l' </det>espace de noms . </div>
<div class="p">De tels éléments peuvent , par exemple , fournir : <det class="fem">les </det>informations utilisées par <det class="fem">les </det>extensions d' éléments ou <det class="masc">l' </det>extension de fonctions ( voir [ 14 Extensions ] ) , <det class="fem">les </det>informations concernant <det class="masc">l' </det>utilisation de <det class="masc">l' </det>arbre résultat , <det class="fem">les </det>informations concernant <det class="masc">l' </det>obtention de <det class="masc">l' </det>arbre source , <det class="fem">les </det>meta-données de <det class="fem">la </det>feuille de styles , <det class="fem">une </det>documentation structurée de <det class="fem">la </det>feuille de styles . </div>
<div class="p">2.3 Feuille de style sous <det class="fem">la </det>forme d' <det class="masc">un </det>élément littéral résultat <det class="fem">Une </det>syntaxe simplifiée existe pour <det class="fem">les </det>feuilles de style et consiste en <det class="masc">un </det>simple et unique modèle appliqué <det class="masc">au </det>noeud racine . </div>
<div class="p">
<det class="fem">La </det>feuille de styles peut consister en <det class="masc">un </det>simple élément littéral résultat ( voir [ 7.1.1 <det class="masc">Les </det>éléments littéraux résultats ] ) . </div>
<div class="p">
<det class="fem">Une </det>telle feuille de styles est équivalente à <det class="fem">une </det>feuille de styles qui utiliserait <det class="masc">un </det>élément xsl : stylesheet contenant <det class="fem">une </det>règle modèle qui contiendrait , elle -même , <det class="masc">un </det>élément littéral résultat ; <det class="fem">la </det>règle modèle ayant comme motif de recherche <det class="masc">le </det>caractère / . </div>
<div class="p">Par exemple : Par conséquent , <det class="fem">la </det>syntaxe simplifiée ne devrait pas être utilisée pour <det class="fem">les </det>feuilles de style XSLT pouvant être utilisées dans pareils cas . </div>
<div class="p">
<det class="fem">Cette </det>situation peut se produire , par exemple , lorsqu' <det class="fem">une </det>feuille de styles XSLT est transmise par messagerie avec <det class="masc">un </det>type MIME associé tel que text / xml ou application / xml à <det class="masc">un </det>receveur qui utilisera <det class="masc">le </det>type MIME pour déterminer comment traiter <det class="masc">le </det>message . </div>
<div class="p">2.4 Noms qualifiés <det class="masc">Le </det>nom d' <det class="masc">un </det>objet XSLT interne , en particulier <det class="masc">les </det>modèles nommés ( voir [ 6 Modèles nommés ] ) , <det class="masc">un </det>mode ( voir [ 5.7 Modes ] ) , <det class="masc">un </det>ensemble d' attributs ( voir [ 7.1.4 Ensembles d' attributs nommés ] ) , <det class="fem">une </det>clef ( voir [ 12.2 Clés ] ) , <det class="masc">un </det>format décimal ( voir [ 12.3 Formatage de nombres ] ) , <det class="fem">une </det>variable ou <det class="masc">un </det>paramètre ( voir [ 11 Variables et Paramètres ] ) est spécifié comme étant <det class="masc">un </det>nom qualifié ( QName ) . </div>
<div class="p">S' il dispose d' <det class="masc">un </det>préfixe , alors celui -là est développé en <det class="fem">une </det>référence d' URI en lui appliquant <det class="fem">les </det>déclarations d' espaces de noms applicables <det class="masc">aux </det>attributs dans lesquels <det class="masc">le </det>nom apparaît . </div>
<div class="p">
<det class="masc">Le </det>nom étendu , comprenant <det class="fem">la </det>partie locale <det class="masc">du </det>nom et <det class="fem">la </det>possible référence vide à <det class="masc">l' </det>URI , est utilisé comme nom de <det class="masc">l' </det>objet . </div>
<div class="p">
<det class="masc">L' </det>espace de noms par défaut n' est pas utilisé pour <det class="masc">les </det>noms sans préfixes . </div>
<div class="p">2.5 Traitement de <det class="fem">la </det>compatibilité ascendante <det class="masc">Un </det>élément active <det class="masc">le </det>traitement par compatibilité ascendante pour lui -même , <det class="masc">ses </det>attributs , <det class="masc">ses </det>descendants et <det class="masc">leurs </det>attributs dans <det class="masc">le </det>cas où c' est <det class="masc">un </det>élément xsl : stylesheet dont <det class="masc">l' </det>attribut version est différent de 1.0 , ou c' est <det class="masc">un </det>élément littéral résultat ayant <det class="masc">un </det>attribut xsl : version dont <det class="fem">la </det>valeur est différente de 1.0 , or lorsque c' est <det class="masc">un </det>élément littéral résultat qui n' a pas <det class="masc">un </det>attribut xsl : version et qui est <det class="masc">l' </det>élément document d' <det class="fem">une </det>feuille de styles utilisant <det class="fem">la </det>syntaxe simplifiée ( voir [ 2.3 Feuille de style sous forme d' élément littéral résultat ] ) . </div>
<div class="p">
<det class="masc">Un </det>élément littéral résultat ayant <det class="masc">un </det>attribut xsl : version dont <det class="fem">la </det>valeur est égale à 1.0 désactive <det class="masc">le </det>mode de traitement par compatibilité ascendante pour lui -même , <det class="masc">ses </det>attributs , <det class="masc">ses </det>descendants et <det class="masc">leurs </det>attributs . </div>
<div class="p">Si <det class="masc">un </det>élément est traité en mode compatibilité ascendante alors : s' il s' agit d' <det class="masc">un </det>élément de haut niveau et que XSLT 1.0 ne permet pas à <det class="masc">cet </det>élément d' être de haut niveau , alors il doit être ignoré ainsi que <det class="masc">son </det>contenu ; S' il s' agit d' <det class="masc">un </det>élément d' <det class="masc">un </det>modèle qui n' est pas autorisé comme tel par XSLT 1.0 , alors , si <det class="masc">l' </det>élément n' est pas instancié , aucune erreur ne doit pas être signalée et si <det class="masc">l' </det>élément est instancié , alors XSLT doit exécuter <det class="masc">un </det>" recours " pour <det class="masc">l' </det>élément tel que spécifié dans [ 15 Reprise ] ; Si <det class="masc">l' </det>élément a <det class="masc">un </det>attribut non autorisé par XSLT 1.0 ou si <det class="masc">l' </det>élément a <det class="masc">un </det>attribut optionnel dont <det class="fem">la </det>valeur n' est pas autorisée par XSLT 1.0 , alors <det class="masc">l' </det>attribut doit être ignoré . </div>
<div class="p">Ainsi , bien que <det class="fem">la </det>feuille de styles suivante inclus <det class="masc">des </det>éléments de <det class="masc">l' </det>espace de noms XSLT non définis dans <det class="fem">cette </det>spécification , n' importe quel processeur XSLT 1.0 doit être capable de traiter <det class="fem">cette </det>feuille de styles suivante sans produire d' erreur : Si <det class="fem">une </det>expression se produit dans <det class="masc">un </det>attribut qui est traité en mode compatibilité ascendante , alors <det class="masc">un </det>processeur XSLT doit rattraper <det class="fem">les </det>erreurs de traitement de <det class="masc">l' </det>expression de <det class="fem">la </det>manière suivante : Si <det class="masc">l' </det>expression n' est pas conforme à <det class="fem">la </det>syntaxe permise par <det class="fem">la </det>grammaire XPath , alors il ne faut pas signaler d' erreurs tant que <det class="masc">l' </det>expression n' est pas évaluée ; Si <det class="masc">l' </det>expression appelle <det class="fem">une </det>fonction dont <det class="masc">le </det>nom n' est pas préfixé et qui ne fait pas partie de <det class="fem">la </det>librairie XSLT , alors il ne faut pas signaler d' erreurs tant que <det class="fem">la </det>fonction n' est pas appelée ; Si <det class="masc">l' </det>expression fait <det class="masc">un </det>appel de fonction dont <det class="masc">les </det>arguments , en nombre ou en type , ne sont pas autorisés par XSLT , alors il ne faut pas signaler d' erreur tant que <det class="fem">la </det>fonction n' est pas appelée . </div>
<div class="p">2.6 Combinaison de feuilles de style XSLT fournit deux mécanismes pour combiner <det class="fem">des </det>feuilles de style : <det class="masc">un </det>mécanisme d' inclusion permettant <det class="fem">aux </det>feuilles de style d' être combinées sans changer <det class="fem">la </det>sémantique <det class="fem">des </det>feuilles de styles à combiner , et <det class="masc">un </det>mécanisme d' import permettant <det class="fem">aux </det>feuilles de styles de se recouvrir mutuellement . </div>
<div class="p">2.6.1 Inclusion de feuilles de style 2.6.2 Import <det class="fem">des </det>feuilles de style Alors , <det class="masc">l' </det>ordre de préséance d' import ( faible d' abord ) est D , B , E , C , A. NOTE : Puisque <det class="masc">les </det>éléments xsl : import doivent apparaître avant toute définition ou règle modèle , <det class="fem">une </det>implémentation traitant <det class="fem">des </det>feuilles de style importées , <det class="masc">au </det>moment ou elle rencontre <det class="masc">l' </det>élément xsl : import va rencontrer <det class="fem">des </det>définitions et <det class="fem">des </det>règles modèle dans <det class="masc">l' </det>ordre croissant de préséance d' import . </div>
<div class="p">En général , <det class="fem">une </det>définition ou règle modèle avec <det class="fem">une </det>préséance d' import supérieure prend <det class="fem">la </det>préséance sur <det class="fem">une </det>définition ou <det class="fem">une </det>règle modèle ayant <det class="fem">une </det>préséance d' import plus faible . </div>
<div class="p">Ceci est donné avec plus de détail pour chaque type de définition ou de règle modèle . </div>
<div class="p">
<det class="masc">L' </det>importation directe ou indirecte d' <det class="fem">une </det>feuille de styles par elle -même est <det class="fem">une </det>erreur . </div>
<div class="p">A partir de là , <det class="masc">le </det>cas où <det class="fem">une </det>feuille de styles avec <det class="fem">une </det>URI particulière est importée à plusieurs endroits n' est pas traitée de manière particulière . </div>
<div class="p">
<det class="masc">L' </det>arbre d' import aura <det class="masc">un </det>élément xsl : stylesheet différent à chaque endroit où elle est importée . </div>
<div class="p">NOTE : Lorsque xsl : apply-imports est utilisé ( voir [ 5.6 Passer outre <det class="masc">des </det>règles modèles ] ) , <det class="masc">le </det>comportement peut être différent de celui qui aurait été si <det class="fem">la </det>feuille de styles avait été importée simplement avec <det class="fem">une </det>préséance d' import supérieure . </div>
<div class="p">2.7 Feuilles de style encapsulées Normalement <det class="fem">une </det>feuille de styles XSLT est <det class="masc">un </det>document XML à part entière ayant <det class="masc">l' </det>élément xsl : stylesheet comme élément racine . </div>
<div class="p">Cependant , <det class="fem">une </det>feuille de styles XSLT peut aussi être encapsulée dans <det class="fem">une </det>autre ressource . </div>
<div class="p">Deux types d' encapsulation sont possibles : <det class="fem">la </det>feuille de styles XSLT peut être encapsulée d' <det class="fem">une </det>manière textuelle dans <det class="fem">une </det>ressource non XML , ou <det class="masc">l' </det>élément xsl : stylesheet peut survenir dans <det class="masc">un </det>document XML autrement que comme élément racine . </div>
<div class="p">Pour faciliter <det class="fem">la </det>deuxième forme d' encapsulation , <det class="masc">l' </det>élément xsl : stylesheet est autorisé à avoir <det class="masc">un </det>attribut ID permettant de lui attribuer un identifiant unique . </div>
<div class="p">NOTE : Dans <det class="masc">le </det>but d' utiliser <det class="masc">ce </det>type d' attribut avec <det class="fem">la </det>fonction id de XPath , il doit être déclaré dans <det class="fem">la </det>DTD comme étant <det class="masc">un </det>ID . <det class="masc">L' </det>exemple suivant montre comment <det class="masc">l' </det>instruction de traitement xml-stylesheet [ feuilles de style XML ] peut être utilisée pour permettre à <det class="masc">un </det>document de contenir <det class="fem">sa </det>propre feuille de styles . </div>
<div class="p">
<det class="masc">L' </det>adresse URI utilise <det class="fem">une </det>URI relative avec <det class="masc">un </det>fragment d' identification pour localiser <det class="masc">l' </det>élément xsl : stylesheet : 3 Modèle de données <det class="masc">Le </det>modèle de données utilisé par XSLT est <det class="masc">le </det>même que celui utilisé par XPath avec en plus ce qui est décrit dans <det class="fem">cette </det>section . </div>
<div class="p">XSLT travaille sur <det class="masc">les </det>documents de type source , résultat et feuille de styles en utilisant <det class="masc">le </det>même modèle de données . </div>
<div class="p">Deux documents XML ayant <det class="masc">le </det>même arbre seront traités de <det class="fem">la </det>même manière par XSLT . <det class="fem">Les </det>instructions de traitement et <det class="masc">les </det>commentaires de <det class="fem">la </det>feuille de styles sont ignorés : <det class="fem">la </det>feuille de styles est traitée comme si , ni <det class="masc">les </det>noeuds d' instructions de traitement , ni <det class="masc">les </det>noeuds de commentaires , n' étaient inclus dans <det class="masc">l' </det>arbre qui représente <det class="fem">la </det>feuille de styles . </div>
<div class="p">3.1 <det class="masc">Les </det>fils <det class="masc">du </det>noeud racine <det class="fem">Les </det>restrictions faites sur <det class="masc">les </det>fils <det class="masc">du </det>noeud racine sont levées pour <det class="masc">l' </det>arbre résultat . </div>
<div class="p">
<det class="masc">L' </det>arbre résultat peut avoir comme enfant n' importe quelle séquence de noeuds qu' il serait possible d' avoir pour <det class="masc">un </det>noeud d' élément . </div>
<div class="p">En particulier , il peut avoir pour enfant <det class="masc">des </det>noeuds textuels et n' importe quel nombre de noeuds d' éléments . </div>
<div class="p">Lorsqu' <det class="masc">un </det>arbre résultat est sauvegardé en utilisant <det class="fem">la </det>méthode d' écriture XML ( voir [ 16 Sortie ] ) , il est possible que <det class="masc">l' </det>arbre résultat ne soit pas <det class="masc">un </det>document XML bien formé ; toutefois , il sera toujours <det class="fem">une </det>entité générale externe validée bien formée . </div>
<div class="p">Lorsque <det class="masc">l' </det>arbre source est <det class="masc">le </det>résultat de <det class="masc">l' </det>analyse d' <det class="masc">un </det>document XML bien formé , alors <det class="masc">le </det>noeud racine de <det class="masc">l' </det>arbre source satisfait de facto <det class="fem">aux </det>restrictions normales qui sont de ne pas avoir <det class="masc">un </det>noeud texte comme enfant et exactement <det class="masc">un </det>seul élément enfant . </div>
<div class="p">Si <det class="masc">l' </det>arbre source est créé par d' autres moyens , par exemple en utilisant DOM , <det class="fem">les </det>restrictions habituelles sont levées pour <det class="masc">l' </det>arbre source comme pour <det class="masc">l' </det>arbre résultat . </div>
<div class="p">3.2 URI base A chaque noeud est associé <det class="fem">une </det>URI qu' on désigne comme étant <det class="masc">son </det>URI de base : elle est utilisée pour <det class="masc">le </det>remplacement <det class="fem">des </det>valeurs relatives <det class="masc">des </det>URI d' attributs par <det class="fem">des </det>URIs absolues . </div>
<div class="p">Si <det class="masc">un </det>élément ou <det class="fem">une </det>instruction de traitement survient dans <det class="fem">une </det>entité externe , alors <det class="masc">son </det>URI de base est <det class="masc">l' </det>URI de <det class="masc">l' </det>entité externe ; autrement , <det class="masc">l' </det>URI de base est <det class="masc">l' </det>URI de base <det class="masc">du </det>document . </div>
<div class="p">
<det class="masc">L' </det>URI de base <det class="masc">du </det>noeud document est <det class="masc">l' </det>URI de <det class="masc">l' </det>entité document . </div>
<div class="p">
<det class="masc">L' </det>URI de base d' <det class="masc">un </det>noeud textuel , d' <det class="masc">un </det>noeud commentaire , d' <det class="masc">un </det>noeud d' attribut ou d' <det class="masc">un </det>noeud d' espace de noms est <det class="masc">l' </det>URI de base <det class="masc">du </det>parent <det class="masc">du </det>noeud . </div>
<div class="p">3.3 Entités non valides <det class="masc">Le </det>noeud racine dispose de règles de correspondances qui fournissent <det class="masc">l' </det>URI de chaque entité non analysée déclarée dans <det class="fem">la </det>DTD de <det class="masc">ce </det>document . </div>
<div class="p">
<det class="masc">L' </det>URI est générée à partir <det class="fem">des </det>identificateurs système et publique spécifiés dans <det class="fem">la </det>déclaration de <det class="masc">l' </det>entité . </div>
<div class="p">
<det class="masc">Le </det>processeur XSLT peut utiliser <det class="masc">l' </det>identifiant publique pour générer <det class="masc">l' </det>URI d' <det class="fem">une </det>entité <det class="masc">au </det>lieu de celle spécifiée dans <det class="masc">l' </det>identifiant système . </div>
<div class="p">Si <det class="masc">le </det>processeur XSLT n' utilise pas <det class="masc">un </det>identifiant publique pour générer <det class="masc">l' </det>URI , il doit utiliser <det class="masc">l' </det>identifiant système ; si l' identifiant système est <det class="fem">une </det>URI relative , il doit être résolu et transformé en <det class="fem">une </det>URI absolue en utilisant comme URI de base , <det class="masc">l' </det>URI de <det class="fem">la </det>ressource contenant <det class="fem">la </det>déclaration de <det class="masc">l' </det>entité [ RFC2396 ] . </div>
<div class="p">3.4 Suppression <det class="masc">des </det>espaces blancs <det class="fem">Une </det>fois <det class="masc">l' </det>arbre pour <det class="masc">le </det>document source ou <det class="fem">la </det>feuille de styles construit , mais avant tout autre traitement XSLT , certains noeuds textuels sont supprimés . </div>
<div class="p">
<det class="masc">Un </det>noeud textuel est supprimé quand il ne contient que <det class="masc">des </det>caractères d' espaces blancs . </div>
<div class="p">Supprimer <det class="masc">le </det>noeud textuel revient à l' enlever de <det class="masc">l' </det>arbre . </div>
<div class="p">
<det class="masc">Le </det>processus de suppression prend en entrée <det class="masc">un </det>ensemble de noms d' éléments pour lesquels <det class="masc">les </det>caractères d' espaces blancs doivent être préservés . </div>
<div class="p">
<det class="masc">Le </det>processus de suppression est appliqué aussi bien <det class="fem">aux </det>feuilles de styles qu' <det class="masc">aux </det>documents source , cependant , <det class="masc">les </det>ensembles <det class="masc">des </det>noms d' éléments pour lesquels <det class="masc">les </det>caractères d' espaces blancs doivent être préservés sont déterminés différemment pour <det class="fem">les </det>feuilles de style et <det class="masc">les </det>documents source . </div>
<div class="p">
<det class="masc">Un </det>noeud textuel est préservé si <det class="masc">l' </det>une <det class="fem">des </det>conditions suivantes est vérifiée : <det class="masc">le </det>nom de <det class="masc">l' </det>élément parent <det class="masc">du </det>noeud textuel fait partie de <det class="masc">l' </det>ensemble contenant <det class="masc">les </det>noms <det class="masc">des </det>éléments dont on veut préserver <det class="masc">les </det>caractères d' espaces blancs . </div>
<div class="p">
<det class="masc">Le </det>noeud textuel contient <det class="masc">au </det>moins <det class="masc">un </det>caractère différent d' <det class="masc">un </det>espace blanc . </div>
<div class="p">Comme pour XML , <det class="masc">les </det>espaces blancs sont <det class="masc">les </det>caractères dont <det class="masc">les </det>codes hexadécimaux sont # x20 , # x9 , # xD ou # xA . <det class="masc">Le </det>premier <det class="masc">des </det>ancêtres <det class="masc">du </det>noeud textuel à avoir <det class="masc">l' </det>attribut xml : space renseigné en fixe <det class="fem">la </det>valeur à preserve ( en d' autres termes : il n' existe aucun élément entre <det class="masc">cet </det>ancêtre et <det class="masc">le </det>noeud textuel qui modifierait <det class="fem">la </det>valeur de <det class="masc">cet </det>attribut pour la remettre à default ) . </div>
<div class="p">Autrement <det class="masc">le </det>noeud texte est supprimé . </div>
<div class="p">
<det class="masc">Les </det>attributs xml : space ne sont pas supprimés de <det class="masc">l' </det>arbre . </div>
<div class="p">NOTE : Ceci sous-entend qu' <det class="masc">un </det>attribut xml : space est spécifié dans <det class="masc">un </det>élément littéral résultat et sera inclus dans <det class="masc">le </det>résultat . </div>
<div class="p">Pour <det class="fem">les </det>feuilles de style , <det class="masc">l' </det>ensemble <det class="masc">des </det>noms d' éléments préservant <det class="masc">les </det>caractères d' espaces blancs est simplement xsl : text . </div>
<div class="p">S' il reste plus d' <det class="fem">une </det>correspondance , c' est <det class="fem">une </det>erreur . </div>
<div class="p">
<det class="masc">Un </det>processeur XSLT peut signaler <det class="masc">l' </det>erreur ; s' il ne signale pas <det class="masc">l' </det>erreur , il doit la rattraper en choisissant , parmi <det class="fem">les </det>correspondances restantes , celle utilisée en dernier dans <det class="fem">la </det>feuille de styles . </div>
<div class="p">4 Expressions XSLT utilise <det class="masc">le </det>langage d' expression défini par XPath [ XPath ] . </div>
<div class="p">
<det class="fem">Les </det>expressions sont utilisées dans XSLT pour <det class="fem">une </det>variété de possibilités incluant : sélection de noeuds pour traitement ; spécification <det class="fem">des </det>conditions pour <det class="fem">les </det>différentes manières de traitement d' <det class="masc">un </det>noeud ; génération de texte à insérer dans <det class="masc">l' </det>arbre résultat . </div>
<div class="p">
<det class="fem">Une </det>expression doit correspondre à <det class="fem">la </det>règle de production Expr de XPath . </div>
<div class="p">
<det class="fem">Les </det>expressions interviennent comme valeurs de certains attributs d' éléments XSLT et entre accolades dans <det class="masc">des </det>modèles de valeurs d' attributs . </div>
<div class="p">Dans XSLT , <det class="fem">une </det>expression autonome ( c' est à dire : <det class="fem">une </det>expression qui ne fait partie d' aucune autre expression ) prend <det class="masc">son </det>contexte comme suit : <det class="masc">Le </det>noeud contextuel est <det class="masc">le </det>noeud courant <det class="fem">la </det>position contextuelle vient de <det class="fem">la </det>position <det class="masc">du </det>noeud courant dans <det class="fem">la </det>liste courante de noeuds ; <det class="fem">la </det>première position est 1 <det class="fem">la </det>dimension contextuelle est issue de <det class="fem">la </det>dimension de <det class="fem">la </det>liste courante de noeuds <det class="masc">les </det>liens variables sont ceux dans <det class="masc">le </det>périmètre de <det class="masc">l' </det>élément ayant <det class="masc">un </det>attribut dans lequel <det class="masc">l' </det>expression se produit ( voir [ 11 Variables et Paramètres ] ) <det class="masc">l' </det>ensemble de déclarations d' espace de noms sont celles dans <det class="masc">le </det>champ de <det class="masc">l' </det>élément ayant <det class="masc">l' </det>attribut dans lequel <det class="masc">l' </det>expression se produit ; ceci inclus <det class="fem">la </det>déclaration implicite <det class="masc">du </det>préfixe xml exigé par <det class="fem">la </det>Recommandation <det class="masc">des </det>espaces de noms [ Noms XML ] ; <det class="masc">l' </det>espace de noms par défaut ( comme déclaré par xmlns ) n' appartient pas à <det class="masc">cet </det>ensemble . <det class="fem">la </det>librairie de fonctions est représentée par <det class="fem">la </det>librairie de fonctions de base augmentée <det class="fem">des </det>fonctions additionnelles définies dans [ 12 Fonctions additionnelles ] et <det class="fem">des </det>fonctions d' extension décrites dans [ 14 Extensions ] ; Lorsqu' <det class="fem">une </det>expression appelle <det class="fem">une </det>quelconque autre fonction , <det class="fem">une </det>erreur doit être générée . </div>
<div class="p">5 Règles modèle 5.1 Modèle de traitement <det class="fem">Une </det>liste de noeuds sources est traitée pour créer <det class="masc">un </det>fragment de <det class="masc">l' </det>arbre résultat . </div>
<div class="p">
<det class="masc">L' </det>arbre résultat est construit par traitement d' <det class="fem">une </det>liste contenant juste <det class="masc">le </det>noeud racine . </div>
<div class="p">
<det class="fem">Une </det>liste de noeuds sources est traitée par rajout successif <det class="masc">des </det>arbres résultants <det class="masc">du </det>traitement successif de chaque noeud de <det class="fem">la </det>liste . </div>
<div class="p">
<det class="masc">Un </det>noeud est traité en trouvant toutes <det class="fem">les </det>règles modèle dont <det class="masc">les </det>motifs correspondent <det class="masc">au </det>noeud , et en choisissant <det class="masc">le </det>meilleur parmi elles ; <det class="fem">la </det>règle modèle retenue est alors instanciée en considérant <det class="masc">le </det>noeud comme noeud courant et <det class="fem">la </det>liste de noeuds source comme liste courante de noeuds . </div>
<div class="p">Typiquement , <det class="masc">un </det>modèle contient <det class="fem">des </det>instructions traitant <det class="fem">une </det>liste de noeuds source sélectionnés . </div>
<div class="p">
<det class="masc">Le </det>processus de correspondance , instanciation et sélection se poursuit récursivement et se termine lorsque aucun nouveau noeud source n' est sélectionné pour traitement . </div>
<div class="p">
<det class="masc">Les </det>outils sont libres de traiter <det class="masc">le </det>document source par n' importe quel moyen <det class="masc">du </det>moment ou <det class="masc">le </det>résultat produit est <det class="masc">le </det>même que s' il était traité par <det class="masc">ce </det>modèle de traitement . </div>
<div class="p">5.2 Modèles <det class="fem">Les </det>règles modèle identifient <det class="masc">les </det>noeuds auxquels elles s' appliquent en utilisant <det class="masc">un </det>motif . </div>
<div class="p">
<det class="masc">Les </det>motifs sont aussi bien utilisés dans <det class="fem">des </det>règles modèle que pour <det class="fem">la </det>numérotation ( voir [ 7.7 Numérotation ] ) ou <det class="fem">la </det>déclaration de clés ( voir [ 12.2 Clés ] ) . </div>
<div class="p">
<det class="masc">Un </det>motif spécifie <det class="masc">un </det>ensemble de conditions sur <det class="masc">un </det>noeud . </div>
<div class="p">
<det class="masc">Un </det>noeud satisfaisant <det class="fem">les </det>conditions correspond <det class="masc">au </det>motif ; <det class="masc">un </det>noeud qui ne satisfait pas <det class="fem">les </det>conditions ne correspond pas <det class="masc">au </det>motif . </div>
<div class="p">
<det class="fem">La </det>syntaxe pour <det class="masc">les </det>motifs est <det class="masc">un </det>sous-ensemble de <det class="fem">la </det>syntaxe pour <det class="fem">les </det>expressions . </div>
<div class="p">En particulier , <det class="masc">les </det>chemins de localisation soumis à certaines restrictions peuvent être utilisés comme <det class="masc">des </det>motifs . </div>
<div class="p">
<det class="fem">Une </det>expression , qui est aussi <det class="masc">un </det>motif , donne toujours comme résultat <det class="masc">un </det>objet qui est <det class="masc">un </det>ensemble de noeuds . </div>
<div class="p">
<det class="masc">Un </det>noeud correspond à <det class="masc">un </det>motif si <det class="masc">le </det>noeud est membre <det class="masc">du </det>résultat de <det class="masc">l' </det>évaluation <det class="masc">du </det>motif , considéré alors comme expression respectant <det class="masc">un </det>certain contexte ; <det class="masc">ce </det>cas se produit quand <det class="masc">le </det>noeud contextuel est <det class="masc">le </det>noeud en train d' être mis en correspondance ou <det class="masc">l' </det>un de <det class="masc">ses </det>ancêtres . </div>
<div class="p">Voici quelques exemples de motifs : para correspond à n' importe quel élément para * correspond à n' importe quel élément chapter appendix trouve tous <det class="masc">les </det>éléments chapter et appendix olist / item trouve tous <det class="masc">les </det>éléments item ayant olist comme parent appendix//para correspond à n' importe quel élément para dont <det class="masc">un </det>ancêtre est appendix / correspond <det class="masc">au </det>noeud racine text ( ) correspond à n' importe quel noeud textuel processing-instruction ( ) correspond à n' importe quel instruction de traitement node ( ) correspond à n' importe quel noeud autre qu' <det class="masc">un </det>noeud attribut et que <det class="masc">le </det>noeud racine id ( " W11 " ) correspond à <det class="masc">l' </det>élément ayant l' identifiant unique W11 para [ 1 ] correspond <det class="masc">au </det>premier <det class="masc">des </det>éléments para d' <det class="masc">un </det>parent * [ position ( ) =1 and self : :para ] correspond à n' importe quel élément para qui est <det class="masc">le </det>premier élément fils de <det class="masc">son </det>parent para [ last ( ) =1 ] correspond à n' importe quel élément para qui est <det class="masc">l' </det>unique élément para de <det class="masc">son </det>élément parent items / item [ position ( ) &gt; 1 ] correspond à tous <det class="masc">les </det>éléments item , autres que <det class="masc">le </det>premier , et dont <det class="masc">le </det>parent est items item [ position ( ) mod 2 = 1 ] serait vrai pour tous <det class="masc">les </det>fils item de numéro d' ordre impair par rapport à <det class="masc">leur </det>parent . div [ @class="appendix"]//p correspond à tous <det class="masc">les </det>éléments p ayant <det class="masc">un </det>ancêtre div pour lequel <det class="masc">l' </det>attribut class prend <det class="fem">la </det>valeur appendix @class correspond à tous <det class="masc">les </det>attributs class ( pas à tous <det class="masc">les </det>éléments ayant <det class="masc">l' </det>attribut class ) @ * correspond à n' importe quel attribut <det class="masc">Un </det>motif doit concorder avec <det class="fem">la </det>grammaire <det class="masc">des </det>motifs ( Pattern ) . </div>
<div class="p">
<det class="masc">Un </det>motif est <det class="masc">un </det>ensemble de motifs de chemins de localisation séparés par . </div>
<div class="p">
<det class="masc">Un </det>motif de chemin de localisation est <det class="masc">un </det>chemin de localisation dont <det class="fem">les </det>étapes n' utilisent que <det class="masc">les </det>axes child ou attribute . </div>
<div class="p">Bien que <det class="masc">les </det>motifs ne doivent pas utiliser <det class="masc">l' </det>axe descendant-or-self , ils peuvent utiliser <det class="masc">l' </det>opérateur / / tout aussi bien que <det class="masc">l' </det>opérateur / . </div>
<div class="p">
<det class="masc">Les </det>motifs de chemins de localisation peuvent aussi commencer par <det class="masc">un </det>appel de fonction id ou key avec <det class="masc">un </det>argument littéral . </div>
<div class="p">
<det class="masc">Les </det>prédicats d' <det class="masc">un </det>motif peuvent utiliser n' importe quelle expression exactement comme ceux <det class="masc">des </det>chemins de localisation . </div>
<div class="p">
<det class="masc">Un </det>motif est conçu pour concorder avec <det class="masc">un </det>noeud si et seulement s' il existe <det class="masc">un </det>contexte tel que lorsque <det class="masc">le </det>motif est évalué comme <det class="fem">une </det>expression dans <det class="masc">ce </det>contexte , <det class="masc">le </det>noeud appartient à <det class="masc">l' </det>ensemble de noeuds résultat . </div>
<div class="p">Lorsqu' <det class="fem">une </det>correspondance est en train d' être établie pour <det class="masc">un </det>noeud , <det class="masc">les </det>contextes possibles ont <det class="masc">un </det>noeud contextuel qui est <det class="masc">le </det>noeud en train d' être mis en correspondance ou <det class="masc">un </det>de <det class="masc">ses </det>ancêtres , et <det class="fem">une </det>liste de noeuds contextuels réduite <det class="masc">au </det>seul noeud contextuel . </div>
<div class="p">Par exemple , p concorde avec n' importe quel élément p , parce que pour tout p , si <det class="masc">l' </det>expression p est évaluée dans <det class="masc">le </det>contexte de <det class="masc">son </det>élément parent , alors <det class="masc">cet </det>élément p appartiendra à <det class="masc">l' </det>ensemble <det class="masc">des </det>noeuds résultat . </div>
<div class="p">NOTE : Cela correspond même à <det class="masc">un </det>élément p qui serait <det class="masc">l' </det>élément document puisque <det class="fem">la </det>racine <det class="masc">du </det>document est <det class="masc">le </det>parent de <det class="masc">l' </det>élément document . </div>
<div class="p">Bien que <det class="fem">la </det>sémantique <det class="masc">des </det>motifs soit indirectement spécifiée en terme d' évaluation d' expressions , il est facile de comprendre directement <det class="fem">la </det>signification <det class="masc">des </det>motifs sans devoir les considérer comme <det class="fem">des </det>évaluations d' expression . </div>
<div class="p">Dans <det class="masc">un </det>motif , indique <det class="fem">les </det>alternatives ; <det class="masc">un </det>motif avec un ou plusieurs séparant différentes alternatives concorde si <det class="masc">l' </det>une <det class="fem">des </det>alternatives concorde . </div>
<div class="p">
<det class="fem">La </det>correspondance pour <det class="masc">un </det>motif composé d' <det class="fem">une </det>séquence d' étapes ( StepPatterns ) séparés par / ou / / est faite de droite vers <det class="fem">la </det>gauche . </div>
<div class="p">
<det class="fem">La </det>concordance <det class="masc">du </det>motif ne se produit que si <det class="masc">l' </det>étape <det class="fem">la </det>plus à droite concorde et qu' <det class="masc">un </det>élément approprié concorde avec <det class="masc">le </det>reste <det class="masc">du </det>motif ; si <det class="masc">le </det>séparateur est / alors seul <det class="masc">le </det>parent est <det class="masc">un </det>élément approprié ; si <det class="masc">le </det>séparateur est / / , alors tout élément ancêtre peut être <det class="masc">un </det>élément approprié . </div>
<div class="p">
<det class="fem">Une </det>séquence d' étape ( StepPatterns ) qui utilise <det class="masc">l' </det>axe fils concorde si <det class="masc">le </det>test de noeud ( NodeTest ) est vrai pour <det class="masc">le </det>noeud et si <det class="masc">le </det>noeud n' est pas <det class="masc">un </det>noeud d' attribut . </div>
<div class="p">
<det class="fem">Une </det>séquence d' étapes ( StepPattern ) qui utilise <det class="masc">l' </det>axe <det class="masc">des </det>attributs concorde si <det class="masc">le </det>test de noeud ( NodeTest ) est vrai pour <det class="masc">le </det>noeud et si <det class="masc">le </det>noeud est <det class="masc">un </det>noeud attribut . </div>
<div class="p">Si [ ] est présent , alors <det class="fem">la </det>première expression <det class="masc">du </det>prédicat ( PredicateExpr ) dans <det class="fem">une </det>séquence d' étapes ( StepPattern est évalué en considérant que <det class="masc">le </det>noeud pour lequel <det class="fem">une </det>concordance est en train d' être établie est <det class="masc">le </det>noeud contextuel et que <det class="masc">ses </det>suivants correspondant <det class="masc">au </det>test de noeud ( NodeTest ) forment <det class="fem">la </det>liste <det class="masc">des </det>noeuds contextuels , à moins que <det class="masc">le </det>noeud en train d' être recherché ne soit <det class="masc">un </det>noeud d' attribut , auquel cas , <det class="fem">la </det>liste <det class="masc">des </det>noeuds contextuels correspond à tous <det class="masc">les </det>attributs ayant <det class="masc">le </det>même parent que <det class="masc">l' </det>attribut en train d' être recherché et qui concorde avec <det class="masc">le </det>test de nom ( NameTest ) . </div>
<div class="p">Par exemple : appendix//ulist / item [ position ( ) =1 ] correspond à <det class="masc">un </det>noeud si et seulement si tout ce qui suit est vrai : <det class="masc">le </det>test de noeud ( NodeTest ) item est vrai pour <det class="masc">le </det>noeud et <det class="masc">le </det>noeud n' est pas <det class="masc">un </det>attribut ; en d' autres termes , <det class="masc">le </det>noeud est <det class="masc">un </det>élément item <det class="masc">L' </det>évaluation <det class="masc">du </det>prédicat ( PredicateExpr ) position ( ) =1 est vraie en considérant <det class="masc">le </det>noeud comme noeud contextuel et <det class="masc">les </det>suivants <det class="masc">du </det>noeud ( qui sont <det class="masc">des </det>éléments item ) comme liste de noeuds contextuels <det class="masc">Le </det>noeud a <det class="masc">un </det>parent qui concorde avec <det class="masc">le </det>motif appendix//ulist ; Ceci est vrai si <det class="masc">le </det>parent est <det class="masc">un </det>élément ulist dont <det class="masc">un </det><det class="masc">des </det>ancêtres est <det class="masc">l' </det>élément appendix . </div>
<div class="p">5.3 Définition de règles modèle Comme décrit dans ce qui suit , <det class="masc">l' </det>élément xsl : apply-templates traite d' <det class="fem">une </det>manière récursive <det class="masc">les </det>fils de <det class="masc">l' </det>élément source . </div>
<div class="p">5.4 Application <det class="fem">des </det>règles modèle NOTE : Typiquement , xsl : apply-templates est utilisé pour traiter uniquement <det class="masc">les </det>noeuds qui sont <det class="masc">des </det>descendants <det class="masc">du </det>noeud courant . </div>
<div class="p">
<det class="fem">Une </det>telle utilisation de xsl : apply-templates ne peut engendrer <det class="fem">une </det>boucle de traitement infinie . </div>
<div class="p">Cependant , lorsque xsl : apply-templates est utilisé pour traiter <det class="masc">les </det>éléments qui ne sont pas <det class="masc">des </det>descendants <det class="masc">du </det>noeud courant , il y a <det class="fem">une </det>possibilité de boucle infinie . </div>
<div class="p">Par exemple : <det class="masc">Les </det>outils peuvent , dans certains cas , être capables de détecter de pareilles boucles , mais <det class="fem">la </det>possibilité qu' <det class="fem">une </det>feuille de styles entre dans <det class="fem">une </det>boucle infinie sans que <det class="masc">le </det>programme ne la détecte persiste . </div>
<div class="p">5.5 Résolution de conflits <det class="fem">des </det>règles modèle Il est possible qu' <det class="masc">un </det>noeud source concorde avec plusieurs règles modèle . </div>
<div class="p">
<det class="fem">La </det>règle à utiliser est déterminée de <det class="fem">la </det>manière suivante : Premièrement , toutes <det class="fem">les </det>règles concordantes ayant <det class="fem">une </det>préséance d' import plus faible que <det class="fem">la </det>règle considérée ou que celles qui ont <det class="fem">la </det>préséance d' import plus forte sont éliminées . </div>
<div class="p">Ensuite , toutes <det class="fem">les </det>règles ayant <det class="fem">une </det>plus faible priorité que <det class="fem">la </det>règle considérée ou que <det class="fem">les </det>règles ayant <det class="fem">la </det>priorité <det class="fem">la </det>plus forte sont éliminées . </div>
<div class="p">
<det class="fem">La </det>priorité d' <det class="fem">une </det>règle modèle est spécifiée par <det class="masc">l' </det>attribut priority de <det class="fem">la </det>règle . </div>
<div class="p">
<det class="fem">Sa </det>valeur doit être <det class="masc">un </det>nombre réel ( négatif ou positif ) , conforme à <det class="fem">la </det>règle de production Number avec <det class="masc">un </det>signe moins ( - ) optionnel <det class="masc">au </det>début <det class="masc">du </det>nombre . <det class="fem">La </det>priorité par défaut est calculée comme suit : Si <det class="masc">le </det>motif contient plusieurs alternatives séparées par , alors il est traité comme si c' était <det class="masc">un </det>ensemble de règles modèle , une pour chaque alternative . </div>
<div class="p">Si <det class="masc">le </det>motif a <det class="fem">la </det>forme d' <det class="masc">un </det>nom qualifié ( QName ) précédé par <det class="masc">un </det>ChildOrAttributeAxisSpecifier ou a <det class="fem">la </det>forme d' <det class="fem">une </det>instruction de traitement processing-instruction ( Literal ) précédé par <det class="masc">un </det>ChildOrAttributeAxisSpecifier , alors <det class="fem">la </det>priorité est 0 . </div>
<div class="p">Si <det class="masc">le </det>motif a <det class="fem">la </det>forme d' <det class="masc">un </det>nom sans deux points ( NCName ) : * précédé d' <det class="masc">un </det>ChildOrAttributeAxisSpecifier , alors <det class="fem">la </det>priorité est - 0.25 . </div>
<div class="p">Autrement , si <det class="masc">le </det>pattern consiste uniquement en <det class="masc">un </det>test de noeud NodeTest précédé par <det class="masc">un </det>ChildOrAttributeAxisSpecifier , alors <det class="fem">la </det>priorité est - 0.5 . </div>
<div class="p">Sinon , <det class="fem">la </det>priorité est 0.5 . </div>
<div class="p">Ainsi <det class="masc">le </det>plus commun <det class="masc">des </det>types de motifs ( <det class="masc">un </det>motif qui teste <det class="masc">un </det>type particulier de noeuds avec <det class="masc">un </det>nom étendu particulier ) a <det class="fem">une </det>priorité 0 . </div>
<div class="p">Ensuite , <det class="masc">le </det>type de motif <det class="masc">le </det>moins spécifique ( <det class="masc">un </det>motif qui teste <det class="masc">un </det>type particulier de noeuds et <det class="masc">un </det>nom étendu avec <det class="fem">une </det>URI particulière indiquant <det class="masc">son </det>espace de noms ) a <det class="fem">une </det>priorité de - 0.25 . </div>
<div class="p">
<det class="masc">Les </det>motifs <det class="masc">les </det>moins spécifiques ( motifs permettant de tester <det class="masc">un </det>type particulier de noeuds ) ont <det class="fem">une </det>priorité de - 0.5 . </div>
<div class="p">
<det class="masc">Les </det>motifs <det class="masc">les </det>plus spécifiques que le motif <det class="masc">le </det>plus commun ont <det class="fem">une </det>priorité de 0.5 . </div>
<div class="p">Si après vérification <det class="fem">des </det>conditions ci-dessus il reste plus qu' <det class="fem">une </det>seule règle modèle qui concorde alors il y a <det class="fem">une </det>erreur . </div>
<div class="p">
<det class="masc">Un </det>processeur XSLT peut signaler <det class="masc">l' </det>erreur ; s' il ne le fait pas , il doit la rattraper en choisissant , parmi <det class="fem">les </det>règles concordantes restantes , celle qui arrive en dernière dans <det class="fem">la </det>feuille de styles . </div>
<div class="p">5.6 Passer outre <det class="masc">des </det>règles modèles <det class="masc">Les </det>modèles peuvent être invoqués par <det class="masc">leur </det>nom . </div>
<div class="p">
<det class="masc">L' </det>utilisation de <det class="masc">l' </det>attribut name de <det class="masc">l' </det>élément xsl : template permet de spécifier <det class="masc">un </det>nom de modèle . </div>
<div class="p">
<det class="fem">La </det>valeur de <det class="masc">l' </det>attribut name est <det class="masc">un </det>nom qualifié ( QName ) , qui est développé tel que décrit <det class="masc">au </det>chapitre [ 2.4 Noms qualifiés ] . </div>
<div class="p">Quand <det class="masc">l' </det>élément xsl : template est qualifié par <det class="masc">l' </det>attribut name , il peut , sans que cela soit obligatoire , avoir également <det class="masc">un </det>attribut match . </div>
<div class="p">
<det class="masc">L' </det>élément xsl : call-template permet d' appeler <det class="masc">un </det>modèle par <det class="masc">son </det>nom ; il a <det class="masc">un </det>attribut obligatoire name qui identifie <det class="masc">le </det>modèle à appeler . </div>
<div class="p">
<det class="masc">Au </det>contraire de <det class="masc">l' </det>élément xsl : apply-templates , xsl : call-template ne modifie pas <det class="masc">le </det>noeud courant ou <det class="fem">la </det>liste courante de noeuds . </div>
<div class="p">
<det class="masc">Les </det>attributs match , mode et priority d' <det class="masc">un </det>élément xsl : template n' ont pas d' effet si <det class="masc">le </det>modèle est invoqué par <det class="masc">un </det>élément xsl : call-template . </div>
<div class="p">De même , <det class="masc">l' </det>attribut name d' <det class="masc">un </det>élément xsl : template n' a pas d' effet si <det class="masc">le </det>modèle est invoqué par <det class="masc">un </det>élément xsl : apply-templates . </div>
<div class="p">
<det class="fem">Une </det>erreur est produite si <det class="fem">une </det>même feuille de styles contient plus d' <det class="masc">un </det>modèle ayant à <det class="fem">la </det>fois <det class="masc">le </det>même nom et <det class="fem">la </det>même préséance d' import . 7 Création de <det class="masc">l' </det>arbre résultant <det class="fem">Cette </det>section décrit <det class="fem">les </det>instructions qui créent directement <det class="masc">des </det>noeuds dans <det class="masc">l' </det>arbre résultant . </div>
<div class="p">7.1 Création d' éléments et d' attributs 7.1.1 Eléments résultats littéraux Dans <det class="masc">un </det>modèle , <det class="masc">un </det>élément d' <det class="fem">une </det>feuille de style qui n' appartient pas à <det class="masc">l' </det>espace de noms XSLT et n' est pas <det class="masc">un </det>élément extension ( voir [ 14.1 Eléments extension ] ) est instancié pour créer <det class="masc">un </det>noeud élément avec <det class="masc">le </det>même nom étendu . <det class="masc">le </det>contenu de <det class="masc">l' </det>élément est <det class="masc">un </det>template qui est instancié pour donner <det class="masc">le </det>contenu de <det class="masc">l' </det>élément noeud créé . </div>
<div class="p">
<det class="masc">L' </det>élément noeud créé aura <det class="masc">les </det>noeuds attributs qui étaient présents sur <det class="masc">le </det>noeud élément dans <det class="masc">l' </det>arbre de <det class="fem">la </det>feuille de style , plutôt que <det class="masc">les </det>attributs avec <det class="masc">les </det>noms dans <det class="masc">l' </det>espace de noms XSLT . <det class="masc">Le </det>noeud élément créé aura aussi <det class="fem">une </det>copie de <det class="masc">l' </det>espace de noms <det class="masc">des </det>noeuds qui étaient présents sur <det class="masc">l' </det>élément noeuds dans <det class="fem">la </det>feuille de style avec <det class="masc">l' </det>exception que tout espace de noms dont <det class="fem">la </det>valeur textuelle est <det class="masc">l' </det>espace de noms XSLT URI ( http : / / www . w3 . org / 1999 / XSL / Transform ) , <det class="masc">un </det>nom d' espace URI déclaré a <det class="fem">une </det>extension d' espace de noms ( voir [ 14.1 Éléments extension ] ) ou <det class="masc">un </det>espace de noms URI désigné comme <det class="masc">un </det>espace de noms exclu . </div>
<div class="p">
<det class="masc">Un </det>espace de noms URI est désigné comme <det class="masc">un </det>espace de noms exclu en utilisant <det class="masc">un </det>attribut exclude-result-prefixes sur <det class="masc">un </det>élément xsl : stylesheet ou <det class="masc">un </det>attribut xsl : exclude-result-prefixes sur <det class="masc">un </det>élément résultat littéral . </div>
<div class="p">
<det class="fem">La </det>valeur de <det class="masc">ces </det>deux attributs est <det class="fem">une </det>liste de préfixes d' espace de noms séparés par <det class="masc">un </det>espace blanc . </div>
<div class="p">
<det class="masc">L' </det>espace de nom relié à chacun <det class="masc">des </det>préfixes est désigné comme <det class="masc">un </det>espace de noms exclu . </div>
<div class="p">C' est <det class="fem">une </det>erreur s' il n' y a pas d' espace de noms relié <det class="masc">au </det>préfixe sur <det class="masc">un </det>élément supportant <det class="masc">l' </det>attribut exclude-result-prefixes ou xsl : exclude-result-prefixes . </div>
<div class="p">
<det class="masc">L' </det>espace de noms par défaut ( comme déclaré par xmlns ) peut-être désigné comme <det class="masc">un </det>espace de noms exclu en incluant # default dans <det class="fem">la </det>liste <det class="masc">des </det>préfixes d' espace de noms . </div>
<div class="p">
<det class="fem">La </det>désignation d' <det class="masc">un </det>espace de noms comme par exemple <det class="masc">un </det>espace de noms exclu est effectif dans un sous arbre de <det class="fem">la </det>feuille de style relié à <det class="masc">l' </det>élément supportant <det class="masc">l' </det>attribut exclude-result-prefixes ou xsl : exclude-result-prefixes ; un sous arbre relié à <det class="masc">un </det>élément xsl : stylesheet n' inclue pas toutes <det class="fem">les </det>feuilles de style importées ou inclues par <det class="masc">les </det>enfants de <det class="masc">cet </det>élément . </div>
<div class="p">NOTE : Quand <det class="fem">une </det>feuille de style utilise <det class="fem">une </det>déclaration d' espace de noms seulement dans <det class="masc">le </det>but d' adresser <det class="masc">un </det>arbre source , en spécifiant <det class="masc">le </det>préfixe dans <det class="masc">l' </det>attribut exclude-result-prefixes , cela n' empêche pas <det class="fem">les </det>déclarations superflues d' espaces de noms dans <det class="masc">l' </det>arbre résultant . </div>
<div class="p">
<det class="fem">La </det>valeur d' <det class="masc">un </det>attribut d' <det class="masc">un </det>élément résultat littéral est interprétée comme <det class="fem">la </det>valeur de <det class="masc">l' </det>attribut template : il peut contenir <det class="fem">des </det>expressions contenues entre accolades ( { } ) . </div>
<div class="p">
<det class="masc">Un </det>espace de noms URI dans <det class="masc">l' </det>arbre d' <det class="fem">une </det>feuille de style est utilisé pour spécifier <det class="masc">un </det>espace de noms URI dans <det class="masc">l' </det>arbre résultant est appelé espace de noms URI littéral . </div>
<div class="p">Cela s' applique à : <det class="masc">l' </det>espace de noms URI est <det class="masc">un </det>nom étendu d' <det class="masc">un </det>élément résultat littéral dans <det class="fem">la </det>feuille de style <det class="masc">l' </det>espace de noms URI dans <det class="masc">le </det>nom étendu d' <det class="masc">un </det>attribut spécifié dans <det class="masc">un </det>élément résultat littéral dans <det class="fem">la </det>feuille de style <det class="fem">la </det>valeur textuelle d' <det class="masc">un </det>noeud d' espace de noms sur <det class="masc">un </det>élément résultat littéral d' <det class="fem">une </det>feuille de style génèrera <det class="fem">une </det>feuille de style XSLT à partir d' <det class="masc">un </det>document de <det class="fem">la </det>forme : NOTE : Il peut être aussi nécessaire d' utiliser <det class="masc">des </det>alias pour <det class="masc">les </det>espaces de noms plutôt que <det class="masc">les </det>espaces de noms XSLT URI . Par exemple , <det class="masc">les </det>éléments résultats littéraux appartenant à <det class="masc">un </det>espace de noms qui comportent <det class="fem">des </det>signatures digitales peuvent faire qu' <det class="fem">une </det>feuille de style XSLT soit mal comprise par <det class="masc">un </det>programme sécuritaire , en utilisant <det class="masc">un </det>alias pour <det class="masc">l' </det>espace de noms l' on peut éviter <det class="fem">une </det>telle confusion . </div>
<div class="p">7.1.2 Créer <det class="masc">des </det>éléments avec xsl : element <det class="masc">le </det>résultat ne sera pas <det class="fem">la </det>déclaration d' <det class="masc">un </det>espace de noms . </div>
<div class="p">En ajoutant <det class="masc">un </det>attribut à <det class="masc">un </det>élément remplace <det class="masc">l' </det>attribut existant de <det class="masc">cet </det>élément avec <det class="masc">le </det>même nom étendu . </div>
<div class="p">Les opération suivantes sont <det class="fem">des </det>erreurs : Ajouter <det class="masc">un </det>attribut à <det class="masc">un </det>élément après que <det class="masc">des </det>enfants lui aient été rajoutés , <det class="fem">les </det>implémentations peuvent signaler <det class="masc">l' </det>erreur ou ignorer <det class="masc">l' </det>attribut . </div>
<div class="p">Ajouter <det class="masc">un </det>attribut à <det class="masc">un </det>noeud qui ne soit pas <det class="masc">un </det>élément , <det class="fem">les </det>implémentations peuvent signaler <det class="masc">l' </det>erreur ou ignorer <det class="masc">l' </det>attribut . </div>
<div class="p">Créer <det class="masc">des </det>noeuds autres que <det class="masc">des </det>noeuds de texte durant <det class="masc">l' </det>instanciation <det class="masc">du </det>contenu de <det class="masc">l' </det>élément xsl : attribute ; <det class="fem">les </det>implémentations peuvent signaler <det class="masc">l' </det>erreur ou ignorer <det class="masc">l' </det>attribut . </div>
<div class="p">NOTE : Quand <det class="masc">un </det>xsl : attribute contient <det class="masc">un </det>noeud de texte avec <det class="masc">un </det>saut de ligne , alors <det class="fem">la </det>sortie XML doit contenir <det class="fem">une </det>référence de caractère . </div>
<div class="p">Par exemple , donnera comme résultat : ( ou tout autre référence de caractère équivalente ) . </div>
<div class="p">
<det class="fem">La </det>sortie XML peut être C' est parceque XML 1.0 demande que <det class="masc">les </det>retours à <det class="fem">la </det>ligne dans <det class="fem">les </det>valeurs d' attributs soient traités comme <det class="masc">des </det>espaces , mais ne l' exige pas <det class="fem">des </det>références de caractère de retour à <det class="fem">la </det>ligne . </div>
<div class="p">
<det class="fem">Les </det>valeurs d' attributs <det class="masc">du </det>modèle de données représentent <det class="fem">la </det>valeur de <det class="masc">l' </det>attribut après normalisation . </div>
<div class="p">Si <det class="masc">un </det>retour à <det class="fem">la </det>ligne se trouvant dans <det class="fem">une </det>valeur d' attribut de <det class="masc">l' </det>arbre était sorti comme <det class="masc">un </det>caractère de retour à <det class="fem">la </det>ligne plutôt que comme <det class="fem">une </det>référence de caractère , alors <det class="fem">la </det>valeur de <det class="masc">l' </det>attribut dans <det class="masc">l' </det>arbre créé en reparsant <det class="masc">le </det>fichier XML contiendrait <det class="masc">un </det>espace et nom <det class="masc">un </det>saut de ligne , ce qui signifirait que <det class="masc">l' </det>arbre n' a pas été produit correctement . </div>
<div class="p">7.1.4 Ensembles d' attributs nommés <det class="fem">Des </det>définitions multiples d' <det class="masc">un </det>ensemble d' attributs ayant <det class="masc">le </det>même nom étendu sont fusionnées . </div>
<div class="p">
<det class="masc">Un </det>attribut d' <det class="fem">une </det>définition qui possède <det class="fem">une </det>préséance d' import plus élevée passe avant <det class="masc">l' </det>attribut d' <det class="fem">une </det>définition qui en aurait <det class="fem">une </det>plus faible . </div>
<div class="p">C' est <det class="fem">une </det>erreur quand il y a deux ensembles d' attributs ayant <det class="masc">un </det>même nom étendu et <det class="fem">une </det>même préséance d' import et que <det class="fem">les </det>deux contiennent <det class="masc">le </det>même attribut , à moins que ne soit précisé <det class="fem">une </det>définition de <det class="masc">l' </det>ensemble d' attribut qui confère à <det class="masc">l' </det>un d' eux <det class="fem">une </det>plus haute préséance d' import <det class="masc">Un </det>processeur XSLT peut signaler <det class="masc">l' </det>erreur , si il ne le fait pas , il doit rattraper <det class="masc">l' </det>erreur en choisissant parmi <det class="fem">les </det>définittions qui spécifient <det class="masc">l' </det>attribut que celle qui a <det class="fem">la </det>plus haute préséance d' import est <det class="fem">la </det>dernière à avoir été spécifiée dans <det class="fem">la </det>feuille de style . </div>
<div class="p">
<det class="masc">L' </det>emplacement où <det class="masc">les </det>attributs d' <det class="masc">un </det>ensemble d' attributs sont spécifiés est significatif uniquement en fusionnant <det class="masc">les </det>attributs dans <det class="masc">un </det>ensemble d' attributs ; cela ne fait aucune différence de savoir quand <det class="masc">l' </det>ensemble d' attributs est utilisé . </div>
<div class="p">7.2 Créer <det class="masc">du </det>texte <det class="masc">Un </det>modèle peut aussi contenir <det class="masc">des </det>noeuds textuels . </div>
<div class="p">Chaque noeud textuel <det class="masc">du </det>modèle restant après que <det class="masc">les </det>espaces blancs aient été filtrés conformément à ce qui est spécifié <det class="masc">au </det>chapitre [ 3.4 Suppression d' espaces ] créera <det class="masc">un </det>noeud textuel de même valeur textuelle dans <det class="masc">l' </det>arbre résultant . </div>
<div class="p">
<det class="masc">Les </det>noeuds textuels adjacents d' <det class="masc">un </det>arbre résultat seront automatiquement fusionnés . </div>
<div class="p">Noter que <det class="masc">le </det>texte est traité <det class="masc">au </det>niveau de <det class="masc">l' </det>arbre . </div>
<div class="p">Donc , <det class="masc">le </det>balisage de &amp; lt ; dans <det class="masc">le </det>modèle sera représenté dans <det class="masc">l' </det>arbre de <det class="fem">la </det>feuille de style par <det class="masc">un </det>noeud textuel incluant <det class="masc">le </det>caractère &lt; . </div>
<div class="p">Cela créera <det class="masc">un </det>noeud textuel dans <det class="masc">l' </det>arbre résultat qui contiendra &lt; , lequel sera représenté par <det class="masc">l' </det>entité &amp; lt ; ( ou <det class="fem">une </det>référence de caractère équivalente ) quand <det class="masc">l' </det>arbre résultat est mis sous <det class="fem">la </det>forme d' <det class="masc">un </det>document XML ( à moins que <det class="fem">la </det>méthode de sortie XML soit désactivée comme décrit dans [ 16.4 Désactivation de <det class="fem">la </det>production littérale <det class="masc">des </det>caractères en sortie ] ) . </div>
<div class="p">7.3 Créer <det class="fem">des </det>instructions de traitement créera <det class="masc">l' </det>instruction de traitement Ce n' est pas <det class="fem">une </det>erreur quand <det class="masc">le </det>résultat de <det class="masc">l' </det>intanciation n' est ni <det class="masc">un </det>NCName ni <det class="masc">un </det>PITarget . </div>
<div class="p">
<det class="masc">Un </det>processeur XSLT peut signaler <det class="masc">l' </det>erreur ; si il ne le fait pas , il doit la rattraper en supprimant <det class="masc">l' </det>instruction de traitement de <det class="masc">l' </det>arbre résultant . </div>
<div class="p">NOTE : Cela signifie que <det class="masc">l' </det>élément xsl : processing-instruction ne peut pas être utilisé pour produire <det class="fem">une </det>déclaration XML . <det class="masc">L' </det>élément xsl : output devra être utilisé à <det class="fem">la </det>place ( voir [ 16 Sorties ] ) . </div>
<div class="p">C' est <det class="fem">une </det>erreur quand <det class="masc">l' </det>intanciation <det class="masc">du </det>contenu de xsl : processing-instruction crée <det class="masc">un </det>noeud autre qu' <det class="masc">un </det>noeud textuel . </div>
<div class="p">
<det class="masc">Un </det>processeur XSLT peut signaler <det class="masc">l' </det>erreur mais si il ne le fait pas , il doit ignorer <det class="masc">les </det>noeuds posant problème ainsi que <det class="masc">leur </det>contenu . </div>
<div class="p">C' est <det class="fem">une </det>erreur si <det class="masc">l' </det>intanciation <det class="masc">du </det>contenu de xsl : processing-instruction contient <det class="fem">la </det>chaîne ? &gt; . </div>
<div class="p">
<det class="masc">Un </det>processeur XSLT peut signaler <det class="masc">l' </det>erreur ; si il ne le fait pas , il doit rattraper <det class="masc">l' </det>erreur en insérant <det class="masc">un </det>espace après toute occurence de ? qui est suivie par <det class="masc">un </det>&gt; . </div>
<div class="p">7.4 Créer <det class="masc">des </det>commentaires Créera <det class="masc">ce </det>commentaire : C' est <det class="fem">une </det>erreur si <det class="masc">l' </det>instanciation <det class="masc">du </det>contenu de xsl : comment crée <det class="masc">des </det>noeuds autres que <det class="masc">des </det>noeuds textuels . </div>
<div class="p">
<det class="masc">Un </det>processeur XSLT peut signaler <det class="masc">l' </det>erreur , si'l ne <det class="masc">le </det>fait pas , il doit la rattraper en ignorant <det class="masc">le </det>noeud posant problème ainsi que <det class="masc">son </det>contenu . </div>
<div class="p">C' est <det class="fem">une </det>erreur si <det class="masc">le </det>contenu résultant de <det class="masc">l' </det>instanciation de xsl : comment contient <det class="fem">la </det>chaîne </div>
<div class="p">ou si elle finit par - . </div>
<div class="p">
<det class="masc">Un </det>processeur XSLT peut signaler <det class="masc">l' </det>erreur ; si il ne le fait pas , il doit rattraper <det class="masc">l' </det>erreur en insérant <det class="masc">un </det>espace après toute occurence de - suivie d' <det class="masc">un </det>autre carcatère - ou qui se trouve être à <det class="fem">la </det>fin <det class="masc">du </det>commmentaire . </div>
<div class="p">7.5 Copier <det class="masc">au </det>lieu de : <det class="masc">L' </det>élément xsl : value-of est instancié pour créer <det class="masc">un </det>noeud textuel de <det class="masc">l' </det>arbre résultant . </div>
<div class="p">
<det class="masc">L' </det>attribut obligatoire select est <det class="fem">une </det>expression ; <det class="fem">cette </det>expression est évaluée et <det class="masc">l' </det>objet résultant est converti en <det class="fem">une </det>chaîne de caractères comme l' aurait fait <det class="fem">la </det>fonction string . </div>
<div class="p">
<det class="fem">La </det>chaîne de caractères spécifie <det class="fem">la </det>valeur textuelle <det class="masc">du </det>noeud textuel créé . </div>
<div class="p">Si <det class="fem">la </det>chaîne est vide , <det class="masc">le </det>noeud textuel ne sera pas créé . </div>
<div class="p">
<det class="masc">Le </det>noeud textuel créé sera fusionné avec tout autre noeud textuel adjacent . </div>
<div class="p">
<det class="masc">L' </det>élément xsl : copy-of peut être utilisé pour copier <det class="masc">un </det>ensemble de noeuds vers <det class="masc">l' </det>arbre résultat sans les convertir en chaîne . </div>
<div class="p">Voir [ 11.3 Utiliser <det class="fem">des </det>valeurs de variables et de paramètres avec xsl : copy-of ] . </div>
<div class="p">Par exemple , <det class="fem">les </det>déclarations suivantes créent <det class="masc">un </det>paragraphe HTML à partir de <det class="masc">l' </det>élément person et de <det class="masc">ses </det>attributs given-name et family-name . </div>
<div class="p">
<det class="masc">Le </det>paragraphe contiendra <det class="fem">la </det>valeur de <det class="masc">l' </det>attribut given-name <det class="masc">du </det>noeud courant suivie d' <det class="masc">un </det>espace et de <det class="fem">la </det>valeur de <det class="masc">l' </det>attribut family-name <det class="masc">du </det>noeud courant . </div>
<div class="p">
<det class="masc">L' </det>exemple suivant crée <det class="masc">un </det>élément résultat img à partir de <det class="masc">l' </det>élément source photograph ; <det class="fem">la </det>valeur de <det class="masc">l' </det>attribut src de <det class="masc">l' </det>élément img est calculée à partir de <det class="fem">la </det>valeur de <det class="fem">la </det>variable image-dir et de <det class="fem">la </det>valeur textuelle de <det class="masc">l' </det>enfant href de <det class="masc">l' </det>élément photograph ; <det class="fem">la </det>valeur de <det class="masc">l' </det>attribut width de <det class="masc">l' </det>élément img est calculée à partir de <det class="fem">la </det>valeur de <det class="masc">l' </det>attribut width de <det class="masc">l' </det>enfant size de <det class="masc">l' </det>élément photograph : Avec <det class="masc">le </det>source : n' est pas autorisée . </div>
<div class="p">A <det class="fem">la </det>place , utiliser simplement : Si aucun attribut value n' est spécifié , alors <det class="masc">l' </det>élément xsl : number insère <det class="masc">un </det>nombre basé sur <det class="fem">la </det>position <det class="masc">du </det>noeud courant dans <det class="masc">l' </det>arbre source . </div>
<div class="p">
<det class="masc">Les </det>attributs suivants contrôlent <det class="fem">la </det>manière dont <det class="masc">le </det>noeud courant doit être numéroté : <det class="masc">L' </det>attribut level spécifie <det class="masc">les </det>niveaux de <det class="masc">l' </det>arbre source qui doivent être considérés ; <det class="fem">les </det>valeurs possibles sont single , multiple ou any . </div>
<div class="p">
<det class="fem">La </det>valeur par défaut est single . </div>
<div class="p">
<det class="masc">L' </det>attribut count est <det class="masc">un </det>motif qui spécifie <det class="masc">les </det>noeuds à comptabiliser dans <det class="masc">les </det>niveaux spécifiés . </div>
<div class="p">Si <det class="masc">l' </det>attribut count n' est pas spécifié , alors <det class="fem">sa </det>valeur par défaut est <det class="masc">le </det>motif qui correspond à tous <det class="masc">les </det>noeuds de même type que <det class="masc">le </det>noeud courant et , si <det class="masc">le </det>noeud courant a <det class="masc">un </det>nom expansé , ayant <det class="masc">le </det>même nom expansé que <det class="masc">le </det>noeud courant . </div>
<div class="p">
<det class="masc">L' </det>attribut from est <det class="masc">un </det>motif qui spécifie où commence <det class="masc">l' </det>énumération . </div>
<div class="p">De plus , <det class="masc">les </det>attributs décrits <det class="masc">au </det>chapitre [ 7.7.1 Attributs de conversion de nombres en chaînes de caractères ] sont utilisés dans <det class="fem">les </det>conversions de nombres en chaînes de caractères , comme lorsque <det class="masc">l' </det>attribut value est spécifié . </div>
<div class="p">
<det class="masc">L' </det>élément xsl : number commence par construire <det class="fem">une </det>liste d' entiers positifs en utilisant <det class="masc">les </det>attributs level , count et from selon <det class="fem">les </det>règles suivantes : Quand level="single " , <det class="masc">le </det>premier <det class="masc">des </det>ancêtres dans <det class="masc">l' </det>axe ancêtre-ou-réflexif ( ancestor-or-self ) correspondant <det class="masc">au </det>motif spécifié par <det class="masc">l' </det>attribut count est recherché puis <det class="fem">une </det>liste contenant <det class="masc">cet </det>ancêtre et tous <det class="masc">ses </det>prédécesseurs correspondant eux -mêmes <det class="masc">au </det>motif précisé par <det class="masc">l' </det>attribut count est construite . </div>
<div class="p">Si <det class="masc">le </det>premier ancêtre n' existe pas , <det class="fem">la </det>liste construite est vide . </div>
<div class="p">Si <det class="masc">l' </det>attribut from est spécifié , alors , <det class="masc">les </det>seuls ancêtres recherchés sont ceux qui sont <det class="masc">des </det>descendants de <det class="masc">l' </det>ancêtre <det class="masc">le </det>plus proche correspondant <det class="masc">au </det>motif from . </div>
<div class="p">
<det class="masc">Les </det>prédécesseurs ont ici <det class="fem">la </det>même signification que dans <det class="masc">l' </det>axe <det class="masc">des </det>prédécesseurs ( preceding-sibling axis ) . </div>
<div class="p">Quand level="multiple " , <det class="fem">une </det>liste de tous <det class="masc">les </det>ancêtres <det class="masc">du </det>noeud courant dans <det class="masc">l' </det>ordre <det class="masc">du </det>document est construite terminée par <det class="masc">le </det>noeud courant lui -même ; ensuite , <det class="masc">les </det>noeuds correspondant <det class="masc">au </det>motif count sont extraits de <det class="fem">cette </det>liste et chacun d' eux provoque <det class="fem">la </det>création d' <det class="fem">une </det>liste composée <det class="masc">du </det>noeud et de <det class="masc">l' </det>ensemble de <det class="masc">ses </det>prédécesseurs correspondant <det class="masc">au </det>motif count . </div>
<div class="p">Si <det class="masc">l' </det>attribut from est spécifié , alors <det class="masc">les </det>seuls ancêtres à être recherchés sont ceux qui sont <det class="masc">des </det>descendants de <det class="masc">l' </det>ancêtre <det class="masc">le </det>plus proche correspondant <det class="masc">au </det>motif from . </div>
<div class="p">
<det class="masc">Les </det>prédécesseurs ont ici <det class="fem">la </det>même signification que dans <det class="masc">l' </det>axe <det class="masc">des </det>prédécesseurs ( preceding-sibling axis ) . </div>
<div class="p">Quand level="any " , <det class="fem">une </det>liste à <det class="masc">un </det>élément est constituée contenant <det class="masc">le </det>nombre de noeuds qui correspondent <det class="masc">au </det>motif count et appartiennent à <det class="masc">l' </det>ensemble formé <det class="masc">du </det>noeud courant et de tous <det class="masc">les </det>noeuds <det class="masc">du </det>document , quel que soit <det class="masc">leur </det>niveau , qui se trouvent avant <det class="masc">le </det>noeud courant dans <det class="masc">l' </det>ordre <det class="masc">du </det>document , à <det class="masc">l' </det>exclusion <det class="masc">des </det>noeuds d' espace de noms et d' attribut ( en d' autres termes , il s' agit de <det class="masc">l' </det>union <det class="masc">des </det>membres <det class="masc">des </det>axes prédécesseurs ( preceding ) et ancêtres-ou-réflexif ( ancestor-or-self ) . </div>
<div class="p">Si <det class="masc">l' </det>attribut from est spécifié , alors seuls <det class="masc">les </det>noeuds qui se trouvent après <det class="masc">le </det>premier noeud précédant <det class="masc">le </det>noeud courant et correspondant <det class="masc">au </det>motif from sont pris en considération . </div>
<div class="p">
<det class="fem">La </det>liste <det class="masc">des </det>nombres est ensuite convertie en <det class="fem">une </det>chaîne de caractères en utilisant <det class="masc">les </det>attributs décrits <det class="masc">au </det>chapitre [ 7.7.1 Attributs de conversion de nombres en chaînes de caractères ] ; dans <det class="masc">ce </det>contexte , <det class="fem">la </det>valeur de chacun de <det class="masc">ces </det>attributs est interprétée comme <det class="masc">un </det>modèle de valeur d' attribut . </div>
<div class="p">Après conversion , <det class="fem">la </det>chaîne de caractères résultante est insérée dans <det class="masc">l' </det>arbre résultat . </div>
<div class="p">
<det class="fem">Les </det>lignes suivantes calculent <det class="masc">le </det>nombre d' items d' <det class="fem">une </det>liste ordonnée : <det class="masc">L' </det>exemple suivant numérote <det class="masc">les </det>éléments HTML H4 avec <det class="masc">un </det>préfixe composé de 3 parties : Quand on numérote avec <det class="fem">une </det>séquence alphabétique , <det class="masc">l' </det>attribut lang spécifie quel alphabet de langue doit être utilisé ; il a <det class="fem">la </det>même gamme de valeurs que xml : lang [ XML ] ; si aucune valeur lang n' est spécifiée , <det class="fem">la </det>langage doit être déterminé de <det class="masc">l' </det>environnement système . </div>
<div class="p">
<det class="masc">Les </det>développeurs de logiciels doivent documenter <det class="masc">les </det>langages supportés par <det class="fem">leur </det>implémentation de <det class="fem">la </det>numérotation . </div>
<div class="p">NOTE : <det class="masc">les </det>développeurs de logiciels ne doivent faire aucune supposition concernant <det class="fem">la </det>manière dont <det class="fem">la </det>numérotation fonctionne dans <det class="masc">des </det>cas particuliers de langages et doivent correctement étudier <det class="masc">les </det>langages qu' ils se proposent de supporter . </div>
<div class="p">
<det class="fem">Les </det>conventions de numérotations étant différentes de <det class="masc">l' </det>anglais dans de nombreux langages . </div>
<div class="p">
<det class="masc">L' </det>attribut letter-value permet de lever <det class="fem">les </det>ambiguïtés concernant <det class="fem">les </det>séquences de numérotation reposant sur <det class="fem">des </det>lettres . </div>
<div class="p">Dans de nombreux langages , il y a deux séquences communément utilisées de numérotations à base de lettres . </div>
<div class="p">
<det class="masc">L' </det>une attribue <det class="fem">des </det>valeurs numériques <det class="fem">aux </det>lettres ordonnées selon <det class="masc">l' </det>alphabet , et <det class="masc">l' </det>autre attribue <det class="fem">des </det>valeurs numériques <det class="fem">aux </det>lettres selon d' autres critères traditionnels propre <det class="masc">au </det>langage . </div>
<div class="p">En anglais , cela correspondrait <det class="fem">aux </det>règles de numérotation a et i . </div>
<div class="p">Dans d' autres langages , <det class="masc">le </det>premier membre de chaque séquence est <det class="masc">le </det>même , faisant que <det class="fem">la </det>seule marque de formatage serait ambïgue . </div>
<div class="p">
<det class="fem">La </det>valeur alphabetic permet de spécifier qu' il s' agit d' <det class="fem">une </det>séquence alphabétique ; <det class="fem">La </det>valeur traditional permet de préciser <det class="fem">une </det>autre séquence . </div>
<div class="p">Si <det class="masc">l' </det>attribut letter-value n' est pas précisé , alors <det class="fem">la </det>levée de <det class="masc">l' </det>ambiguïté dépend de <det class="masc">l' </det>implémentation . </div>
<div class="p">NOTE : Il est possible que deux processeurs XSLT conformes ne convertissent pas tout à fait <det class="masc">un </det>même nombre en <det class="fem">une </det>chaîne de caractères strictement identique . </div>
<div class="p">Il se peut que <det class="masc">des </det>processeurs XSLT ne supportent pas certains lanagages . </div>
<div class="p">De plus , il peut y avoir <det class="fem">des </det>variations dans <det class="fem">la </det>manière dont <det class="fem">les </det>conversions sont effectuées pour <det class="masc">des </det>langages spécifiques qui ne soient pas contrôlables par <det class="masc">les </det>attributs de xsl : number . </div>
<div class="p">
<det class="fem">Les </det>futures versions de XSLT pourront fournir <det class="masc">des </det>attributs additionnels pour pouvoir contrôler <det class="fem">ces </det>variations . </div>
<div class="p">
<det class="fem">Les </det>implémentations peuvent également utiliser sur <det class="masc">l' </det>élément xsl : number <det class="masc">des </det>attributs issus d' espaces de noms spécifiques à <det class="masc">l' </det>implémentation . </div>
<div class="p">
<det class="masc">L' </det>attribut grouping-separator donne <det class="masc">le </det>séparateur utilisé comme séparateur de groupes ( par exemple <det class="masc">les </det>milliers ) <det class="fem">des </det>séquences numériques , et <det class="masc">l' </det>attribut optionnel grouping-size spécifie <det class="fem">la </det>taille ( habituellement 3 ) <det class="masc">du </det>regrouppement . </div>
<div class="p">Par exmple , grouping-separator= " , " et grouping-size="3 " produiraient <det class="masc">des </det>nombres de <det class="fem">la </det>forme 1 , 000 , 000 . </div>
<div class="p">Si <det class="masc">un </det>seul <det class="masc">des </det>deux attributs grouping-separator et grouping-size est spécifié , alors il est ignoré . </div>
<div class="p">Voici quelques exemples de spécifications de conversion : format="&amp;#x30A2 ; " spécifie <det class="fem">une </det>numérotation en Katakana format="&amp;#x30A4 ; " spécifie <det class="fem">une </det>numérotation Katakana dans <det class="masc">l' </det>ordre " iroha " format="&amp;#x0E51 ; " spécifie <det class="fem">une </det>numérotation en chiffres Thai format="&amp;#x05D0 ; " letter-value="traditional " spécifie <det class="fem">une </det>numérotation traditionnelle en Hébreu format="&amp;#x10D0 ; " letter-value="traditional " spécifie <det class="fem">une </det>numérotation en Géorgien format="&amp;#x03B1 ; " letter-value="traditional " spécifie <det class="fem">une </det>numérotation en Grec " classique " format="&amp;#x0430 ; " letter-value="traditional " spécifie <det class="fem">une </det>numérotation en vieux Slave 8 Répétition Il est utile de pouvoir spécifier directement <det class="masc">le </det>modèle pour <det class="masc">les </det>noeuds sélectionnés lorsque <det class="masc">le </det>résultat est <det class="fem">une </det>structure régulière connue . </div>
<div class="p">
<det class="masc">L' </det>instruction xsl : for-each contient <det class="masc">un </det>modèle qui est instancié pour chaque noeud sélectionné par <det class="masc">l' </det>expression spécifiée en tant que valeur de <det class="masc">l' </det>attribut select . </div>
<div class="p">
<det class="masc">L' </det>attribut select est obligatoire . </div>
<div class="p">
<det class="masc">Le </det>résultat de <det class="masc">l' </det>évaluation de <det class="masc">l' </det>expression doit être <det class="masc">un </det>ensemble de noeuds . </div>
<div class="p">
<det class="masc">Le </det>modèle est instancié avec <det class="masc">le </det>noeud sélectionné identifié comme <det class="masc">le </det>noeud courant , et avec <det class="fem">la </det>liste de tous <det class="masc">les </det>noeuds sélectionnés identifiée comme <det class="fem">la </det>liste courante de noeuds . </div>
<div class="p">À moins qu' <det class="fem">une </det>spécification d' ordre ne soit présente , <det class="masc">les </det>noeuds sont traités dans <det class="masc">l' </det>ordre induit par <det class="masc">le </det>document ( voir [ 10 Tri ] ) . </div>
<div class="p">Par exemple , Considérons <det class="masc">un </det>document XML avec <det class="fem">la </det>structure suivante : ce qui suit permet de créer <det class="masc">un </det>document HTML contenant <det class="fem">une </det>table contenant <det class="fem">une </det>ligne pour chaque élément customer 9 Traitement conditionnel XSLT propose deux instructions qui pemettent <det class="masc">le </det>traitement conditionnel dans <det class="masc">un </det>modèle : xsl : if et xsl : choose . </div>
<div class="p">
<det class="masc">L' </det>instruction xsl : if sert à exprimer <det class="fem">la </det>condition simple si-alors ; <det class="masc">L' </det>instruction xsl : choose permet quant à elle <det class="masc">un </det>choix parmi plusieurs possibilités . </div>
<div class="p">9.1 Traitement conditionnel par xsl : if <det class="masc">L' </det>élément xsl : if a <det class="masc">un </det>attribut test qui spécifie <det class="fem">une </det>expression . </div>
<div class="p">
<det class="masc">Le </det>contenu est <det class="masc">un </det>modèle . </div>
<div class="p">Après évaluation de <det class="masc">l' </det>expression , <det class="masc">le </det>résultat est converti en booléen comme si elle avait été évaluée par <det class="fem">la </det>fonction boolean . </div>
<div class="p">Si <det class="masc">le </det>résultat est vrai alors <det class="masc">le </det>contenu <det class="masc">du </det>modèle est instancié , sinon rien n' est créé . </div>
<div class="p">Dans <det class="masc">l' </det>exemple suivant , <det class="masc">les </det>noms dans <det class="masc">un </det>groupe de noms sont formatés sous <det class="fem">la </det>forme d' <det class="fem">une </det>liste de noms séparés par <det class="fem">des </det>virgules : <det class="masc">L' </det>exemple suivant colore en jaune <det class="fem">une </det>ligne de tableau sur 2 ( <det class="fem">les </det>lignes de rang pair ) : 9.2 Traitement conditionnel par xsl : choose 10 tri case-order peut avoir soit <det class="fem">la </det>valeur upper-first ou <det class="fem">la </det>valeur lower-first ; ceci n' est valable que lorsque data-type="text " , et indique que <det class="fem">les </det>lettres majuscules sont triées avant <det class="fem">les </det>lettres minuscules dans <det class="masc">le </det>cas upper-first et inversement dans <det class="masc">le </det>cas lower-first . </div>
<div class="p">Par exemple , si lang="en " , alors A a B b sont triées avec case-order="upper-first " et a A b B sont triées avec case-order="lower-first " . </div>
<div class="p">
<det class="fem">La </det>valeur par défaut dépend de <det class="fem">la </det>langue . </div>
<div class="p">NOTE : Deux processeurs XSLT conformes peuvent ne pas faire exactement <det class="masc">le </det>même tri . </div>
<div class="p">Certains processeurs XSLT peuvent ne pas supporter certaines langues . </div>
<div class="p">Il peut aussi y avoir <det class="fem">des </det>variations possibles lors d' <det class="masc">un </det>tri dans n' importe quelle langue particulière qui n' est pas spécifiée par <det class="masc">l' </det>attribut de xsl : sort , par exemple , lorsque Hiragana ou Katakana est trié en Japonais dans <det class="masc">un </det>premier temps . </div>
<div class="p">
<det class="fem">Les </det>versions de XSLT peuvent fournir <det class="masc">des </det>attributs additionnels afin de permettre <det class="masc">un </det>contrôle sur <det class="fem">ces </det>variations . </div>
<div class="p">Pour cela , <det class="fem">les </det>réalisations peuvent aussi utiliser <det class="masc">des </det>attributs appartenant à <det class="masc">des </det>espaces de noms spécifiques à <det class="masc">l' </det>implémentation en question pour xsl : sort . </div>
<div class="p">NOTE : Il est recommandé <det class="fem">aux </det>développeurs de consulter [ UNICODE TR10 ] pour <det class="fem">des </det>informations sur <det class="masc">le </det>tri internationalisé . </div>
<div class="p">
<det class="masc">Le </det>tri doit être stable : dans <det class="fem">une </det>liste de noeuds triée , n' importe quel sous-liste ayant <det class="fem">des </det>clés de tri égales doit être ordonnée dans <det class="masc">l' </det>ordre <det class="masc">du </det>document . </div>
<div class="p">Considérons par exemple , <det class="fem">une </det>base de données répertoriant <det class="masc">des </det>employés et ayant <det class="fem">la </det>forme Alors , <det class="fem">une </det>liste d' employés triée par <det class="masc">le </det>nom peut être générée en utilisant 11 Variables et Paramètres &lt; ! </div>
<div class="p">Category : instruction </div>
<div class="p">&gt; &lt; xsl : variable name = qname select = expression &gt; &lt; ! </div>
<div class="p">Content : template </div>
<div class="p">&gt; &lt;/xsl:variable&gt; Si <det class="masc">le </det>contenu de <det class="masc">l' </det>élément de lien de variable est vide et <det class="masc">cet </det>élément n' a pas <det class="masc">un </det>attribut select , alors <det class="fem">la </det>valeur de <det class="fem">la </det>variable est <det class="fem">une </det>chaîne de caractères vide . </div>
<div class="p">Ainsi est équivalent à NOTE : Lorsqu' <det class="fem">une </det>variable est utilisée pour sélectionner <det class="masc">des </det>noeuds par position , éviter de faire : Cela cause <det class="masc">l' </det>affichage <det class="masc">du </det>premier élément item , car <det class="fem">la </det>variable n sera liée <det class="masc">un </det>fragment d' arbre résultat et non à <det class="masc">un </det>nombre . </div>
<div class="p">Utiliser plutôt ou NOTE : <det class="masc">Un </det>moyen pratique pour fixer <det class="fem">la </det>valeur d' <det class="masc">un </det>paramètre à <det class="masc">l' </det>ensemble de noeuds vide est : 11.3 Utilisation <det class="fem">des </det>valeurs <det class="masc">des </det>variables et <det class="masc">des </det>paramètres avec xsl : copy-of &lt; xsl : copy-of select = expression / &gt; <det class="masc">L' </det>élément xsl : copy-of , contrairement à xsl : value-of ( voir [ 7.6.1 Generating Text with xsl : value-of ] ) , peut être utilisé pour insérer <det class="masc">un </det>fragment d' arbre résultat dans <det class="masc">un </det>arbre résultat , sans avoir à commencer par le convertir en <det class="fem">une </det>chaîne de caractères . </div>
<div class="p">
<det class="masc">L' </det>attribut select exigé contient <det class="fem">une </det>expression . </div>
<div class="p">Lorsque <det class="masc">le </det>résultat de <det class="masc">l' </det>évaluation de <det class="masc">l' </det>expression est fragment d' arbre résultat , alors <det class="masc">le </det>fragment complet est copié dans <det class="masc">l' </det>arbre résultat . </div>
<div class="p">Lorsque <det class="masc">le </det>résultat est <det class="masc">un </det>ensemble de noeuds , alors tous <det class="masc">les </det>noeuds de <det class="masc">cet </det>ensemble sont copiés dans <det class="masc">l' </det>arbre résultat dans <det class="masc">le </det>même ordre où ils apparaissent dans <det class="masc">le </det>document ; <det class="fem">la </det>copie d' <det class="masc">un </det>élément noeud copie <det class="masc">les </det>noeuds attributs , <det class="masc">les </det>noeuds espaces de noms et <det class="masc">les </det>enfants de <det class="masc">l' </det>élément noeud ainsi que <det class="masc">l' </det>élément noeud lui -même ; <det class="fem">la </det>copie d' <det class="masc">un </det>noeud racine se fait par <det class="fem">la </det>copie de <det class="masc">ses </det>enfants . </div>
<div class="p">Si <det class="masc">le </det>résultat n' est ni <det class="masc">un </det>ensemble de noeuds ni <det class="masc">un </det>fragment d' arbre résultat , alors il est doit être convertit en <det class="fem">une </det>chaîne de caractères et ensuite inséré dans <det class="masc">l' </det>arbre résultat de <det class="fem">la </det>même manière qu' avec xsl : value-of . </div>
<div class="p">11.4 Variables et Paramètres de haut niveau <det class="masc">Les </det>éléments xsl : variable et xsl : param sont tous deux autorisés à être utilisés comme éléments de haut niveau ( top-level ) . </div>
<div class="p">
<det class="masc">Un </det>élément lien de variable de haut niveau déclare <det class="fem">une </det>variable globale visible partout . </div>
<div class="p">
<det class="masc">Un </det>élément xsl : param de haut niveau déclare <det class="masc">un </det>paramètre pour <det class="fem">la </det>feuille de style ; XSLT ne définit pas <det class="masc">le </det>mécanisme permettant de transmettre <det class="masc">les </det>paramètres à <det class="fem">la </det>feuille de style . </div>
<div class="p">
<det class="fem">Une </det>feuille de style ne peut contenir plus d' <det class="masc">un </det>lien à <det class="fem">une </det>variable de haut niveau ayant <det class="masc">le </det>même nom et <det class="fem">la </det>même préséance d' import . </div>
<div class="p">
<det class="masc">Au </det>niveau <det class="masc">le </det>plus haut , <det class="masc">l' </det>expression ou <det class="masc">le </det>modèle spécifiant <det class="fem">la </det>valeur d' <det class="fem">une </det>variable est évalué dans <det class="masc">le </det>même contexte <det class="masc">le </det>traitement <det class="masc">du </det>noeud racine d' <det class="masc">un </det>document source : <det class="masc">le </det>noeud courant est <det class="masc">le </det>noeud racine <det class="masc">du </det>document source et <det class="fem">la </det>liste courante de noeuds est <det class="fem">une </det>liste contenant uniquement <det class="masc">le </det>noeud racine <det class="masc">du </det>document source . </div>
<div class="p">Si <det class="masc">le </det>modèle ou <det class="masc">l' </det>expression spécifiant <det class="fem">la </det>valeur d' <det class="fem">une </det>variable globale x fait référence à <det class="fem">une </det>variable globale y , alors <det class="fem">la </det>valeur de y doit être calculée avant <det class="fem">la </det>valeur de x . </div>
<div class="p">S' il était impossible de traiter toutes <det class="fem">les </det>variables globales de <det class="fem">la </det>sorte alors c' est <det class="fem">une </det>erreur ; en d' autres termes , si <det class="fem">la </det>définition est circulaire alors c' est <det class="fem">une </det>erreur . </div>
<div class="p">
<det class="masc">L' </det>exemple suivant montre <det class="fem">la </det>déclaration d' <det class="fem">une </det>variable globale para-font-size , qui est référencée dans <det class="fem">la </det>valeur d' <det class="masc">un </det>attribut modèle . </div>
<div class="p">11.5 <det class="masc">Les </det>Variables et <det class="masc">les </det>Paramètres dans <det class="masc">les </det>modèles De même qu' il est possible d' utiliser dans les élément de haut niveau , xsl : variable et xsl : param sont aussi permis dans <det class="masc">les </det>modèles . </div>
<div class="p">Dans <det class="masc">un </det>modèle , xsl : variable est autorisé partout où <det class="fem">une </det>instruction l' est . </div>
<div class="p">Dans <det class="masc">ce </det>cas , <det class="masc">le </det>lien est visible pour tous <det class="masc">les </det>frères suivant ainsi que <det class="masc">leurs </det>descendants . </div>
<div class="p">Notez bien que <det class="masc">le </det>lien n' est pas visible par <det class="masc">l' </det>élément xsl : variable lui -même . xsl : param est permis lorsqu' il est fils <det class="masc">au </det>début d' <det class="masc">un </det>élément xsl : template . </div>
<div class="p">Dans <det class="masc">ce </det>cas précis , <det class="masc">le </det>lien est visible pour tous <det class="masc">les </det>frères suivant et à <det class="masc">leurs </det>descendants . </div>
<div class="p">Notez que <det class="masc">le </det>lien n' est pas visible par <det class="masc">l' </det>élément xsl : param lui -même . </div>
<div class="p">
<det class="masc">Un </det>lien inhibe <det class="masc">un </det>autre lien si <det class="masc">le </det>lien se produit à <det class="masc">un </det>point où <det class="masc">l' </det>autre lien est visible , et <det class="masc">les </det>deux liens doivent avoir <det class="masc">le </det>même nom . </div>
<div class="p">Si <det class="masc">un </det>lien établit par <det class="masc">un </det>élément xsl : variable ou <det class="masc">un </det>élément xsl : param dans <det class="masc">un </det>modèle inhibe <det class="masc">un </det>autre lien établit aussi dans <det class="masc">un </det>modèle par <det class="masc">un </det>élément xsl : variable ou <det class="masc">un </det>élément xsl : param alors c' est <det class="fem">une </det>erreur . </div>
<div class="p">Par contre , lien un établit par <det class="masc">un </det>élément xsl : variable ou <det class="masc">un </det>élément xsl : param dans <det class="masc">un </det>modèle peut inhiber <det class="masc">un </det>autre lien établit par <det class="masc">un </det>élément de haut niveau xsl : variable ou <det class="masc">un </det>élément de haut niveau xsl : param . </div>
<div class="p">Ainsi , ce qui suit est erroné : &lt;xsl:template name="foo"&gt; &lt;xsl:param name="x" select="1"/&gt; &lt;xsl:variable name="x" select="2"/&gt; &lt;/xsl:template&gt; Cependant ce qui suit est autorisé : NOTE : <det class="masc">L' </det>équivalent Java <det class="masc">le </det>plus proche d' <det class="masc">un </det>élément xsl : variable dans <det class="masc">un </det>modèle est <det class="fem">la </det>déclaration avec initialisation d' <det class="fem">une </det>variable locale terminale . </div>
<div class="p">Par exemple , a <det class="fem">la </det>même sémantique que XSLT ne fournit pas <det class="masc">un </det>équivalent à <det class="masc">l' </det>opérateur d' initialisation de Java car ceci rend plus difficile <det class="fem">une </det>implémentation qui traite <det class="masc">un </det>document d' <det class="fem">une </det>manière autre que <det class="fem">la </det>manière de traitement par lots , partant <det class="masc">du </det>début jusqu' à <det class="fem">la </det>fin . </div>
<div class="p">11.6 Passage de paramètres <det class="masc">aux </det>modèles <det class="masc">Le </det>passage de paramètres <det class="fem">aux </det>modèle se fait par <det class="masc">le </det>moyen de <det class="masc">l' </det>élément xsl : with-param . </div>
<div class="p">
<det class="masc">L' </det>attribut name obligatoire indique <det class="masc">le </det>nom <det class="masc">du </det>paramètre ( <det class="fem">la </det>variable dont <det class="fem">la </det>valeur doit être remplacée ) . </div>
<div class="p">
<det class="fem">La </det>valeur de <det class="masc">l' </det>attribut name est <det class="masc">un </det>QName , qui est résolu comme décrit dans [ 2.4 Noms qualifiés ] . xsl : with-param est permis aussi bien dans xsl : call-template que dans xsl : apply-templates . </div>
<div class="p">
<det class="fem">La </det>valeur <det class="masc">du </det>paramètre est spécifiée de <det class="fem">la </det>même manière que pour xsl : variable et xsl : param . </div>
<div class="p">
<det class="masc">Le </det>noeud courant et <det class="fem">la </det>liste courante de noeuds utilisés pour calculer <det class="fem">la </det>valeur spécifiée par <det class="masc">l' </det>élément xsl : with-param sont <det class="masc">les </det>mêmes que ceux utilisés pour <det class="masc">l' </det>élément xsl : apply-templates ou pour <det class="masc">l' </det>élément xsl : call-template dans lequel il se apparaît . </div>
<div class="p">Ce n' est pas <det class="fem">une </det>erreur de passer <det class="masc">un </det>paramètre x à <det class="masc">un </det>modèle qui n' a pas d' élément xsl : param pour <det class="masc">le </det>paramètre x ; dans <det class="masc">ce </det>cas là , <det class="masc">le </det>paramètre x est tout simplement ignoré . </div>
<div class="p">
<det class="masc">L' </det>exemple suivant défini <det class="masc">un </det>modèle nommé pour <det class="masc">un </det>numbered-block avec <det class="masc">un </det>argument pour contrôler <det class="masc">le </det>format <det class="masc">du </det>nombre . </div>
<div class="p">12 Fonctions additionnelles <det class="fem">Cette </det>section décrit <det class="masc">les </det>mécanismes d' ajout de fonctions spécifiques à <det class="fem">la </det>librairie <det class="fem">des </det>fonctions <det class="masc">du </det>noyau de XPath . </div>
<div class="p">Certaines de <det class="fem">ces </det>fonctions additionnelles se servent d' informations spécifiées par <det class="masc">des </det>éléments de premier niveau dans <det class="fem">la </det>feuille de style ; <det class="fem">cette </det>section décrit aussi <det class="masc">ces </det>éléments . </div>
<div class="p">12.1 Documents avec sources multiples Fonction : node-setdocument ( object , node-set ? ) <det class="fem">La </det>fonction document permet d' accéder <det class="masc">aux </det>documents XML autres que <det class="masc">le </det>document source principal . </div>
<div class="p">Lorsque <det class="fem">la </det>fonction document a exactement <det class="masc">un </det>argument et que <det class="masc">cet </det>argument est <det class="masc">un </det>ensemble de noeuds alors , <det class="masc">le </det>résultat est <det class="masc">l' </det>union , pour chaque noeud de <det class="masc">l' </det>ensemble de noeuds reçu en argument , <det class="masc">du </det>résultat de <det class="masc">l' </det>exécution de <det class="fem">la </det>fonction document avec comme premier argument <det class="fem">la </det>string-value <det class="masc">du </det>noeud , et comme deuxième argument <det class="masc">un </det>ensemble de noeuds dont <det class="masc">l' </det>unique élément est <det class="masc">le </det>noeud lui -même . </div>
<div class="p">Lorsque <det class="fem">la </det>fonction document a deux arguments et que <det class="masc">le </det>premier argument est <det class="masc">un </det>ensemble de noeuds alors , <det class="masc">le </det>résultat est <det class="fem">la </det>réunion , pour chaque noeud de <det class="masc">l' </det>ensemble de noeuds reçu en argument , <det class="masc">du </det>résultat de <det class="masc">l' </det>exécution de <det class="fem">la </det>fonction document avec comme premier argument <det class="fem">la </det>string-value <det class="masc">du </det>noeud et , comme deuxième argument , <det class="masc">le </det>deuxième argument passé à <det class="fem">la </det>fonction document . </div>
<div class="p">Si <det class="masc">le </det>premier argument de <det class="fem">la </det>fonction document n' est pas <det class="masc">un </det>ensemble de noeuds alors il sera convertit en <det class="fem">une </det>chaîne de caractères comme par <det class="masc">l' </det>exécution de <det class="fem">la </det>fonction string . </div>
<div class="p">
<det class="fem">Cette </det>chaîne de caractères est traitée comme <det class="fem">une </det>référence à <det class="masc">un </det>URI ; <det class="fem">la </det>ressource identifiée par <det class="masc">l' </det>URI est extraite . </div>
<div class="p">
<det class="fem">Les </det>données résultant de <det class="fem">la </det>fonction d' extraction sont analysées comme <det class="masc">un </det>document XML et <det class="masc">un </det>arbre est construit en concordance avec <det class="masc">le </det>modèle de données ( voir [ 3 Modèle de données ] ) . </div>
<div class="p">Si <det class="masc">l' </det>extraction de <det class="fem">la </det>ressource se solde par <det class="fem">une </det>erreur alors , <det class="masc">le </det>processeur XSLT peut signaler <det class="masc">l' </det>erreur ; s' il ne le fait pas , il doit récupérer sur <det class="masc">l' </det>erreur en retournant <det class="masc">un </det>ensemble vide de noeuds . </div>
<div class="p">
<det class="fem">Une </det>erreur pouvant se produire à <det class="masc">l' </det>extraction résulte <det class="masc">du </det>fait que <det class="masc">le </det>processeur XSLT ne supporte pas <det class="masc">le </det>schéma utilisé par <det class="masc">l' </det>URI . <det class="masc">Un </det>processeur XSLT n' est sensé supporter aucun schéma particulier d' URI . <det class="masc">Les </det>schémas d' URI supportés par <det class="masc">un </det>processeur XSLT doivent être clairement indiqués dans <det class="fem">sa </det>documentation . </div>
<div class="p">Si <det class="fem">la </det>référence à <det class="masc">l' </det>URI ne contient pas <det class="masc">un </det>identificateur de fragment alors , <det class="fem">la </det>fonction retourne <det class="masc">l' </det>ensemble de noeuds contenant uniquement <det class="masc">le </det>noeud racine <det class="masc">du </det>document . </div>
<div class="p">Si <det class="fem">la </det>référence à <det class="masc">l' </det>URI contient <det class="masc">un </det>identificateur de fragment alors , <det class="fem">la </det>fonction retourne <det class="masc">un </det>ensemble de noeuds contenant <det class="masc">les </det>noeuds de <det class="masc">l' </det>arbre identifiés par <det class="masc">l' </det>identificateur <det class="masc">du </det>fragment de <det class="fem">la </det>référence à <det class="masc">l' </det>URI . <det class="fem">La </det>sémantique de <det class="masc">l' </det>identificateur de fragment dépend <det class="masc">du </det>type de média <det class="masc">du </det>résultat de <det class="masc">l' </det>extraction de <det class="masc">l' </det>URI . Si lors <det class="masc">du </det>traitement de <det class="masc">l' </det>identificateur de fragment , <det class="fem">une </det>erreur se produisait , alors <det class="masc">le </det>processeur XSLT peut signaler <det class="fem">cette </det>erreur ; dans <det class="masc">le </det>cas contraire , il doit récupérer <det class="masc">l' </det>erreur en retournant <det class="masc">un </det>ensemble vide de noeuds . </div>
<div class="p">
<det class="fem">Les </det>erreurs possibles comportent : <det class="masc">L' </det>identificateur <det class="masc">du </det>fragment fait référence à quelque chose qui ne peut être représentée par <det class="fem">une </det>ensemble de noeuds XSLT ( telle qu' <det class="fem">une </det>chaîne de caractères dans <det class="masc">un </det>noeud texte ) . </div>
<div class="p">
<det class="masc">Le </det>processeur XSLT ne supporte pas <det class="masc">les </det>identificateurs <det class="masc">du </det>fragment pour <det class="masc">le </det>type de média <det class="masc">du </det>résultat de récupération . </div>
<div class="p">
<det class="masc">Un </det>processeur XSLT n' est pas supposé de supporter <det class="masc">un </det>type particulier de types de média . </div>
<div class="p">
<det class="fem">La </det>documentation de chaque processeur XSLT doit indiquer pour quels type de médias <det class="masc">le </det>processeur supporte <det class="masc">les </det>identificateurs de fragments . </div>
<div class="p">
<det class="fem">Les </det>données résultant de <det class="masc">l' </det>action d' extraction sont analysées comme <det class="masc">un </det>document XML sans tenir compte <det class="masc">du </det>type de média <det class="masc">du </det>résultat de <det class="masc">l' </det>extraction ; si <det class="masc">le </det>type média de haut niveau est text , alors il est analysé comme si <det class="masc">le </det>type média était text / xml ; autrement , il est analysé comme si <det class="masc">le </det>type média était application / xml . </div>
<div class="p">NOTE : Puisqu' il n' y a pas de type média xml de haut niveau , <det class="fem">les </det>données avec <det class="masc">un </det>type média autre que text / xml ou application / xml peuvent être XML . <det class="fem">La </det>référence à <det class="masc">l' </det>URI peut être relative . </div>
<div class="p">
<det class="masc">L' </det>URI de base ( voir [ 3.2 URI base ] ) <det class="masc">du </det>noeud qui apparaît <det class="masc">le </det>premier dans <det class="masc">le </det>document et qui appartient à <det class="masc">l' </det>ensemble de noeuds <det class="masc">du </det>deuxième argument est utilisé comme URI de base pour résoudre <det class="masc">les </det>URI relatives et <det class="fem">les </det>transformer en URI absolues . Lorsque <det class="masc">le </det>deuxième argument est omis , <det class="masc">le </det>noeud de <det class="fem">la </det>feuille de style qui contient <det class="masc">l' </det>expression incluant <det class="masc">un </det>appel à <det class="fem">la </det>fonction document est utilisé comme noeud de substitution par défaut . </div>
<div class="p">Notez qu' <det class="fem">une </det>référence à <det class="fem">une </det>URI de taille nulle est <det class="fem">une </det>référence <det class="masc">au </det>document dont <det class="masc">l' </det>URI qui lui est relative est en cours de résolution ; ainsi document ( " " ) fait référence <det class="masc">au </det>noeud racine de <det class="fem">la </det>feuille de style ; <det class="fem">la </det>représentation en arbre de <det class="fem">la </det>feuille de style est exactement <det class="fem">la </det>même que si <det class="masc">le </det>document XML contenant <det class="fem">la </det>feuille de style était <det class="masc">le </det>document source initial . </div>
<div class="p">Deux documents sont traités comme <det class="masc">le </det>même document s' ils sont identifiés par <det class="masc">le </det>même URI . <det class="masc">L' </det>URI absolue est utilisé pour <det class="fem">la </det>comparaison dans laquelle chaque URI relative a été résolue et ne contient aucun identificateur de fragment . </div>
<div class="p">
<det class="masc">Un </det>noeud racine est traité comme si c' était <det class="masc">le </det>même noeud qu' <det class="masc">un </det>autre noeud racine si <det class="masc">les </det>deux noeuds sont tous deux <det class="masc">du </det>même document . </div>
<div class="p">Ainsi , <det class="masc">l' </det>expression suivante est toujours vrai : <det class="fem">La </det>fonction document augmente <det class="fem">la </det>possibilité qu' <det class="masc">un </det>ensemble de noeuds puisse contenir <det class="masc">des </det>noeuds provenant de plusieurs documents . </div>
<div class="p">Avec <det class="masc">un </det>tel ensemble de noeuds , <det class="masc">l' </det>ordre <det class="masc">du </det>document relatif pour deux noeuds dans <det class="masc">un </det>même document est <det class="masc">l' </det>ordre <det class="masc">du </det>document normal définit par XPath [ XPath ] . </div>
<div class="p">
<det class="masc">L' </det>ordre de deux noeuds relatif <det class="masc">au </det>document dans deux documents différents est déterminé <det class="masc">un </det>ordre dépendant de <det class="masc">l' </det>implémentation <det class="masc">des </det>documents contenant <det class="masc">les </det>deux noeuds . </div>
<div class="p">Il n' y a pas de contraintes sur <det class="fem">la </det>manière selon laquelle <det class="masc">l' </det>implémentation ordonne <det class="masc">les </det>documents autres que le fait que <det class="masc">l' </det>ordonnancement doit se faire du'une manière consistante : <det class="fem">une </det>implémentation doit toujours utiliser <det class="masc">le </det>même ordre pour <det class="masc">le </det>même ensemble de documents . </div>
<div class="p">12.2 Clés <det class="fem">Les </det>clés procurent <det class="masc">le </det>moyen de travailler avec <det class="masc">des </det>documents contenant <det class="fem">une </det>structure implicite de références croisées . </div>
<div class="p">
<det class="masc">Les </det>types d' attributs ID , IDREF et IDREFS dans XML fournissent <det class="masc">un </det>mécanisme permettant <det class="masc">les </det>documents XML de rendre explicites <det class="fem">leurs </det>références croisées . </div>
<div class="p">
<det class="fem">La </det>fonction id de XPath permet à XSLT de supporter <det class="masc">ce </det>mécanisme . </div>
<div class="p">Cela dit , <det class="masc">ce </det>mécanisme a <det class="masc">un </det>certain nombre de limitations : <det class="masc">Les </det>attributs ID doivent être déclarés comme dans <det class="fem">une </det>DTD . Si <det class="masc">un </det>attribut ID n' est déclaré que dans un sous ensemble externe de DTD alors , il ne sera reconnu en tant que tel que si <det class="masc">le </det>processeur XML tenait compte <det class="masc">du </det>sous ensemble externe de <det class="fem">la </det>DTD . Cependant , XML n' exige pas <det class="masc">des </det>processeurs XML de tenir compte <det class="masc">des </det>DTD externes . </div>
<div class="p">Ils peuvent bien choisir , à raison , de ne pas lire et considérer <det class="masc">les </det>DTDs externes , particulièrement si <det class="masc">le </det>document est déclaré avec <det class="masc">l' </det>attribut standalone="yes " . </div>
<div class="p">
<det class="masc">Un </det>document peut contenir <det class="masc">un </det>seul ensemble d' IDs uniques . </div>
<div class="p">Il ne peut y avoir <det class="fem">des </det>ensembles séparés et indépendants d' IDs uniques . </div>
<div class="p">
<det class="masc">L' </det>ID d' <det class="masc">un </det>élément ne peut être spécifié que dans <det class="masc">un </det>attribut ; il ne peut être spécifié par <det class="masc">le </det>contenu d' <det class="masc">un </det>élément ou par <det class="masc">un </det>élément fils . </div>
<div class="p">
<det class="masc">Un </det>ID ne peut être autre qu' <det class="masc">un </det>nom XML . Il ne peut , par exemple pas , contenir <det class="masc">des </det>espaces . </div>
<div class="p">
<det class="masc">Un </det>élément peut avoir <det class="masc">au </det>plus <det class="masc">un </det>ID . <det class="masc">Un </det>élément <det class="masc">au </det>plus peut avoir <det class="masc">un </det>ID particulier . </div>
<div class="p">À cause <det class="fem">ces </det>limitations , <det class="masc">les </det>documents XML peuvent parfois contenir <det class="fem">une </det>structure de références croisées qui n' est pas explicitement déclarée par <det class="masc">les </det>attributs ID / IDREF / IDREFS . <det class="fem">Une </det>clé est <det class="masc">un </det>triplet contenant : <det class="masc">un </det>noeud contenant <det class="fem">la </det>clé <det class="masc">le </det>nom de <det class="fem">la </det>clé ( <det class="masc">un </det>nom étendu ) <det class="fem">la </det>valeur de <det class="fem">la </det>clé ( <det class="fem">une </det>chaîne de caractères ) Pour chaque document , <det class="fem">une </det>feuille de style déclare <det class="masc">un </det>ensemble de clé à <det class="masc">l' </det>aide de <det class="masc">l' </det>élément xsl : key . </div>
<div class="p">Pour <det class="masc">un </det>élément de <det class="masc">cet </det>ensemble de clés ayant <det class="masc">un </det>noeud x , <det class="masc">un </det>nom y et <det class="fem">une </det>valeur z , nous disons que <det class="masc">le </det>noeud x a <det class="fem">une </det>clé dont <det class="masc">le </det>nom est y et <det class="fem">la </det>valeur est z . </div>
<div class="p">Ainsi , <det class="fem">une </det>clé est <det class="fem">une </det>sorte de ID généralisé qui n' est pas contraint par <det class="fem">les </det>mêmes limitations qu' <det class="masc">un </det>ID XML : <det class="fem">Les </det>clés sont déclarées dans <det class="fem">les </det>feuilles de style en utilisant <det class="masc">les </det>éléments xsl : key . </div>
<div class="p">
<det class="fem">Une </det>clé a <det class="masc">un </det>nom ainsi qu' <det class="fem">une </det>valeur ; chaque nom de clé être considéré comme distinguant <det class="fem">une </det>espace d' identificateurs séparé et indépendant . </div>
<div class="p">
<det class="fem">La </det>valeur d' <det class="fem">une </det>clé nommée peut être spécifiée à qui parait <det class="masc">le </det>plus commode ; par exemple , dans <det class="masc">un </det>attribut , dans <det class="masc">un </det>élément fils ou dans <det class="masc">le </det>contenu de <det class="masc">l' </det>élément . </div>
<div class="p">
<det class="fem">Une </det>expression XPath sert à indiquer où trouver <det class="fem">la </det>valeur d' <det class="fem">une </det>clé nommée particulière . </div>
<div class="p">
<det class="fem">La </det>valeur d' <det class="fem">une </det>clé n' est pas forcement <det class="masc">un </det>nom et peut être <det class="fem">une </det>chaîne de caractères arbitraire . </div>
<div class="p">
<det class="masc">Un </det>document peut contenir plusieurs clés avec <det class="masc">le </det>même noeud , <det class="masc">le </det>même nom de clé mais ayant <det class="fem">des </det>valeurs différentes . </div>
<div class="p">
<det class="masc">Un </det>document peut contenir plusieurs clés ayant <det class="masc">le </det>même nom , <det class="fem">la </det>même valeur mais <det class="masc">des </det>noeuds différents . &lt; xsl : key name = qname match = pattern use = expression / &gt; <det class="masc">L' </det>élément xsl : key sert à <det class="fem">la </det>déclaration de clés . </div>
<div class="p">
<det class="masc">Le </det>nom de <det class="fem">la </det>clé est spécifié dans <det class="masc">l' </det>attribut name . </div>
<div class="p">
<det class="fem">La </det>valeur de <det class="masc">l' </det>attribut name est <det class="masc">un </det>QName , qui est étendu comme indiqué dans [ 2.4 Noms qualifiés ] . </div>
<div class="p">
<det class="masc">L' </det>attribut match est <det class="masc">un </det>Pattern ; <det class="masc">un </det>élément xsl : key informe sur <det class="fem">les </det>clés de n' importe quel noeud et qui concordent avec <det class="masc">un </det>motif spécifié par <det class="masc">l' </det>attribut match . </div>
<div class="p">
<det class="masc">L' </det>attribut use est <det class="fem">une </det>expression spécifiant <det class="fem">la </det>valeur de <det class="fem">la </det>clé ; <det class="fem">cette </det>expression est évaluée <det class="fem">une </det>fois pour chaque noeud concordant avec <det class="masc">le </det>motif . </div>
<div class="p">Si <det class="masc">le </det>résultat est <det class="masc">un </det>ensemble de noeuds alors , pour chaque noeud de <det class="masc">cet </det>ensemble , <det class="masc">le </det>noeud concordant avec <det class="masc">le </det>motif a <det class="fem">une </det>clé dont <det class="masc">le </det>nom est celui spécifié et dont <det class="fem">la </det>valeur est celle de <det class="fem">la </det>chaîne de caractères <det class="masc">du </det>noeud de <det class="masc">l' </det>ensemble de noeuds ; autrement <det class="masc">le </det>résultat est convertit en <det class="fem">une </det>chaîne de caractères et <det class="masc">le </det>noeud qui concorde avec <det class="masc">le </det>motif a <det class="fem">une </det>clé dont <det class="masc">le </det>nom est celui spécifié et dont dont <det class="fem">la </det>valeur est égale à <det class="fem">cette </det>chaîne de caractères . </div>
<div class="p">Ainsi , <det class="masc">un </det>noeud x a <det class="fem">une </det>clé dont <det class="masc">le </det>nom est y et dont <det class="fem">la </det>valeur est z si et seulement s' il existe <det class="masc">un </det>élément xsl : key tel que : x concorde avec <det class="masc">le </det>motif spécifié par <det class="masc">l' </det>attribut match de <det class="masc">l' </det>élément xsl : key ; <det class="fem">la </det>valeur de <det class="masc">l' </det>attribut name de <det class="masc">l' </det>élément xsl : key est égale à y ; et Lorsque <det class="masc">l' </det>expression spécifiée par <det class="masc">l' </det>attribut use de <det class="masc">l' </det>élément xsl : key est évaluée avec , comme noeud courant , <det class="masc">le </det>noeud x et comme liste courante de noeuds <det class="fem">la </det>liste contenant uniquement <det class="masc">le </det>noeud x résultant dans <det class="masc">un </det>objet u , alors , ou bien z est égal <det class="masc">au </det>résultat de conversion de <det class="masc">l' </det>objet u en <det class="fem">une </det>chaîne de caractères comme par une appel à <det class="fem">la </det>fonction string , ou alors , u est <det class="fem">une </det>ensemble de noeuds et z est égal a <det class="fem">la </det>valeur de <det class="fem">la </det>chaîne de caractères d' un ou plusieurs noeuds dans u . </div>
<div class="p">Notez bien aussi qu' il est possible d' avoir plus d' <det class="masc">un </det>élément xsl : key concordant <det class="masc">un </det>noeud donné ; tous <det class="masc">les </det>éléments xsl : key concordants sont utilisés , même si <det class="fem">leurs </det>préséance d' import n' est pas <det class="fem">la </det>même . </div>
<div class="p">Si <det class="masc">l' </det>un <det class="masc">des </det>attributs use ou match contenait <det class="fem">une </det>VariableReference alors c' est <det class="fem">une </det>erreur . </div>
<div class="p">Fonction : node-setkey ( string , object ) <det class="fem">La </det>fonction key joue <det class="masc">le </det>même rôle pour <det class="fem">les </det>clés que celui de <det class="fem">la </det>fonction id pour <det class="masc">les </det>IDs . </div>
<div class="p">
<det class="masc">Le </det>premier argument spécifie <det class="masc">le </det>nom de <det class="fem">la </det>clé . </div>
<div class="p">
<det class="fem">La </det>valeur de <det class="masc">cet </det>argument doit être <det class="masc">un </det>QName , qui est étendu comme c' est décrit dans [ 2.4 Noms qualifiés ] . </div>
<div class="p">Lorsque <det class="masc">le </det>type <det class="masc">du </det>deuxième argument de <det class="fem">la </det>fonction key est <det class="masc">un </det>ensemble de noeuds alors , <det class="masc">le </det>résultat est <det class="fem">la </det>réunion <det class="masc">des </det>résultats de <det class="masc">l' </det>application de <det class="fem">la </det>fonction key à <det class="fem">la </det>valeur de <det class="fem">la </det>chaîne de caractères de chacun <det class="masc">des </det>noeuds de <det class="masc">l' </det>ensemble de noeuds reçu en deuxième argument par <det class="fem">la </det>fonction . </div>
<div class="p">Si <det class="masc">le </det>type <det class="masc">du </det>deuxième argument de <det class="fem">la </det>fonction key n' est pas <det class="masc">un </det>ensemble de noeuds alors <det class="masc">l' </det>argument est converti en <det class="fem">une </det>chaîne de caractères de <det class="fem">la </det>même manière que par <det class="masc">l' </det>appel de <det class="fem">la </det>fonction string ; elle retourne , sous forme d' <det class="masc">un </det>ensemble de noeuds contenant <det class="masc">les </det>noeuds <det class="masc">du </det>même document , <det class="masc">un </det>noeud contexte dont <det class="fem">la </det>valeur de <det class="fem">la </det>clé nommée est égale à <det class="fem">cette </det>chaîne de caractères . </div>
<div class="p">Étant donné , par exemple , <det class="fem">la </det>déclaration suivante : <det class="masc">l' </det>expression key ( " idkey " , @ref ) retourne <det class="masc">le </det>même ensemble de noeuds que id ( @ref ) , à condition que <det class="masc">le </det>seul attribut ID déclaré dans <det class="masc">le </det>document source XML est : et que <det class="masc">l' </det>attribut ref <det class="masc">du </det>noeud courant ne contient pas d' espaces . </div>
<div class="p">Considérons <det class="masc">un </det>document décrivant <det class="fem">une </det>librairie de fonction et utilisant <det class="masc">un </det>élément prototype pour définir <det class="fem">les </det>fonctions ainsi qu' <det class="masc">un </det>élément function pour faire référence <det class="masc">aux </det>noms <det class="masc">des </det>fonctions <det class="fem">La </det>feuille de style peut alors générer <det class="masc">des </det>hyperliens entre <det class="fem">les </det>références et <det class="fem">les </det>définition comme suit : <det class="fem">La </det>fonction key peut être utilisée pour récupérer <det class="fem">une </det>clé à partir d' <det class="masc">un </det>document autre que <det class="masc">le </det>document contenant <det class="masc">le </det>noeud contexte . </div>
<div class="p">Supposons par exemple , <det class="masc">un </det>document contenant <det class="fem">des </det>références bibliographiques sous <det class="fem">la </det>forme &lt;bibref&gt; XSLT &lt;/bibref&gt; , et qu' il y ait <det class="masc">un </det>document XML séparé bib . xml contenant <det class="fem">la </det>base de données bibliographiques dont <det class="fem">les </det>entrées sous de <det class="fem">la </det>forme : Alors , pour <det class="fem">la </det>transformation <det class="masc">des </det>éléments bibref <det class="fem">la </det>feuille de style peut contenir ce qui suit : 12.3 Formatage de nombres Fonction : stringformat-number ( number , string , string ? ) <det class="fem">La </det>fonction format-number converti <det class="masc">son </det>premier argument en <det class="fem">une </det>chaîne de caractères en utilisant comme format de conversion , <det class="fem">la </det>chaîne de caractères motif spécifiée par <det class="masc">le </det>deuxième argument et <det class="masc">le </det>format décimal indiqué par <det class="masc">le </det>troisième argument , ou <det class="masc">le </det>format décimal par défaut en cas d' absence <det class="masc">du </det>troisième argument . </div>
<div class="p">
<det class="fem">La </det>chaîne de caractères motif de conversion doit respecter <det class="fem">la </det>syntaxe spécifiée par <det class="fem">la </det>classe DecimalFormat de JDK 1.1 . </div>
<div class="p">
<det class="fem">La </det>chaîne de caractères motif doit être <det class="fem">une </det>chaîne localisée : <det class="masc">le </det>format décimal détermine quels sont <det class="masc">les </det>caractères ayant <det class="fem">une </det>signification particulière dans <det class="masc">le </det>motif ( à <det class="masc">l' </det>exception <det class="masc">du </det>caractère guillemet qui n' est pas localisé ) . </div>
<div class="p">
<det class="masc">Le </det>motif de format ne doit pas contenir <det class="masc">le </det>symbole monétaire ( # x00A4 ) ; <det class="masc">le </det>support de <det class="fem">cette </det>caractéristique a été ajouté après <det class="fem">la </det>release initiale de JDK 1.1 . </div>
<div class="p">
<det class="masc">Le </det>nom <det class="masc">du </det>format5 décimal doit être <det class="masc">un </det>QName , qui est étendu comme décrit dans [ 2.4 Noms qualifiés ] . </div>
<div class="p">Si <det class="fem">la </det>feuille de style ne contient pas <det class="fem">une </det>déclaration <det class="masc">du </det>format décimal avec expanded-name spécifié alors c' est <det class="fem">une </det>erreur . </div>
<div class="p">NOTE : <det class="fem">Les </det>implémentations ne doivent pas forcément utiliser <det class="masc">l' </det>implémentation de JDK 1.1 implémentation , et les implémentation ne doivent pas être forcément réalisées en Java . </div>
<div class="p">NOTE : <det class="fem">Les </det>feuilles de style peuvent utiliser d' autres moyens de XPath pour contrôler <det class="masc">l' </det>arrondissement <det class="masc">des </det>nombres . &lt; xsl : decimal-format name = qname decimal-separator = char grouping-separator = char infinity = string minus-sign = char NaN = string percent = char per-mille = char zero-digit = char digit = char pattern-separator = char / &gt; <det class="masc">L' </det>élément xsl : decimal-format déclare <det class="masc">un </det>format décimal qui contrôle <det class="masc">l' </det>interprétation d' <det class="masc">un </det>motif de format utilisé par <det class="fem">la </det>fonction format-number . </div>
<div class="p">S' il y a <det class="masc">un </det>attribut name alors , <det class="masc">l' </det>élément déclare <det class="masc">un </det>format décimal nommé ; autrement , il déclare <det class="masc">le </det>format décimal par défaut . </div>
<div class="p">
<det class="fem">La </det>valeur de <det class="masc">l' </det>attribut name est <det class="masc">un </det>QName , qui est étendu comme décrit dans [ 2.4 Noms qualifiés ] . </div>
<div class="p">A moins qu' <det class="masc">un </det>format décimal ne soit déclaré chaque fois avec <det class="fem">la </det>même valeur pour tous <det class="masc">les </det>attributs ( en tenant compte de n' importes quelles valeurs par défaut ) , <det class="fem">la </det>déclaration multiple ( même avec <det class="fem">des </det>préséances d' import différentes ) , <det class="masc">du </det>format décimal par défaut ou d' <det class="masc">un </det>format décimal nommé est <det class="fem">une </det>erreur . </div>
<div class="p">
<det class="masc">Les </det>autres attributs de <det class="masc">l' </det>élément xsl : decimal-format correspondent <det class="fem">aux </det>méthodes de <det class="fem">la </det>classe DecimalFormatSymbols de JDK 1.1 . </div>
<div class="p">Pour chaque paire de méthodes get / set il existe <det class="masc">un </det>attribut défini pour <det class="masc">l' </det>élément xsl : decimal-format . </div>
<div class="p">
<det class="masc">Les </det>attributs suivants permettent de contrôler aussi bien <det class="masc">l' </det>interprétation <det class="masc">des </det>caractères dans <det class="masc">le </det>motif de format que de spécifier <det class="masc">les </det>caractères pouvant apparaître dans <det class="masc">le </det>résultat de formatage <det class="masc">du </det>nombre : decimal-separator indique <det class="masc">le </det>caractère utilisé pour <det class="masc">le </det>symbole <det class="fem">des </det>décimales ; <det class="fem">la </det>valeur par défaut est <det class="masc">le </det>caractère point ( . ) grouping-separator indique <det class="masc">le </det>caractère utilisé comme séparateur de groupes ( e . g . milliers ) ; <det class="fem">la </det>valeur par défaut est <det class="masc">le </det>caractère virgule ( , ) percent indique <det class="masc">le </det>caractère utilisé pour <det class="masc">le </det>signe pour-cent ; <det class="fem">la </det>valeur par défaut est <det class="masc">le </det>caractère pour-cent ( % ) per-mille indique <det class="masc">le </det>caractère utilisé pour <det class="masc">le </det>signe pour-mille ; <det class="fem">la </det>valeur par défaut est <det class="masc">le </det>caractère Unicode pour-mille ( # x2030 ) zero-digit indique <det class="masc">le </det>caractère utilisé pour <det class="masc">le </det>chiffre zéro ; <det class="fem">la </det>valeur par défaut est <det class="masc">le </det>chiffre zéro ( 0 ) <det class="masc">Les </det>attributs suivants contrôlent <det class="masc">l' </det>interprétation <det class="masc">des </det>caractères dans <det class="masc">le </det>motif de format : digit indique <det class="masc">le </det>caractère utilisé pour <det class="masc">un </det>chiffre dans <det class="masc">le </det>motif de format ; <det class="fem">la </det>valeur par défaut est <det class="masc">le </det>caractère dièse ( # ) pattern-separator indique <det class="masc">le </det>caractère utilisé dans <det class="masc">un </det>motif , pour séparer <det class="masc">les </det>sous-motifs représentant <det class="masc">des </det>nombres positifs <det class="fem">des </det>sous motifs représentant <det class="masc">des </det>nombres négatifs ; <det class="fem">la </det>valeur par défaut est <det class="masc">le </det>caractère point-virgule ( ; ) <det class="masc">Les </det>attributs suivants indiquent <det class="masc">les </det>caractères ou <det class="fem">les </det>chaînes de caractères pouvant apparaître dans <det class="masc">le </det>résultat de formatage d' <det class="masc">un </det>nombre : infinity indique <det class="fem">la </det>chaîne de caractères utilisée pour représenter <det class="masc">l' </det>infinité ; <det class="fem">la </det>valeur par défaut est <det class="fem">la </det>chaîne de caractères Infinity NaN indique <det class="fem">la </det>chaîne de caractères utilisée pour représenter <det class="fem">la </det>valeur de NaN ( Not a Number ) ; <det class="fem">la </det>valeur par défaut est <det class="fem">la </det>chaîne de caractères NaN minus-sign indique <det class="masc">le </det>caractère utilisé comme signe moins par défaut ; <det class="fem">la </det>valeur par défaut est <det class="fem">la </det>caractère tiret-moins ( - , # x2D ) 12.4 Fonctions additionnelles diverses Fonction : node-setcurrent ( ) <det class="fem">La </det>fonction current retourne <det class="masc">un </det>ensemble de noeuds ayant pour seul élément <det class="masc">le </det>noeud courant . </div>
<div class="p">Pour <det class="fem">une </det>expression indépendante ( ne se produisant pas dans <det class="fem">une </det>autre expression ) , <det class="masc">le </det>noeud courant est toujours <det class="masc">le </det>même que <det class="masc">le </det>noeud contexte . </div>
<div class="p">Ainsi , a <det class="fem">la </det>même signification que Cependant dans <det class="masc">des </det>crochets , <det class="masc">le </det>noeud courant est habituellement différent <det class="masc">du </det>noeud contexte . </div>
<div class="p">Par exemple , traite tous <det class="masc">les </det>éléments item qui ont <det class="masc">un </det>élément glossary parent et qui ont <det class="masc">un </det>attribut name dont <det class="fem">la </det>valeur est égale à <det class="fem">la </det>valeur de <det class="masc">l' </det>attribut ref <det class="masc">du </det>noeud courant . </div>
<div class="p">Ceci est différent de qui signifie <det class="fem">la </det>même chose que permettant de traiter tous <det class="masc">les </det>éléments item ayant <det class="masc">un </det>élément glossary parent et ayant <det class="masc">un </det>attribut name et <det class="masc">un </det>attribut ref ayant <det class="fem">la </det>même valeur . </div>
<div class="p">
<det class="masc">L' </det>utilisation de <det class="fem">la </det>fonction current dans <det class="masc">un </det>motif est <det class="fem">une </det>erreur . </div>
<div class="p">Fonction : stringunparsed-entity-uri ( string ) <det class="fem">La </det>fonction unparsed-entity-uri retourne <det class="masc">l' </det>URI de <det class="masc">l' </det>entité non valide avec <det class="masc">un </det>nom spécifié dans <det class="masc">le </det>même document que <det class="masc">le </det>noeud contexte ( voir [ 3.3 Entités non valides ] ) . </div>
<div class="p">Si <det class="fem">une </det>pareille entité n' existe pas alors <det class="fem">la </det>fonction retourne <det class="fem">une </det>chaîne de caractères vide . </div>
<div class="p">Fonction : stringgenerate-id ( node-set ? ) <det class="fem">La </det>fonction generate-id retourne <det class="fem">une </det>chaîne de caractères qui identifie d' <det class="fem">une </det>manière unique <det class="masc">le </det>noeud dans <det class="masc">l' </det>ensemble de noeuds reçu en argument qui est <det class="masc">le </det>premier selon <det class="masc">l' </det>ordre <det class="masc">du </det>document . </div>
<div class="p">
<det class="masc">L' </det>identificateur unique doit être composé de caractères ASCII alphanumériques et doit commencer par <det class="masc">un </det>caractère alphabétique . </div>
<div class="p">Ainsi , <det class="fem">la </det>chaîne de caractères est syntaxiquement parlant <det class="masc">un </det>nom XML . <det class="fem">Une </det>implémentation est libre de générer <det class="masc">un </det>identificateur de <det class="fem">la </det>façon qui lui est <det class="fem">la </det>plus appropriée de telle manière qu' <det class="masc">un </det>même identificateur est toujours généré pour <det class="masc">le </det>même noeud et différents identificateurs sont toujours générés à partir de noeuds différents . </div>
<div class="p">
<det class="fem">Une </det>implémentation n' est pas obligée de générer <det class="masc">les </det>mêmes identificateurs chaque fois qu' <det class="masc">un </det>document subi <det class="fem">une </det>transformation . </div>
<div class="p">Rien ne garanti identificateur unique généré sera est distinct de n' importe quel IDs unique spécifié dans <det class="masc">le </det>document source . </div>
<div class="p">Si <det class="masc">l' </det>ensemble de noeuds reçu en argument est vide <det class="fem">la </det>fonction retourne <det class="fem">la </det>chaîne de caractères vide . </div>
<div class="p">Si <det class="masc">l' </det>argument est omis , il est remplacé par <det class="masc">le </det>noeud contexte . </div>
<div class="p">Fonction : objectsystem-property ( string ) <det class="masc">L' </det>argument de <det class="fem">cette </det>fonction doit être évalué par <det class="fem">une </det>chaîne de caractères de type QName . </div>
<div class="p">
<det class="masc">Le </det>QName est étendu en <det class="masc">un </det>nom utilisant <det class="fem">la </det>déclaration de <det class="masc">l' </det>espace de noms dans <det class="fem">la </det>portée de <det class="masc">l' </det>expression . </div>
<div class="p">
<det class="fem">La </det>fonction system-property retourne <det class="masc">un </det>objet représentant <det class="fem">la </det>valeur de <det class="fem">la </det>propriété système identifiée par <det class="masc">le </det>nom . </div>
<div class="p">Si <det class="fem">une </det>telle propriété système n' existe pas alors <det class="fem">la </det>chaîne de caractères vide est retournée . </div>
<div class="p">
<det class="fem">Les </det>implémentations doivent fournir <det class="fem">les </det>propriétés système suivantes qui sont toutes dans <det class="masc">l' </det>espace de noms XSLT : xsl : version , il s' agit d' <det class="masc">un </det>nombre qui indique <det class="fem">la </det>version de XSLT supportée par <det class="masc">le </det>processeur ; <det class="fem">Cette </det>valeur est 1.0 pour <det class="masc">les </det>processeurs XSLT implémentant <det class="fem">la </det>version de XSLT spécifiée dans <det class="masc">ce </det>document xsl : vendor , c' est <det class="fem">une </det>chaîne de caractères identifiant le fabriquant <det class="masc">du </det>processeur XSLT xsl : vendor-url , <det class="fem">une </det>chaîne de caractères qui contient <det class="fem">une </det>URL identifiant le fabriquant <det class="masc">du </det>processeur XSLT ; <det class="fem">cette </det>URL est d' <det class="fem">une </det>manière générale , <det class="fem">la </det>page d' accueil ( home page ) <det class="masc">du </det>site Web <det class="masc">du </det>fabriquant . </div>
<div class="p">13 Messages &lt; xsl : message terminate = " yes " " no " &gt; &lt; ! </div>
<div class="p">Content : template </div>
<div class="p">&gt; &lt;/xsl:message&gt; <det class="masc">L' </det>instruction xsl : message permet d' envoyer <det class="masc">un </det>message d' <det class="fem">une </det>manière qui dépend <det class="masc">du </det>processeur XSLT . <det class="masc">Le </det>contenu de <det class="masc">l' </det>instruction xsl : message est <det class="masc">un </det>modèle . </div>
<div class="p">
<det class="masc">L' </det>instruction xsl : message est instanciée par <det class="masc">l' </det>instanciation <det class="masc">du </det>contenu afin de créer <det class="masc">un </det>fragment XML . <det class="masc">Le </det>fragment XML est <det class="masc">le </det>contenu <det class="masc">du </det>message . </div>
<div class="p">NOTE : xsl : message peut être implémenté par <det class="masc">un </det>processeur XSLT de telle sorte qu' il déclenche <det class="fem">une </det>dialogue popup d' alerte , ou en écrivant dans <det class="masc">un </det>fichier log . </div>
<div class="p">Si <det class="fem">la </det>valeur de <det class="masc">l' </det>attribut terminate est yes alors , <det class="masc">le </det>processeur XSLT doit terminer <det class="masc">son </det>traitement après <det class="masc">l' </det>envoi <det class="masc">du </det>message . </div>
<div class="p">
<det class="fem">La </det>valeur par défaut est no . </div>
<div class="p">Pour <det class="fem">la </det>localisation <det class="masc">des </det>messages , <det class="masc">un </det>moyen pratique consiste à stocker <det class="masc">l' </det>information localisée ( texte <det class="masc">des </det>messages , etc . ) dans <det class="masc">un </det>document XML qui devient <det class="masc">un </det>fichier d' entrée additionnel pour <det class="fem">la </det>feuille de style . </div>
<div class="p">Supposons par exemple que <det class="masc">les </det>messages pour <det class="fem">une </det>langue L sont stockés dans <det class="masc">un </det>fichier XML resources / L. xml sous <det class="fem">la </det>forme : <det class="fem">La </det>feuille de style doit alors utiliser <det class="masc">l' </det>approche suivante pour localiser <det class="masc">les </det>messages : 14 Extensions XSLT autorise 2 sortes d' extension , <det class="masc">l' </det>une s' applique <det class="masc">aux </det>éléments , <det class="masc">l' </det>autre <det class="fem">aux </det>fonctions . </div>
<div class="p">
<det class="fem">Cette </det>version de XSLT ne fournit aucun mécanisme de définition <det class="fem">des </det>implémentations d' extension . </div>
<div class="p">Aussi , <det class="fem">une </det>feuille de styles XSLT qui se veut portable entre différentes implémentations de XSLT ne peut -elle pas dépendre d' extensions spécifiques . </div>
<div class="p">XSLT fournit <det class="masc">des </det>mécanismes qui permettent à <det class="fem">une </det>feuille de styles XSLT de déterminer si <det class="masc">le </det>processeur XSLT qui <det class="fem">la </det>traite est capable de traiter <det class="fem">des </det>extensions particulières , et de spécifier ce qui doit arriver quand <det class="fem">les </det>extensions ne sont pas disponibles . </div>
<div class="p">Si <det class="fem">une </det>feuille de styles XSLT est écrite en faisant attention à <det class="masc">l' </det>utilisation de <det class="masc">ces </det>mécanismes , alors il lui est possible de tirer partie <det class="fem">des </det>extensions tout en restant portable sur n' importe quelle implémentation de XSLT . 14.1 Eléments extension <det class="masc">Le </det>mécanisme d' extension d' éléments permet de désigner <det class="masc">des </det>espaces de noms comme étant <det class="masc">des </det>espaces de noms d' extension . </div>
<div class="p">Lorsqu' <det class="masc">un </det>espace de noms est qualifié d' espace de noms d' extension , et qu' <det class="masc">un </det>élément dont <det class="masc">le </det>nom fait partie de <det class="masc">cet </det>espace est utilisé dans <det class="masc">un </det>modèle , alors <det class="masc">cet </det>élément est traité comme <det class="fem">une </det>instruction plutôt que comme <det class="masc">un </det>élément résultat littéral . </div>
<div class="p">
<det class="masc">L' </det>espace de nom détermine alors <det class="fem">la </det>sémantique de <det class="masc">l' </det>instruction . </div>
<div class="p">NOTE : Puisqu' <det class="masc">un </det>élément fils d' <det class="masc">un </det>élément xsl : stylesheet n' apparaît pas dans <det class="masc">le </det>modèle , <det class="masc">les </det>éléments de haut niveau non-XSLT ne sont pas <det class="fem">des </det>extensions d' éléments telles que définies ici , et rien dans <det class="fem">cette </det>section ne s' applique à eux . </div>
<div class="p">On qualifie <det class="masc">un </det>espace de noms d' espace de noms d' extension en utilisant soit <det class="masc">l' </det>attribut extension-element-prefixes de <det class="masc">l' </det>élément xsl : stylesheet soit <det class="masc">l' </det>attribut xsl : extension-element-prefixes sur <det class="masc">un </det>élément résultat littéral ou <det class="masc">un </det>élément extension . </div>
<div class="p">
<det class="fem">La </det>valeur de <det class="masc">ces </det>attributs est <det class="fem">une </det>liste de préfixes d' espaces de noms séparés par <det class="masc">des </det>espaces . </div>
<div class="p">
<det class="masc">L' </det>espace de nom lié à chacun de <det class="masc">ces </det>préfixes se nomme espace de noms d' extension . </div>
<div class="p">
<det class="fem">Une </det>erreur doit être signalée si aucun espace de noms n' est rattaché <det class="masc">au </det>préfixe utilisé par <det class="masc">l' </det>élément porteur de <det class="masc">l' </det>attribut extension-element-prefixes ou xsl : extension-element-prefixes . </div>
<div class="p">
<det class="masc">L' </det>espace de noms par défaut ( tel que déclaré par xmlns ) peut être désigné comme <det class="masc">un </det>espace de noms d' extension , en incluant # default dans <det class="fem">la </det>liste <det class="masc">des </det>préfixes d' espaces de noms . </div>
<div class="p">
<det class="fem">La </det>désignation d' <det class="masc">un </det>espace de noms comme espace de noms d' extension est effective à <det class="masc">l' </det>intérieur <det class="masc">du </det>sous arbre de <det class="fem">la </det>feuille de styles dont <det class="fem">la </det>racine est <det class="masc">l' </det>élément porteur de <det class="masc">l' </det>attribut extension-element-prefixes ou de <det class="masc">l' </det>attribut xsl : extension-element-prefixes . </div>
<div class="p">
<det class="masc">Les </det>sous-arbres qui ont pout racine <det class="masc">l' </det>élément xsl : stylesheet , alors il n' inclue aucune <det class="fem">des </det>feuilles de style importées ou incluses de <det class="masc">cet </det>élément xsl : stylesheet . </div>
<div class="p">Si <det class="masc">le </det>processeur XSLT ne dispose pas d' implémentation pour <det class="masc">un </det>élément extension particulier , alors <det class="fem">la </det>fonction element-available doit retourner <det class="fem">la </det>valeur faux pour <det class="masc">le </det>nom de <det class="masc">l' </det>élément . </div>
<div class="p">Quand <det class="masc">un </det>tel élément extension est instancié , <det class="masc">le </det>processeur XSLT doit exécuter <det class="masc">un </det>retour pour <det class="masc">l' </det>élément tel que spécifié en [ 15 Reprise ] . </div>
<div class="p">
<det class="masc">Un </det>processeur XSLT ne doit pas signaler d' erreur simplement parce qu' <det class="masc">un </det>modèle contient <det class="fem">une </det>extension d' élément pour laquelle il n' y aurait aucune implémentation disponible . </div>
<div class="p">Si <det class="masc">le </det>processeur XSLT dispose d' <det class="fem">une </det>implémentation pour <det class="masc">un </det>élément extension particulier , alors <det class="fem">la </det>fonction element-available doit retourner <det class="fem">la </det>valeur vraie pour <det class="masc">le </det>nom de <det class="masc">l' </det>élément . </div>
<div class="p">14.2 Fonction extension Si , dans <det class="fem">une </det>expression d' appel de fonction ( FunctionCall ) , <det class="masc">un </det>nom de fonction ( FunctionName ) n' est pas conforme à un sans deux points ( NCName ) ( c' est à dire s' il contient <det class="masc">le </det>caractère deux points ) , alors il est traité comme <det class="masc">un </det>appel à <det class="fem">une </det>fonction d' extension . </div>
<div class="p">
<det class="masc">Le </det>nom de <det class="fem">la </det>fonction ( FunctionName ) est étendu en <det class="masc">un </det>nom utilisant <det class="fem">la </det>déclaration d' espace de noms trouvé dans <det class="masc">son </det>contexte d' évaluation . </div>
<div class="p">Si <det class="masc">le </det>processeur XSLT n' a pas d' implémentation particulière pour <det class="masc">un </det>nom d' fonction d' extension , alors <det class="fem">la </det>fonction " fonctions disponibles " ( function-available ) doit retourner <det class="fem">la </det>valeur faux pour <det class="masc">ce </det>nom de fonction . </div>
<div class="p">Si <det class="fem">une </det>telle fonction d' extension survient dans <det class="fem">une </det>expression et si <det class="masc">l' </det>fonction d' extension est en cours d' appel , <det class="masc">le </det>processeur XSLT doit signaler <det class="fem">une </det>erreur . </div>
<div class="p">
<det class="masc">Un </det>processeur XSLT ne doit pas signaler d' erreur simplement parce qu' <det class="fem">une </det>expression contient <det class="fem">une </det>fonction extension inconnue . </div>
<div class="p">Si <det class="masc">le </det>processeur XSLT dispose de <det class="masc">l' </det>implémentation d' <det class="fem">une </det>fonction d' extension particulière , alors <det class="fem">la </det>fonction function-available ( fonction-disponible ) doit retourner <det class="fem">la </det>valeur vrai pour <det class="masc">ce </det>nom de fonction . </div>
<div class="p">Lorsque <det class="fem">cette </det>extension est appelée , alors <det class="masc">le </det>processeur XSLT doit exécuter <det class="masc">l' </det>implémentation correspondante en lui passant <det class="masc">les </det>arguments effectifs . </div>
<div class="p">
<det class="masc">Le </det>résultat retourné par <det class="masc">l' </det>implémentation est renvoyé comme résultat de <det class="masc">l' </det>appel de <det class="fem">la </det>fonction . </div>
<div class="p">15 Reprise alors <det class="fem">la </det>méthode de sortie par défaut est html ; Sinon , <det class="fem">la </det>méthode est xml . </div>
<div class="p">
<det class="fem">La </det>méthode de sortie par défaut doit être utilisée s' il n' y a pas d' élément xsl : output ou si aucun <det class="masc">des </det>éléments xsl : output ne spécifie <det class="fem">une </det>valeur pour <det class="masc">l' </det>attribut method . </div>
<div class="p">
<det class="masc">Les </det>autres attributs de <det class="masc">l' </det>élément xsl : output sont <det class="masc">des </det>paramètres de <det class="fem">la </det>méthode de sortie qui sont : version spécifie <det class="fem">la </det>version de <det class="fem">la </det>méthode de sortie . indent spécifie si <det class="masc">le </det>processeur XSLT est autorisé à rajouter <det class="masc">des </det>espaces blancs additionnels pendant qu' il génère <det class="masc">l' </det>arbre résultat ; <det class="fem">la </det>valeur ne peut être que yesou no . encoding spécifie <det class="masc">le </det>système de codage de caractères préférentiel que <det class="masc">le </det>processeur XSLT doit utiliser pour représenter <det class="fem">des </det>séquences de caractères en tant que séquences d' octets ; <det class="fem">la </det>valeur de <det class="masc">cet </det>attribut doit être traîtée sans tenir compte de <det class="fem">la </det>casse ; <det class="fem">la </det>valeur ne peut contenir que <det class="masc">des </det>caractères compris entre # x21 et # x7E ( c' est à dire <det class="masc">les </det>caractères imprimables de <det class="masc">l' </det>ASCII ) ; <det class="fem">la </det>valeur doit soit être <det class="masc">un </det>jeu de caractères charset enregistré auprès de <det class="masc">l' </det>IANA [ IANA ] , [ RFC2278 ] soit commencer par X - . media-type spécifie <det class="masc">le </det>type de support ( type de contenu MIME ) <det class="fem">des </det>données issues de <det class="masc">l' </det>arbre résultat ; <det class="masc">le </det>paramètre charset ne doit pas être spécifié explicitement ; <det class="masc">au </det>lieu de cela , quand <det class="masc">le </det>type de support de plus haut niveau est text , <det class="masc">un </det>paramètre charset doit être rajouté en conformité avec <det class="masc">le </det>codage <det class="masc">des </det>caractères en vigueur pour <det class="fem">la </det>méthode de sortie . doctype-system spécifie <det class="masc">l' </det>identifiant système qui doit être utilisé dans <det class="fem">la </det>déclaration de type de document . doctype-public spécifie <det class="masc">l' </det>identifiant public qui doit être utilisé dans <det class="fem">la </det>déclaration de type de document . omit-xml-declaration spécifie si <det class="masc">le </det>processeur XSLT doit produire <det class="fem">une </det>déclaration XML ; <det class="fem">la </det>valeur est obligatoirement yes ou no standalone spécifie si <det class="masc">le </det>processeur XSLT doit générer <det class="fem">une </det>déclaration de document autonome ; <det class="fem">la </det>valeur doit être yes ou no cdata-section-elements spécifie <det class="fem">une </det>liste de noms d' éléments dont <det class="masc">les </det>fils de type noeud texte doivent être produit en tant que section CDATA dans <det class="masc">l' </det>arbre résultat . </div>
<div class="p">
<det class="masc">Le </det>sémantique détaillée de chaque attribut sera décrite séparemment pour chaque méthode de sortie à laquelle <det class="masc">l' </det>attribut est applicable . </div>
<div class="p">Si <det class="fem">la </det>sémantique de <det class="masc">l' </det>attribut n' est pas décrite pour <det class="fem">une </det>méthode de sortie , alors cela signifie que <det class="fem">cette </det>méthode ne lui est pas applicable . </div>
<div class="p">
<det class="fem">Une </det>feuille de styles peut contenir plusieurs éléments xsl : output et peut inclure ou importer <det class="fem">des </det>feuilles de style qui contiennent aussi <det class="masc">des </det>éléments xsl : output . </div>
<div class="p">Tous <det class="masc">les </det>éléments xsl : output intervenant dans <det class="fem">une </det>feuille de styles sont fusionnés <det class="masc">au </det>sein d' <det class="masc">un </det>seul élément effectif xsl : output . </div>
<div class="p">
<det class="fem">La </det>valeur effective de <det class="masc">l' </det>attribut cdata-section-elements est <det class="masc">l' </det>union <det class="fem">des </det>valeurs spécifiées . </div>
<div class="p">Pour <det class="masc">les </det>autres attributs , <det class="fem">la </det>valeur effective est <det class="fem">la </det>valeur spécifiée ayant <det class="fem">la </det>plus grande priorité d' importation . </div>
<div class="p">
<det class="fem">La </det>présence de plus d' <det class="fem">une </det>telle valeur pour <det class="masc">un </det>attribut est <det class="fem">une </det>erreur . </div>
<div class="p">
<det class="masc">Un </det>processeur XSLT peut signaler <det class="masc">l' </det>erreur ; s' il ne le fait pas , il doit traiter <det class="masc">l' </det>erreur en utilisant <det class="fem">la </det>valeur qui apparaît en dernier dans <det class="fem">la </det>feuille de styles . </div>
<div class="p">
<det class="fem">Les </det>valeurs <det class="masc">des </det>attributs sont prises par défaut après que <det class="masc">les </det>éléments xsl : output aient été fusionnés ; différentes méthodes de sortie peuvent avoir différentes valeur par défaut pour <det class="masc">un </det>attribut . </div>
<div class="p">16.1 <det class="fem">La </det>méthode de sortie XML <det class="fem">La </det>méthode de sortie xml produit <det class="masc">l' </det>arbre résultat sous <det class="fem">la </det>forme d' <det class="fem">une </det>entité générale XML bien formée et correcte . </div>
<div class="p">Si <det class="masc">le </det>noeud racine de <det class="masc">l' </det>arbre résultat a <det class="masc">un </det>unique fils et aucun autre fils de type texte , alors <det class="masc">l' </det>entité devrait aussi être bien formée . </div>
<div class="p">Si <det class="masc">l' </det>entité est référencée dans <det class="masc">un </det>document XML simple comme dans <det class="masc">l' </det>exemple suivant , dans lequel entity-URI est <det class="masc">l' </det>URI de <det class="masc">l' </det>entité , alors <det class="masc">le </det>document englobant doit être globalement <det class="masc">un </det>document XML bien formé conforme <det class="fem">aux </det>Recommandations <det class="masc">des </det>Espaces de Noms XML [ Noms XML ] . </div>
<div class="p">De plus , le résultatdoit être tel que si <det class="masc">un </det>nouvel arbre était produit à partir <det class="masc">du </det>document englobant pris comme document XML conformément <det class="fem">aux </det>spécifications faites en [ 3 Modèle de données ] , puis en enlevant <det class="masc">l' </det>élément document et en faisant de <det class="masc">ses </det>enfants <det class="masc">des </det>enfants de <det class="masc">l' </det>élément racine , alors <det class="masc">le </det>nouvel arbre serait <det class="masc">le </det>même que <det class="masc">l' </det>arbre résultat , <det class="fem">aux </det>possibles exceptions suivantes près : <det class="masc">L' </det>ordre <det class="masc">des </det>attributs pourrait être différent dans <det class="masc">les </det>deux arbres . </div>
<div class="p">
<det class="masc">Le </det>nouvel arbre pourrait contenir <det class="masc">des </det>noeuds d' espaces de noms qui n' étaient pas présents dans <det class="masc">l' </det>arbre résultat initial . </div>
<div class="p">NOTE : <det class="masc">Un </det>processeur XSLT pourrait avoir besoin de rajouter <det class="fem">des </det>déclarations d' espaces de noms pendant <det class="fem">la </det>génération <det class="masc">au </det>format XML , de <det class="masc">l' </det>arbre résultat . </div>
<div class="p">Si <det class="masc">le </det>processeur XSLT avait généré <det class="fem">une </det>déclaration de type de document à cause de <det class="masc">l' </det>attribut doctype-system , alors <det class="fem">les </det>conditions ci-dessus s' appliquent à <det class="masc">l' </det>entité dans laquelle <det class="fem">la </det>déclaration de type de document générée aura été enlevée . </div>
<div class="p">
<det class="masc">L' </det>attribut version spécifie <det class="fem">la </det>version de XML à considérer pour produire <det class="masc">l' </det>arbre résultat . </div>
<div class="p">Si <det class="masc">le </det>processeur XSLT ne supporte pas <det class="fem">cette </det>version de XML , il doit utiliser <det class="fem">une </det>version de XML qu' il supporte . </div>
<div class="p">
<det class="fem">La </det>version mentionnée dans <det class="fem">la </det>déclaration XML ( si <det class="fem">la </det>déclaration XML est produite ) doit correspondre à <det class="fem">la </det>version de XML que <det class="masc">le </det>processeur aura utilisé pour produire <det class="masc">l' </det>arbre résultat . </div>
<div class="p">
<det class="fem">La </det>valeur de <det class="masc">l' </det>attribut version doit être conforme à <det class="fem">la </det>règle de production VersionNum définie dans <det class="fem">les </det>Recommandations XML ( XML Recommendation [ XML ] ) . </div>
<div class="p">
<det class="fem">La </det>valeur par défaut est 1.0 . </div>
<div class="p">
<det class="masc">L' </det>attribut encoding spécifie <det class="masc">le </det>codage préférentiel à utiliser pour produire <det class="masc">l' </det>arbre résultat . </div>
<div class="p">
<det class="masc">Des </det>processeurs XSLT sont requis pour respecter <det class="fem">les </det>valeurs de UTF-8 et UTF-16 . </div>
<div class="p">Pour <det class="fem">les </det>autres valeurs , si <det class="masc">le </det>processeur XSLT ne supporte pas <det class="masc">le </det>codage spécifié il peut généré <det class="fem">une </det>erreur ; s' il ne signale pas d' erreur il doit utiliser UTF-8 ou UTF-16 à <det class="fem">la </det>place . </div>
<div class="p">
<det class="masc">Le </det>processeur XSLT ne doit pas utiliser d' encodage dont <det class="masc">le </det>nom n' est pas conforme à <det class="fem">la </det>règle de production <det class="masc">des </det>noms d' encodage ( EncName ) de <det class="fem">la </det>Recommandation XML ( XML Recommendation [ XML ] ) . </div>
<div class="p">Si aucun attribut encoding n' est spécifié , alors <det class="masc">le </det>processeur XSLT doit utiliser soit UTF-8 soit UTF-16 . l est possible que <det class="masc">l' </det>arbre résultat contienne <det class="masc">un </det>caractère qui ne puisse pas être représenté dans <det class="masc">le </det>système d' encodage que <det class="masc">le </det>processeur XSLT utilise . </div>
<div class="p">Dans <det class="masc">ce </det>cas , si <det class="masc">le </det>caractère apparaît dans <det class="masc">un </det>contexte où XML reconnaît <det class="fem">les </det>références de caractères ( c' est à dire dans <det class="fem">la </det>valeur d' <det class="masc">un </det>noeud d' attribut ou d' <det class="masc">un </det>noeud textuel ) , alors <det class="masc">le </det>caractère produit devra l' être sous <det class="fem">la </det>forme d' <det class="fem">une </det>référence de caractère ; sinon ( par exemple , si <det class="masc">le </det>caractère se produit dans <det class="masc">le </det>nom d' <det class="masc">un </det>élément ) <det class="masc">le </det>processeur XSLT doit signaler <det class="fem">une </det>erreur . </div>
<div class="p">Si <det class="fem">la </det>valeur de <det class="masc">l' </det>attribut indent est Yes , alors <det class="fem">la </det>méthode de sortie xml peut produire <det class="masc">des </det>espaces blancs en plus de ceux de <det class="masc">l' </det>arbre résultat ( peut-être basé sur <det class="masc">les </det>espaces blancs épurés soit <det class="masc">du </det>document source soit de <det class="fem">la </det>feuille de styles ) dans <det class="masc">le </det>but d' indenter <det class="masc">le </det>résultat proprement ; si <det class="masc">l' </det>attribut indent a <det class="fem">la </det>valeur no , il ne doit produire aucun espace blanc additionnel . </div>
<div class="p">
<det class="fem">La </det>valeur par défaut est no . </div>
<div class="p">
<det class="fem">La </det>méthode de sortie xml doit utiliser <det class="masc">un </det>algorithme pour rajouter <det class="masc">les </det>espaces blancs additionnels qui garantisse que <det class="masc">le </det>résultat , si <det class="masc">les </det>espaces blancs venaient à être supprimé de <det class="fem">la </det>sortie en utilisant <det class="masc">le </det>processus décrit en [ 3.4 Suppression <det class="masc">des </det>espaces blancs ] et en réduisant <det class="masc">l' </det>ensemble <det class="masc">des </det>éléments conservant <det class="masc">les </det>espaces blancs <det class="masc">au </det>seul cas xsl : text , serait <det class="masc">le </det>même , que <det class="masc">les </det>espaces blancs additionnels soit mis dans <det class="fem">la </det>sortie ou qu' ils ne le soient pas . </div>
<div class="p">NOTE : Il n' est normalement pas fiable d' utiliser indent="yes " avec <det class="masc">des </det>types de documents qui contiennent <det class="masc">des </det>types d' éléments à contenu mixte . </div>
<div class="p">
<det class="masc">L' </det>attribut cdata-section-elements contient <det class="fem">une </det>liste de noms qualifiés séparés par <det class="masc">des </det>espaces blancs . </div>
<div class="p">Chaque nom qualifié est expansé pour former <det class="masc">un </det>nom expansé en utilisant <det class="fem">les </det>déclarations d' espaces de noms en vigueur sur <det class="masc">l' </det>élément xsl : output dans lequel <det class="masc">le </det>nom qualifié apparaît ; s' il existe <det class="masc">un </det>espace de noms par défaut , il sera utilisé pour <det class="masc">les </det>noms qualifiés qui n' ont pas de préfixe . </div>
<div class="p">
<det class="masc">L' </det>expansion est réalisée avant que <det class="fem">la </det>fusion <det class="masc">des </det>éléments multiples xsl : output en <det class="masc">un </det>seul élément xsl : output ait lieu . </div>
<div class="p">Si <det class="masc">le </det>nom expansé d' <det class="masc">un </det>parent d' <det class="masc">un </det>noeud textuel est <det class="masc">un </det>membre de <det class="fem">la </det>liste , alors <det class="masc">le </det>noeud textuel doit être sorti en tant que paragraphe de type CDATA . Par exemple , <det class="masc">Un </det>processeur XSLT doit signaler toute erreur à <det class="masc">l' </det>exception de celles qui dans <det class="masc">ce </det>document , sont explicitement autorisées à ne pas être signalées . <det class="masc">un </det>processeur XSLT n' est pas obligé de récupérer toutes <det class="fem">les </det>erreurs bien que cela puisse se réveler nécessaire . </div>
<div class="p">
<det class="masc">Un </det>processeur XSLT conforme peut imposer <det class="fem">des </det>limites sur <det class="fem">les </det>ressources de traitement consommées par <det class="masc">le </det>traitement d' <det class="fem">une </det>feuille de styles . </div>
<div class="p">18 Notation <det class="fem">La </det>spécification de chaque type d' élément défini pour XSLT est précédée par <det class="masc">un </det>résumé de <det class="fem">sa </det>syntaxe sous <det class="fem">la </det>forme d' <det class="masc">un </det>modèle pour <det class="masc">les </det>éléments de <det class="masc">ce </det>type d' élément . </div>
<div class="p">
<det class="fem">La </det>signification de <det class="fem">la </det>notation syntaxique résumée est comme suit : <det class="masc">Un </det>attribut est requis si et seulement si <det class="masc">son </det>nom est en gras . </div>
<div class="p">
<det class="fem">La </det>chaîne de caractères écrite à <det class="fem">la </det>place de <det class="fem">la </det>valeur d' attribut spécifie <det class="fem">les </det>valeurs d' attributs autorisées pour <det class="masc">l' </det>attribut . </div>
<div class="p">Si <det class="fem">cette </det>chaîne est encadrée par <det class="fem">des </det>accolades , elle représente alors <det class="fem">une </det>forme architecturale de <det class="fem">la </det>valeur d' attribut , et <det class="fem">les </det>valeurs d' attributs autorisées sont celles obtenues lors de <det class="masc">l' </det>instanciation de <det class="fem">cette </det>forme architecturale . </div>
<div class="p">
<det class="masc">Le </det>connecteur représente <det class="masc">le </det>ou , <det class="fem">les </det>valeurs listées séparées par <det class="masc">ce </det>connecteur sont mutuellement exclusive . </div>
<div class="p">
<det class="fem">Une </det>chaîne entre cotes signifie que <det class="fem">la </det>valeur de <det class="masc">l' </det>attribut doit être égale à <det class="fem">cette </det>chaîne spécifique . </div>
<div class="p">
<det class="masc">Un </det>nom sans cote , en italique est <det class="fem">une </det>spécification d' <det class="masc">un </det>type particulier de valeur d' attribut . </div>
<div class="p">Si <det class="masc">l' </det>élément ne doit pas avoir <det class="masc">un </det>contenu vide , alors il contient <det class="masc">un </det>commentaire spécifiant <det class="masc">le </det>contenu autorisé . </div>
<div class="p">
<det class="masc">Le </det>contenu autorisé est spécifié de <det class="fem">la </det>même manière pour <det class="fem">une </det>déclaration de type d' élément en XML ; template signifie que n' importe quel combinaison de noeuds textuels , éléments résultat littéraux , éléments d' extension , et <det class="masc">des </det>éléments XSLT de <det class="fem">la </det>catégorie instruction est autorisée ; top-level-element signifie que toute combinaison d' éléments XSLT de <det class="fem">la </det>catégorie top-level-element est autorisée . </div>
<div class="p">
<det class="masc">L' </det>élément est préfacé par <det class="masc">des </det>commentaires indiquant s' il appartient à <det class="fem">la </det>catégorie instruction ou top-level-element ou <det class="masc">aux </det>deux . </div>
<div class="p">
<det class="fem">La </det>catégorie d' <det class="masc">un </det>élément ne fait que signaler s' il est autorisé dans <det class="masc">les </det>contenus dont <det class="masc">les </det>modèles de contenus sont <det class="masc">du </det>type modèle ou éléments de hauts niveaux . </div>
<div class="p">Annexes C Fragment de <det class="fem">la </det>DTD <det class="fem">des </det>feuilles de style XSLT ( Non-Normatif ) NOTE : <det class="masc">Ce </det>fragment de DTD n' est pas normatif parce que <det class="masc">les </det>DTDs de XML 1.0 ne supportent pas <det class="masc">les </det>espaces de noms XML et donc ne peuvent pas décrire correctement <det class="fem">la </det>structure autorisée d' <det class="fem">une </det>feuille de styles XSLT . <det class="masc">L' </det>entité suivante peut être autorisée pour construire <det class="fem">une </det>DTD pour <det class="fem">des </det>feuilles de style XSLT qui crée <det class="fem">des </det>instances d' <det class="fem">une </det>DTD résultat particulière . </div>
<div class="p">Avant de référencer <det class="masc">l' </det>entité , <det class="fem">la </det>DTD de <det class="fem">la </det>feuille de styles doit définir <det class="fem">une </det>entité paramètre result-elements qui liste <det class="masc">les </det>types d' éléments résultat autorisés . </div>
<div class="p">Par exemple : F Changements depuis <det class="fem">la </det>recommandation proposée ( Non-Normatif ) <det class="masc">Les </det>points suivants sont <det class="masc">les </det>changements faits depuis <det class="fem">la </det>recommandation proposée : <det class="masc">L' </det>attribut xsl : version est requis sur <det class="masc">un </det>élément résultat littéral utilisé comme feuille de style ( voir [ 2.3 Feuille de style sous <det class="fem">la </det>forme d' <det class="masc">un </det>élément littéral résultat ] ) . </div>
<div class="p">
<det class="masc">L' </det>attribut data-type de <det class="masc">l' </det>élément xsl : sort peut utiliser <det class="masc">un </det>nom préfixé pour spécifier <det class="masc">un </det>type de données non spécifié par XSLT ( voir [ 10 Ordonnancement ] ) . </div>
<div class="p">G Fonctionalités à <det class="masc">l' </det>étude pour <det class="fem">une </det>future version de XSLT ( Non-Normatif ) <det class="fem">Les </det>fonctionalités suivantes sont en cours d' évaluation pour <det class="fem">les </det>versions de XSLT <det class="masc">au </det>delà de <det class="fem">la </det>verison 1.0 : <det class="fem">une </det>expression conditionnelle ; <det class="masc">le </det>support <det class="masc">des </det>types de données et <det class="masc">des </det>archétypes <det class="masc">des </det>schémas XML ; <det class="masc">le </det>support de quelquechose équivalent <det class="fem">aux </det>règles qui étaient présentes dans <det class="fem">la </det>première version soumise de XSL ; <det class="masc">un </det>attribut pour contrôler <det class="masc">l' </det>espace de noms par défaut pour <det class="masc">les </det>noms apparaîssants dans <det class="masc">les </det>attributs XSLT ; <det class="masc">le </det>support <det class="fem">des </det>références d' entités ; <det class="masc">le </det>support <det class="masc">des </det>DTD dans <det class="masc">le </det>modèle de données ; <det class="masc">le </det>support <det class="fem">des </det>notations dans <det class="masc">le </det>modèle de données ; <det class="masc">un </det>moyen pour obtenir d' <det class="masc">un </det>élément <det class="fem">la </det>liste <det class="masc">des </det>éléments qui le référencent ( par exemple par <det class="masc">un </det>attribut IDREF ) ; <det class="masc">un </det>moyen plus facile pour obtenir <det class="masc">un </det>ID ou <det class="fem">une </det>clé d' <det class="masc">un </det>autre document ; <det class="masc">le </det>support <det class="fem">des </det>expressions régulières pour établir <det class="fem">des </det>correspondances avec tout ou partie <det class="masc">des </det>noeuds textuels , valeurs d' attributs , noms d' attributs et <det class="masc">les </det>noms <det class="masc">des </det>types d' éléments ; <det class="fem">les </det>comparaisons indépendantes de <det class="fem">la </det>casse ; <det class="fem">la </det>normalisation <det class="fem">des </det>chaînes de caractères avant <det class="fem">leur </det>comparaison , par exemple pour <det class="fem">la </det>compatibilité <det class="masc">des </det>caractères ; <det class="fem">une </det>fonction string resolve ( node-set ) dont <det class="masc">l' </det>argument sera <det class="fem">une </det>URI relative que <det class="fem">la </det>fonction trasformera en URI absolue en s' appuyant sur <det class="masc">l' </det>URI de base <det class="masc">du </det>noeud ; <det class="masc">les </det>documents résultat multiples ; <det class="masc">l' </det>utilisation <det class="masc">du </det>noeud courant comme valeur par défaut de <det class="masc">l' </det>attribut select de <det class="masc">l' </det>élément xsl : value-of ; <det class="masc">un </det>attribut sur <det class="masc">l' </det>élément xsl : attributepour contrôler comment <det class="fem">la </det>valeur d' attribut est normalisée ; <det class="fem">des </det>attributs additionels sur <det class="masc">l' </det>élément xsl : sort pour fournir plus de contrôles sur <det class="masc">les </det>tris , comme par exemple <det class="fem">les </det>scripts d' ordonnancements relatifs ; <det class="masc">un </det>moyen de mettre <det class="masc">un </det>texte identifié par <det class="fem">une </det>URI dans <det class="masc">l' </det>arbre résultat ; autoriser <det class="fem">les </det>unions dans <det class="fem">les </det>étapes de localisation ( par exemple foo/(bar baz ) ) ; autoriser sur <det class="masc">les </det>fragments de <det class="masc">l' </det>arbre résultat toutes <det class="fem">les </det>opérations qui sont autorisées sur <det class="masc">les </det>ensembles de noeuds ; <det class="masc">un </det>moyen pour regrouper ensemble <det class="masc">les </det>noeuds consécutifs ayant <det class="masc">des </det>sous-éléments ou <det class="masc">des </det>attributs dupliqués ; <det class="fem">des </det>fonctions pour manipuler <det class="masc">l' </det>attribut style de HTML plus facilement . </div>
</body>
</html>
