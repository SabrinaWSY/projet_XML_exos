<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta charset="UTF-8">
<title>Exercice 8 : Exploration d’une recommandation W3C taggée</title>
</head>
<body>
<div class="header">Mise en forme par Lara DUNUAN et
                    Siyu WANG 
                    , M1 TAL.</div>
<h1>Recommandation XSLT 1.0</h1>
<div class="p">Ce document est une traduction de la recommandation XSL Transformations ( XSLT ) 1.0 du W3C , datée du 16 novembre 1999 . </div>
<div class="p">Cette version traduite peut contenir des erreurs absentes de l' original , dues à la traduction elle -même . </div>
<div class="p">La version originale en anglais , seule normative , se trouve à l' adresse http : / / www . w3 . org / TR / 1999 / REC-xslt-19991116 . </div>
<div class="p">Traduction : Ramzi Guetari Jean-Jacques Thomasson Yves Bazin Traduction hébergée par XMLfr . </div>
<div class="p">Copyright © 1998 W3C ( MIT , INRIA , Keio ) , tous droits réservés . </div>
<div class="p">Les règles du W3C sur la responsabilité , les marques de commerce , les droits d' auteur et les licences de logiciels sont applicables . </div>
<div class="p">Note de traduction : L' entité ISO LATIN I de " oe " ligaturé n' étant pas supportée par certains navigateurs , il sera écrit oe . Transformations XSL ( XSLT ) Version 1.0 Recommandation W3C 16 Novembre 1999 Cette version a été traduite à partir de la version : http : / / www . w3 . org / TR / 1999 / REC-xslt-19991116 ( existe en XML ou HTML ) Dernière version : http : / / www . w3 . org / TR / xslt Versions précédentes : http : / / www . w3 . org / TR / 1999 / PR-xslt-19991008 http : / / www . w3 . org / 1999 / 08 / WD-xslt-19990813 http : / / www . w3 . org / 1999 / 07 / WD-xslt-19990709 http : / / www . w3 . org / TR / 1999 / WD-xslt-19990421 http : / / www . w3 . org / TR / 1998 / WD-xsl-19981216 http : / / www . w3 . org / TR / 1998 / WD-xsl-19980818 Éditeur du document original : James Clark &lt;jjc@jclark.com&gt; Copyright © 1998 W3C ( MIT , INRIA , Keio ) , tous droits réservés . </div>
<div class="p">Les règles du W3C sur la responsabilité , les marques de commerce , les droits d' auteur et les licences de logiciels sont applicables . </div>
<div class="p">Sommaire Cette spécification définit la syntaxe et la sémantique de XSLT , qui est un langage permettant de transformer des documents XML en d' autres documents XML . XSLT est conçu pour être utilisé comme une partie de XSL , le langage des feuilles de style de XML . En plus de XSLT , XSL inclus un vocabulaire XML pour la spécification de formatage . </div>
<div class="p">XSL spécifie les règles de présentation d' un document XML en utilisant XSLT pour décrire comment le document peut être transformé en un autre document qui utilise le vocabulaire de formatage . </div>
<div class="p">XSLT est aussi conçu pour être utilisé indépendamment de XSL . Cependant , XSLT n' est pas censé être utilisé comme un langage de transformation XML à vocation générale . </div>
<div class="p">Il a surtout été conçu pour les types de transformations nécessaires lorsque XSLT est utilisé comme une partie de XSL . État de ce document La version originale de ce document a été examinée par les Membres du W3C ainsi que d' autres parties concernées , elle a été approuvée par le directeur comme étant une Recommandation du W3C . C' est un document stable pouvant être utilisé comme document de référence ou cité comme une référence normative par d' autres documents . </div>
<div class="p">Le rôle du W3C en mettant à disposition cette Recommandation est de promouvoir son déploiement le plus large possible . </div>
<div class="p">Ceci dans le but d' améliorer et d' accroître la fonctionnalité et l' interopérabilité du Web . </div>
<div class="p">La liste des erreurs répertoriées dans cette spécification est disponible à : http : / / www . w3 . org / 1999 / 11 / REC-xslt-19991116-errata . </div>
<div class="p">Les commentaires sur cette spécification peuvent être adressés à xsl-editors@w3 . org ; les archives des commentaires sont disponibles . </div>
<div class="p">Les discussions publiques sur XSL , y compris les Transformations XSL , se tiennent sur la mailing liste XSL-List . </div>
<div class="p">La version anglaise de cette spécification est la seule version normative ( http : / / www . w3 . org / TR / 1999 / REC-xslt-19991116 ) . </div>
<div class="p">Cependant , pour les traductions de ce document , consulter http : / / www . w3 . org / Style / XSL / translations . html . </div>
<div class="p">Une liste des Recommandations courantes du W3C ainsi que d' autres documents techniques peut être trouvée à : http : / / www . w3 . org / TR . Cette spécification a été produite comme une partie de l' activité Style du W3C . Table des matières 1 Introduction 2 Structure des feuilles de style 2.1 Espace de noms XSLT 2.2 Éléments de feuilles de styles 2.3 Feuille de style sous forme d' élément littéral résultat 2.4 Noms qualifiés 2.5 Traitement de la compatibilité ascendante 2.6 Combinaison de feuilles de style 2.6.1 Inclusion de feuilles de style 2.6.2 Import de feuilles de style 2.7 Feuilles de style encapsulées 3 Modèle de données 3.1 Les fils du noeud racine 3.2 URI base 3.3 Entités non valides 3.4 Suppression de caractères espace 4 Expressions 5 Règles modèle 5.1 Modèle de traitement 5.2 Modèles 5.3 Définition de règles modèle 5.4 Application des règles modèle 5.5 Résolution de conflits des règles modèle 5.6 Outrepasser des règles modèles 5.7 Modes 5.8 Règles modèle encastrées 6 Modèles nommés 7 Créer l' arbre résultat 7.1 Créer des éléments et des attributs 7.1.1 Éléments résultats littéraux 7.1.2 Créer des éléments avec xsl : element 7.1.3 Créer des attributs avec xsl : attribute 7.1.4 Ensembles d' attributs nommés 7.2 Créer de texte 7.3 Créer des instructions de traitement 7.4 Créer des commentaires 7.5 Copier 7.6 Calculer le texte généré 7.6.1 Générer du texte avec xsl : value-of 7.6.2 Les modèles de valeurs d' attributs 7.7 Calculer 7.7.1 Attributs de conversion de nombres en chaînes de caractères 8 Répétition 9 Traitement conditionnel 9.1 Traitement conditionnel par xsl : if 9.2 Traitement conditionnel par xsl : choose 10 tri 11 Variables et Paramètres 11.1 Fragments d' arbre résultat 11.2 Valeurs des Variables et des Paramètres 11.3 Utilisation des valeurs des Variables et des Paramètres avec xsl : copy-of 11.4 Variables et paramètres de haut niveau 11.5 Les Variables et les Paramètres dans les modèles 11.6 Passage de paramètres aux modèles 12 Fonctions additionnelles 12.1 Documents avec sources multiples 12.2 Clés 12.3 Formatage de nombres 12.4 Fonctions additionnelles diverses 13 Messages 14 Extensions 14.1 Eléments extension 14.2 Fonctions extension 15 Reprise 16 Sorties 16.1 La méthode de sortie XML 16.2 La méthode de sortie HTML 16.3 La méthode de sortie texte 16.4 Désactivation de la production littérale des caractères en sortie 17 Conformité 18 Notation Annexes A Références A.1 Références normatives A.2 Autres références B Récapitulatif de la syntaxe des éléments C Fragment de la DTD des feuilles de style XSLT ( non normatif ) D Exemples ( non normatifs ) D.1 Exemple de document D.2 Exemple avec des données E Avertissements ( non normatif ) F Changement depuis la recommandation proposée ( non normatif ) G Fonctionnalités à l' étude pour une future version de XSLT ( non normatif ) 1 Introduction Cette spécification définit la syntaxe et la sémantique du langage XSLT . Une transformation dans XSLT est exprimée comme un document XML bien formé [ XML ] conformément aux espaces de noms définis dans la recommandation XML [ Noms XML ] , pouvant aussi bien contenir des éléments définis par XSLT que d' autres éléments non définis par XSLT . Les éléments définis par XSLT se distinguent par leur appartenance à un espace de nom XML spécifique ( voir [ 2.1 Espace de noms XSLT ] ) , qui est référencé dans cette spécification par Espace de noms . </div>
<div class="p">Ainsi cette spécification est une définition de la syntaxe et de la sémantique de l' Espace de noms XSLT . Une transformation exprimée en XSLT décrit les règles pour transformer un arbre source en un arbre résultat . </div>
<div class="p">La transformation est obtenue en associant des motifs à des modèles . </div>
<div class="p">Les motifs sont appliqués aux éléments de l' arbre source . </div>
<div class="p">Le modèle est instancié pour créer une partie de l' arbre résultat . </div>
<div class="p">L' arbre résultat est distinct de l' arbre source . </div>
<div class="p">La structure de l' arbre résultat peut être complètement différente de la structure de l' arbre source . </div>
<div class="p">Pendant la construction de l' arbre résultat , des éléments de l' arbre source peuvent être filtrés et réordonnés , et des structures arbitraires peuvent être ajoutées . </div>
<div class="p">Une transformation exprimée en XSLT est appelée feuille de styles . </div>
<div class="p">Ceci parce que quand XSLT est transformé dans le vocabulaire de formatage XSL , la transformation fonctionne comme une feuille de styles . </div>
<div class="p">Ce document ne spécifie pas comment une feuille de styles XSLT est associée à un document XML . Il est recommandé que les processeurs XSL supportent le mécanisme décrit dans [ Feuilles de style XML ] . </div>
<div class="p">Lorsque ce mécanisme ou n' importe quel autre mécanisme rencontre une séquence de plus d' une seule feuille de styles XSLT qu' il faut appliquer simultanément à un document XML , alors le résultat doit être le même que si l' on appliquait une seule feuille de styles qui importerait chaque membre de la séquence dans l' ordre ( voir [ 2.6.2 Import des feuilles de style ] ) . </div>
<div class="p">Une feuille de styles contient un ensemble de règles modèles . </div>
<div class="p">Une règle modèle est constituée de deux parties : un motif qui sert à identifier des noeuds de l' arbre source et un modèle pouvant être instancié afin de constituer une partie de l' arbre résultat . </div>
<div class="p">Ceci permet à une feuille de styles d' être applicable à une large catégorie de documents ayant des structures d' arbres source similaires . </div>
<div class="p">Un modèle est instancié pour un élément source particulier afin de créer une partie de l' arbre résultat . </div>
<div class="p">Un modèle peut contenir des éléments permettant de spécifier littéralement les éléments de la structure résultante . </div>
<div class="p">Un modèle peut aussi contenir des éléments de l' espace de noms XSLT représentant des instructions pour la création de fragments de l' arbre résultat . </div>
<div class="p">Lorsqu' un modèle est instancié , chaque instruction est exécutée et remplacée par le fragment d' arbre résultat qu' elle aura crée . </div>
<div class="p">Les instructions peuvent sélectionner et traiter les descendants des éléments source . </div>
<div class="p">La création d' un fragment de l' arbre résultat par le traitement des éléments descendants se fait en trouvant la règle modèle applicable et en instanciant son modèle . </div>
<div class="p">Il faut noter que les éléments ne sont traités que lorsqu' ils sont sélectionnés par l' exécution d' une instruction . </div>
<div class="p">L' arbre résultat est construit en prenant la règle modèle du noeud racine et en instanciant son modèle . </div>
<div class="p">Lors de la recherche d' une règle modèle applicable , plusieurs autre règles modèle peuvent avoir un motif correspondant à un élément donné . </div>
<div class="p">Cependant , une seule et unique règle modèle sera appliquée . </div>
<div class="p">La méthode permettant de déterminer quelle est la règle modèle à appliquer est décrite dans [ 5.5 Résolution de conflits des règles modèle ] . </div>
<div class="p">Un modèle possède à lui tout seul une puissance considérable : il peut créer des structures de n' importe quel niveau de complexité ; il peut accéder et récupérer les valeurs de chaînes de caractères situées à n' importe quel endroit de l' arbre source ; il peut générer des structures répétées au fur et à mesure que les occurrences d' éléments sont rencontrées dans l' arbre source . </div>
<div class="p">Pour les transformations simples où la structure de l' arbre résultat est indépendante de la structure de l' arbre source , une feuille de styles peut souvent être réduite à un seul modèle , valable pour la génération de la totalité de l' arbre résultat . </div>
<div class="p">Les transformations appliquées à des documents XML représentant des données sont souvent de ce type ( voir [ D.2 Exemple de données ] ) . </div>
<div class="p">XSLT offre la possibilité d' utiliser une syntaxe simplifiée pour ce type de feuilles de style ( voir [ 2.3 Feuille de style sous forme d' élément littéral résultat ] ) . </div>
<div class="p">L' instanciation d' un modèle se fait toujours par rapport à un noeud courant et une liste de noeuds courante . </div>
<div class="p">Le noeud courant est toujours membre de la liste de noeuds courante . </div>
<div class="p">Plusieurs opérations dans XSLT sont relatives au noeud courant . </div>
<div class="p">Seules quelques instructions permettent de changer la liste de noeuds courante ou le noeud courant ( voir [ 5 Règles modèle ] et [ 8 Répétition ] ) ; Durant l' instanciation de l' une de ces instructions , la liste de noeuds courante est modifiée et forme une nouvelle liste de noeuds courante dont les éléments deviennent , chacun à leur tour , le noeud courant . </div>
<div class="p">A la fin de ce processus , le noeud courant et la liste de noeuds courante redeviennent ce qu' ils étaient avant instanciation de l' instruction . </div>
<div class="p">XSLT utilise le langage d' expression défini par [ XPath ] pour sélectionner les éléments à traiter , les traitements conditionnels et la génération de texte . </div>
<div class="p">XSLT fournit deux ouvertures pour étendre le langage , l' une pour étendre le jeu d' instructions d' utilisables dans les modèles et une autre pour étendre l' ensemble des fonctions utilisables dans les expressions XPath . </div>
<div class="p">Ces ouvertures reposent toutes les deux sur l' utilisation des espaces des noms XML . Cette version de XSLT ne définit pas le mécanisme d' implémentation de ces ouvertures . </div>
<div class="p">Voir [ 14 Extensions ] . </div>
<div class="p">NOTE : Le groupe de travail XSL prévoit de définir ce mécanisme soit dans une future version de cette spécification soit dans une spécification séparée . </div>
<div class="p">La signification des règles d' écriture des éléments spécifiques à la syntaxe XSLT est fournie au chapitre [ 18 Notation ] . </div>
<div class="p">Les types MIME text / xml et application / xml [ RFC2376 ] devraient être utilisés pour les feuilles de style XSLT . Il est possible qu' un type de média soit spécifiquement associé à une feuille de style XSLT ; dans ce cas , ce type de média est également autorisé . </div>
<div class="p">2 Structure des feuilles de style 2.1 Espace de noms XSLT L' URI de l' espace de noms XSLT est : http : / / www . w3 . org / 1999 / XSL / Transform . </div>
<div class="p">NOTE : La valeur 1999 se trouvant dans l' URI indique l' année d' attribution de l' URI par le W3C . Cela n' indique pas la version de XSLT utilisée ; cette dernière étant spécifiée par des attributs ( voir [ 2.2 L' élément de feuille de styles ] et [ 2.3 Feuille de style sous la forme d' élément littéral résultat ] ) . </div>
<div class="p">Les processeurs XSLT doivent utiliser le mécanisme des espaces de noms [ Noms XML ] pour reconnaître les éléments et les attributs de cet espace de noms . </div>
<div class="p">Les éléments de l' espace de noms XSLT sont reconnus uniquement dans la feuille de styles et non dans le document source . </div>
<div class="p">La liste complète des éléments XSLT prédéfinis est spécifiée dans [ B Récapitulatif des éléments de syntaxe ] . </div>
<div class="p">Les constructeurs informatique ne doivent pas étendre l' espace de noms XSLT avec des éléments ou des attributs nouveaux . </div>
<div class="p">Toute extension doit se présenter sous la forme d' un nouvel espace de noms séparé . </div>
<div class="p">Chaque espace de noms utilisé pour des instructions additionnelles doit être identifié au moyen du mécanisme d' extension d' élément spécifié dans [ 14.1 Éléments extension ] . </div>
<div class="p">Cette spécification utilise le préfixe xsl : pour référencer les éléments de l' espace de noms XSLT . Cependant , les feuilles de style XSLT sont libres d' utiliser n' importe quel préfixe , à condition qu' il y ait une déclaration d' espace de noms liant le préfixe à l' URI de l' espace de noms XSLT . Un élément appartenant à l' espace de noms XSLT peut avoir n' importe quel attribut n' appartenant pas à l' espace de noms XSLT , à condition que le nom étendu de l' attribut ne soit pas une URI d' espace de noms nulle . </div>
<div class="p">La présence de tels attributs ne doit pas modifier le comportement des éléments XSLT et des fonctions définies dans ce document . </div>
<div class="p">Ainsi , un processeur XSLT est toujours libre d' ignorer de pareils attributs , et , ce faisant , n' a pas à signaler d' erreur quand il ne reconnaît pas l' URI de l' espace des noms . </div>
<div class="p">De tels attributs peuvent fournir , par exemple , des identificateurs uniques , des indications d' optimisation ou de la documentation . </div>
<div class="p">Une erreur doit être produite quand des éléments de l' espace de noms XSLT ont des attributs dont les noms étendus ont des URI nulles ( par exemple : des attributs sans noms préfixés ) , exception faite des noms d' attributs définis dans la présente spécification . </div>
<div class="p">NOTE : Les conventions utilisées pour les noms des éléments XSLT , les attributs et les fonctions font que tous les noms tous écrits en lettres minuscules , utilisent le trait d' union pour séparer les mots et n' utilisent les abréviations que si elles existent déjà dans la syntaxe du langage en question , comme par exemple XML ou HTML . 2.2 L' élément feuille de styles Un élément fils de l' élément xsl : stylesheet est appelé élément de haut niveau . </div>
<div class="p">L' exemple suivant montre la structure d' une feuille de styles . </div>
<div class="p">Les points de suspension ( ... ) indiquent où les valeurs et les contenus d' attributs ont été omis . </div>
<div class="p">Bien que cet exemple montre un cas d' utilisation de chacun des éléments autorisés , les feuilles de style peuvent en contenir de zéro à plusieurs occurrences . </div>
<div class="p">L' ordre avec lequel les fils de l' élément xsl : stylesheet apparaissent n' est significatif que pour les éléments xsl : import et les récupérations d' erreurs . </div>
<div class="p">Les utilisateurs ont la liberté d' ordonner les éléments selon leurs préférences et les outils de création de feuilles de styles n' ont pas besoins de contrôler l' ordre dans lequel apparaissent les éléments . </div>
<div class="p">De plus , l' élément xsl : stylesheet peut contenir n' importe quel élément n' appartenant pas à l' espace de noms XSLT , à la condition que l' URI de l' espace de noms du nom étendu de l' élément soit non nulle . </div>
<div class="p">La présence de tels éléments de haut niveau ne doit changer le comportement ni des éléments ni des fonctions XSLT définis dans ce document ; ainsi , il ne doit pas être permis de permettre la modification des règles d' un élément de haut niveau comme xsl : apply-templates pour résoudre , par exemple , des conflits . </div>
<div class="p">Ainsi , un processeur XSLT est toujours libre d' ignorer ces éléments de haut niveau , et il doit ignorer un élément de haut niveau sans générer d' erreur s' il ne reconnaît pas l' URI de l' espace de noms . </div>
<div class="p">De tels éléments peuvent , par exemple , fournir : les informations utilisées par les extensions d' éléments ou l' extension de fonctions ( voir [ 14 Extensions ] ) , les informations concernant l' utilisation de l' arbre résultat , les informations concernant l' obtention de l' arbre source , les meta-données de la feuille de styles , une documentation structurée de la feuille de styles . </div>
<div class="p">2.3 Feuille de style sous la forme d' un élément littéral résultat Une syntaxe simplifiée existe pour les feuilles de style et consiste en un simple et unique modèle appliqué au noeud racine . </div>
<div class="p">La feuille de styles peut consister en un simple élément littéral résultat ( voir [ 7.1.1 Les éléments littéraux résultats ] ) . </div>
<div class="p">Une telle feuille de styles est équivalente à une feuille de styles qui utiliserait un élément xsl : stylesheet contenant une règle modèle qui contiendrait , elle -même , un élément littéral résultat ; la règle modèle ayant comme motif de recherche le caractère / . </div>
<div class="p">Par exemple : Par conséquent , la syntaxe simplifiée ne devrait pas être utilisée pour les feuilles de style XSLT pouvant être utilisées dans pareils cas . </div>
<div class="p">Cette situation peut se produire , par exemple , lorsqu' une feuille de styles XSLT est transmise par messagerie avec un type MIME associé tel que text / xml ou application / xml à un receveur qui utilisera le type MIME pour déterminer comment traiter le message . </div>
<div class="p">2.4 Noms qualifiés Le nom d' un objet XSLT interne , en particulier les modèles nommés ( voir [ 6 Modèles nommés ] ) , un mode ( voir [ 5.7 Modes ] ) , un ensemble d' attributs ( voir [ 7.1.4 Ensembles d' attributs nommés ] ) , une clef ( voir [ 12.2 Clés ] ) , un format décimal ( voir [ 12.3 Formatage de nombres ] ) , une variable ou un paramètre ( voir [ 11 Variables et Paramètres ] ) est spécifié comme étant un nom qualifié ( QName ) . </div>
<div class="p">S' il dispose d' un préfixe , alors celui -là est développé en une référence d' URI en lui appliquant les déclarations d' espaces de noms applicables aux attributs dans lesquels le nom apparaît . </div>
<div class="p">Le nom étendu , comprenant la partie locale du nom et la possible référence vide à l' URI , est utilisé comme nom de l' objet . </div>
<div class="p">L' espace de noms par défaut n' est pas utilisé pour les noms sans préfixes . </div>
<div class="p">2.5 Traitement de la compatibilité ascendante Un élément active le traitement par compatibilité ascendante pour lui -même , ses attributs , ses descendants et leurs attributs dans le cas où c' est un élément xsl : stylesheet dont l' attribut version est différent de 1.0 , ou c' est un élément littéral résultat ayant un attribut xsl : version dont la valeur est différente de 1.0 , or lorsque c' est un élément littéral résultat qui n' a pas un attribut xsl : version et qui est l' élément document d' une feuille de styles utilisant la syntaxe simplifiée ( voir [ 2.3 Feuille de style sous forme d' élément littéral résultat ] ) . </div>
<div class="p">Un élément littéral résultat ayant un attribut xsl : version dont la valeur est égale à 1.0 désactive le mode de traitement par compatibilité ascendante pour lui -même , ses attributs , ses descendants et leurs attributs . </div>
<div class="p">Si un élément est traité en mode compatibilité ascendante alors : s' il s' agit d' un élément de haut niveau et que XSLT 1.0 ne permet pas à cet élément d' être de haut niveau , alors il doit être ignoré ainsi que son contenu ; S' il s' agit d' un élément d' un modèle qui n' est pas autorisé comme tel par XSLT 1.0 , alors , si l' élément n' est pas instancié , aucune erreur ne doit pas être signalée et si l' élément est instancié , alors XSLT doit exécuter un " recours " pour l' élément tel que spécifié dans [ 15 Reprise ] ; Si l' élément a un attribut non autorisé par XSLT 1.0 ou si l' élément a un attribut optionnel dont la valeur n' est pas autorisée par XSLT 1.0 , alors l' attribut doit être ignoré . </div>
<div class="p">Ainsi , bien que la feuille de styles suivante inclus des éléments de l' espace de noms XSLT non définis dans cette spécification , n' importe quel processeur XSLT 1.0 doit être capable de traiter cette feuille de styles suivante sans produire d' erreur : Si une expression se produit dans un attribut qui est traité en mode compatibilité ascendante , alors un processeur XSLT doit rattraper les erreurs de traitement de l' expression de la manière suivante : Si l' expression n' est pas conforme à la syntaxe permise par la grammaire XPath , alors il ne faut pas signaler d' erreurs tant que l' expression n' est pas évaluée ; Si l' expression appelle une fonction dont le nom n' est pas préfixé et qui ne fait pas partie de la librairie XSLT , alors il ne faut pas signaler d' erreurs tant que la fonction n' est pas appelée ; Si l' expression fait un appel de fonction dont les arguments , en nombre ou en type , ne sont pas autorisés par XSLT , alors il ne faut pas signaler d' erreur tant que la fonction n' est pas appelée . </div>
<div class="p">2.6 Combinaison de feuilles de style XSLT fournit deux mécanismes pour combiner des feuilles de style : un mécanisme d' inclusion permettant aux feuilles de style d' être combinées sans changer la sémantique des feuilles de styles à combiner , et un mécanisme d' import permettant aux feuilles de styles de se recouvrir mutuellement . </div>
<div class="p">2.6.1 Inclusion de feuilles de style 2.6.2 Import des feuilles de style Alors , l' ordre de préséance d' import ( faible d' abord ) est D , B , E , C , A. NOTE : Puisque les éléments xsl : import doivent apparaître avant toute définition ou règle modèle , une implémentation traitant des feuilles de style importées , au moment ou elle rencontre l' élément xsl : import va rencontrer des définitions et des règles modèle dans l' ordre croissant de préséance d' import . </div>
<div class="p">En général , une définition ou règle modèle avec une préséance d' import supérieure prend la préséance sur une définition ou une règle modèle ayant une préséance d' import plus faible . </div>
<div class="p">Ceci est donné avec plus de détail pour chaque type de définition ou de règle modèle . </div>
<div class="p">L' importation directe ou indirecte d' une feuille de styles par elle -même est une erreur . </div>
<div class="p">A partir de là , le cas où une feuille de styles avec une URI particulière est importée à plusieurs endroits n' est pas traitée de manière particulière . </div>
<div class="p">L' arbre d' import aura un élément xsl : stylesheet différent à chaque endroit où elle est importée . </div>
<div class="p">NOTE : Lorsque xsl : apply-imports est utilisé ( voir [ 5.6 Passer outre des règles modèles ] ) , le comportement peut être différent de celui qui aurait été si la feuille de styles avait été importée simplement avec une préséance d' import supérieure . </div>
<div class="p">2.7 Feuilles de style encapsulées Normalement une feuille de styles XSLT est un document XML à part entière ayant l' élément xsl : stylesheet comme élément racine . </div>
<div class="p">Cependant , une feuille de styles XSLT peut aussi être encapsulée dans une autre ressource . </div>
<div class="p">Deux types d' encapsulation sont possibles : la feuille de styles XSLT peut être encapsulée d' une manière textuelle dans une ressource non XML , ou l' élément xsl : stylesheet peut survenir dans un document XML autrement que comme élément racine . </div>
<div class="p">Pour faciliter la deuxième forme d' encapsulation , l' élément xsl : stylesheet est autorisé à avoir un attribut ID permettant de lui attribuer un identifiant unique . </div>
<div class="p">NOTE : Dans le but d' utiliser ce type d' attribut avec la fonction id de XPath , il doit être déclaré dans la DTD comme étant un ID . L' exemple suivant montre comment l' instruction de traitement xml-stylesheet [ feuilles de style XML ] peut être utilisée pour permettre à un document de contenir sa propre feuille de styles . </div>
<div class="p">L' adresse URI utilise une URI relative avec un fragment d' identification pour localiser l' élément xsl : stylesheet : 3 Modèle de données Le modèle de données utilisé par XSLT est le même que celui utilisé par XPath avec en plus ce qui est décrit dans cette section . </div>
<div class="p">XSLT travaille sur les documents de type source , résultat et feuille de styles en utilisant le même modèle de données . </div>
<div class="p">Deux documents XML ayant le même arbre seront traités de la même manière par XSLT . Les instructions de traitement et les commentaires de la feuille de styles sont ignorés : la feuille de styles est traitée comme si , ni les noeuds d' instructions de traitement , ni les noeuds de commentaires , n' étaient inclus dans l' arbre qui représente la feuille de styles . </div>
<div class="p">3.1 Les fils du noeud racine Les restrictions faites sur les fils du noeud racine sont levées pour l' arbre résultat . </div>
<div class="p">L' arbre résultat peut avoir comme enfant n' importe quelle séquence de noeuds qu' il serait possible d' avoir pour un noeud d' élément . </div>
<div class="p">En particulier , il peut avoir pour enfant des noeuds textuels et n' importe quel nombre de noeuds d' éléments . </div>
<div class="p">Lorsqu' un arbre résultat est sauvegardé en utilisant la méthode d' écriture XML ( voir [ 16 Sortie ] ) , il est possible que l' arbre résultat ne soit pas un document XML bien formé ; toutefois , il sera toujours une entité générale externe validée bien formée . </div>
<div class="p">Lorsque l' arbre source est le résultat de l' analyse d' un document XML bien formé , alors le noeud racine de l' arbre source satisfait de facto aux restrictions normales qui sont de ne pas avoir un noeud texte comme enfant et exactement un seul élément enfant . </div>
<div class="p">Si l' arbre source est créé par d' autres moyens , par exemple en utilisant DOM , les restrictions habituelles sont levées pour l' arbre source comme pour l' arbre résultat . </div>
<div class="p">3.2 URI base A chaque noeud est associé une URI qu' on désigne comme étant son URI de base : elle est utilisée pour le remplacement des valeurs relatives des URI d' attributs par des URIs absolues . </div>
<div class="p">Si un élément ou une instruction de traitement survient dans une entité externe , alors son URI de base est l' URI de l' entité externe ; autrement , l' URI de base est l' URI de base du document . </div>
<div class="p">L' URI de base du noeud document est l' URI de l' entité document . </div>
<div class="p">L' URI de base d' un noeud textuel , d' un noeud commentaire , d' un noeud d' attribut ou d' un noeud d' espace de noms est l' URI de base du parent du noeud . </div>
<div class="p">3.3 Entités non valides Le noeud racine dispose de règles de correspondances qui fournissent l' URI de chaque entité non analysée déclarée dans la DTD de ce document . </div>
<div class="p">L' URI est générée à partir des identificateurs système et publique spécifiés dans la déclaration de l' entité . </div>
<div class="p">Le processeur XSLT peut utiliser l' identifiant publique pour générer l' URI d' une entité au lieu de celle spécifiée dans l' identifiant système . </div>
<div class="p">Si le processeur XSLT n' utilise pas un identifiant publique pour générer l' URI , il doit utiliser l' identifiant système ; si l' identifiant système est une URI relative , il doit être résolu et transformé en une URI absolue en utilisant comme URI de base , l' URI de la ressource contenant la déclaration de l' entité [ RFC2396 ] . </div>
<div class="p">3.4 Suppression des espaces blancs Une fois l' arbre pour le document source ou la feuille de styles construit , mais avant tout autre traitement XSLT , certains noeuds textuels sont supprimés . </div>
<div class="p">Un noeud textuel est supprimé quand il ne contient que des caractères d' espaces blancs . </div>
<div class="p">Supprimer le noeud textuel revient à l' enlever de l' arbre . </div>
<div class="p">Le processus de suppression prend en entrée un ensemble de noms d' éléments pour lesquels les caractères d' espaces blancs doivent être préservés . </div>
<div class="p">Le processus de suppression est appliqué aussi bien aux feuilles de styles qu' aux documents source , cependant , les ensembles des noms d' éléments pour lesquels les caractères d' espaces blancs doivent être préservés sont déterminés différemment pour les feuilles de style et les documents source . </div>
<div class="p">Un noeud textuel est préservé si l' une des conditions suivantes est vérifiée : le nom de l' élément parent du noeud textuel fait partie de l' ensemble contenant les noms des éléments dont on veut préserver les caractères d' espaces blancs . </div>
<div class="p">Le noeud textuel contient au moins un caractère différent d' un espace blanc . </div>
<div class="p">Comme pour XML , les espaces blancs sont les caractères dont les codes hexadécimaux sont # x20 , # x9 , # xD ou # xA . Le premier des ancêtres du noeud textuel à avoir l' attribut xml : space renseigné en fixe la valeur à preserve ( en d' autres termes : il n' existe aucun élément entre cet ancêtre et le noeud textuel qui modifierait la valeur de cet attribut pour la remettre à default ) . </div>
<div class="p">Autrement le noeud texte est supprimé . </div>
<div class="p">Les attributs xml : space ne sont pas supprimés de l' arbre . </div>
<div class="p">NOTE : Ceci sous-entend qu' un attribut xml : space est spécifié dans un élément littéral résultat et sera inclus dans le résultat . </div>
<div class="p">Pour les feuilles de style , l' ensemble des noms d' éléments préservant les caractères d' espaces blancs est simplement xsl : text . </div>
<div class="p">S' il reste plus d' une correspondance , c' est une erreur . </div>
<div class="p">Un processeur XSLT peut signaler l' erreur ; s' il ne signale pas l' erreur , il doit la rattraper en choisissant , parmi les correspondances restantes , celle utilisée en dernier dans la feuille de styles . </div>
<div class="p">4 Expressions XSLT utilise le langage d' expression défini par XPath [ XPath ] . </div>
<div class="p">Les expressions sont utilisées dans XSLT pour une variété de possibilités incluant : sélection de noeuds pour traitement ; spécification des conditions pour les différentes manières de traitement d' un noeud ; génération de texte à insérer dans l' arbre résultat . </div>
<div class="p">Une expression doit correspondre à la règle de production Expr de XPath . </div>
<div class="p">Les expressions interviennent comme valeurs de certains attributs d' éléments XSLT et entre accolades dans des modèles de valeurs d' attributs . </div>
<div class="p">Dans XSLT , une expression autonome ( c' est à dire : une expression qui ne fait partie d' aucune autre expression ) prend son contexte comme suit : Le noeud contextuel est le noeud courant la position contextuelle vient de la position du noeud courant dans la liste courante de noeuds ; la première position est 1 la dimension contextuelle est issue de la dimension de la liste courante de noeuds les liens variables sont ceux dans le périmètre de l' élément ayant un attribut dans lequel l' expression se produit ( voir [ 11 Variables et Paramètres ] ) l' ensemble de déclarations d' espace de noms sont celles dans le champ de l' élément ayant l' attribut dans lequel l' expression se produit ; ceci inclus la déclaration implicite du préfixe xml exigé par la Recommandation des espaces de noms [ Noms XML ] ; l' espace de noms par défaut ( comme déclaré par xmlns ) n' appartient pas à cet ensemble . la librairie de fonctions est représentée par la librairie de fonctions de base augmentée des fonctions additionnelles définies dans [ 12 Fonctions additionnelles ] et des fonctions d' extension décrites dans [ 14 Extensions ] ; Lorsqu' une expression appelle une quelconque autre fonction , une erreur doit être générée . </div>
<div class="p">5 Règles modèle 5.1 Modèle de traitement Une liste de noeuds sources est traitée pour créer un fragment de l' arbre résultat . </div>
<div class="p">L' arbre résultat est construit par traitement d' une liste contenant juste le noeud racine . </div>
<div class="p">Une liste de noeuds sources est traitée par rajout successif des arbres résultants du traitement successif de chaque noeud de la liste . </div>
<div class="p">Un noeud est traité en trouvant toutes les règles modèle dont les motifs correspondent au noeud , et en choisissant le meilleur parmi elles ; la règle modèle retenue est alors instanciée en considérant le noeud comme noeud courant et la liste de noeuds source comme liste courante de noeuds . </div>
<div class="p">Typiquement , un modèle contient des instructions traitant une liste de noeuds source sélectionnés . </div>
<div class="p">Le processus de correspondance , instanciation et sélection se poursuit récursivement et se termine lorsque aucun nouveau noeud source n' est sélectionné pour traitement . </div>
<div class="p">Les outils sont libres de traiter le document source par n' importe quel moyen du moment ou le résultat produit est le même que s' il était traité par ce modèle de traitement . </div>
<div class="p">5.2 Modèles Les règles modèle identifient les noeuds auxquels elles s' appliquent en utilisant un motif . </div>
<div class="p">Les motifs sont aussi bien utilisés dans des règles modèle que pour la numérotation ( voir [ 7.7 Numérotation ] ) ou la déclaration de clés ( voir [ 12.2 Clés ] ) . </div>
<div class="p">Un motif spécifie un ensemble de conditions sur un noeud . </div>
<div class="p">Un noeud satisfaisant les conditions correspond au motif ; un noeud qui ne satisfait pas les conditions ne correspond pas au motif . </div>
<div class="p">La syntaxe pour les motifs est un sous-ensemble de la syntaxe pour les expressions . </div>
<div class="p">En particulier , les chemins de localisation soumis à certaines restrictions peuvent être utilisés comme des motifs . </div>
<div class="p">Une expression , qui est aussi un motif , donne toujours comme résultat un objet qui est un ensemble de noeuds . </div>
<div class="p">Un noeud correspond à un motif si le noeud est membre du résultat de l' évaluation du motif , considéré alors comme expression respectant un certain contexte ; ce cas se produit quand le noeud contextuel est le noeud en train d' être mis en correspondance ou l' un de ses ancêtres . </div>
<div class="p">Voici quelques exemples de motifs : para correspond à n' importe quel élément para * correspond à n' importe quel élément chapter appendix trouve tous les éléments chapter et appendix olist / item trouve tous les éléments item ayant olist comme parent appendix//para correspond à n' importe quel élément para dont un ancêtre est appendix / correspond au noeud racine text ( ) correspond à n' importe quel noeud textuel processing-instruction ( ) correspond à n' importe quel instruction de traitement node ( ) correspond à n' importe quel noeud autre qu' un noeud attribut et que le noeud racine id ( " W11 " ) correspond à l' élément ayant l' identifiant unique W11 para [ 1 ] correspond au premier des éléments para d' un parent * [ position ( ) =1 and self : :para ] correspond à n' importe quel élément para qui est le premier élément fils de son parent para [ last ( ) =1 ] correspond à n' importe quel élément para qui est l' unique élément para de son élément parent items / item [ position ( ) &gt; 1 ] correspond à tous les éléments item , autres que le premier , et dont le parent est items item [ position ( ) mod 2 = 1 ] serait vrai pour tous les fils item de numéro d' ordre impair par rapport à leur parent . div [ @class="appendix"]//p correspond à tous les éléments p ayant un ancêtre div pour lequel l' attribut class prend la valeur appendix @class correspond à tous les attributs class ( pas à tous les éléments ayant l' attribut class ) @ * correspond à n' importe quel attribut Un motif doit concorder avec la grammaire des motifs ( Pattern ) . </div>
<div class="p">Un motif est un ensemble de motifs de chemins de localisation séparés par . </div>
<div class="p">Un motif de chemin de localisation est un chemin de localisation dont les étapes n' utilisent que les axes child ou attribute . </div>
<div class="p">Bien que les motifs ne doivent pas utiliser l' axe descendant-or-self , ils peuvent utiliser l' opérateur / / tout aussi bien que l' opérateur / . </div>
<div class="p">Les motifs de chemins de localisation peuvent aussi commencer par un appel de fonction id ou key avec un argument littéral . </div>
<div class="p">Les prédicats d' un motif peuvent utiliser n' importe quelle expression exactement comme ceux des chemins de localisation . </div>
<div class="p">Un motif est conçu pour concorder avec un noeud si et seulement s' il existe un contexte tel que lorsque le motif est évalué comme une expression dans ce contexte , le noeud appartient à l' ensemble de noeuds résultat . </div>
<div class="p">Lorsqu' une correspondance est en train d' être établie pour un noeud , les contextes possibles ont un noeud contextuel qui est le noeud en train d' être mis en correspondance ou un de ses ancêtres , et une liste de noeuds contextuels réduite au seul noeud contextuel . </div>
<div class="p">Par exemple , p concorde avec n' importe quel élément p , parce que pour tout p , si l' expression p est évaluée dans le contexte de son élément parent , alors cet élément p appartiendra à l' ensemble des noeuds résultat . </div>
<div class="p">NOTE : Cela correspond même à un élément p qui serait l' élément document puisque la racine du document est le parent de l' élément document . </div>
<div class="p">Bien que la sémantique des motifs soit indirectement spécifiée en terme d' évaluation d' expressions , il est facile de comprendre directement la signification des motifs sans devoir les considérer comme des évaluations d' expression . </div>
<div class="p">Dans un motif , indique les alternatives ; un motif avec un ou plusieurs séparant différentes alternatives concorde si l' une des alternatives concorde . </div>
<div class="p">La correspondance pour un motif composé d' une séquence d' étapes ( StepPatterns ) séparés par / ou / / est faite de droite vers la gauche . </div>
<div class="p">La concordance du motif ne se produit que si l' étape la plus à droite concorde et qu' un élément approprié concorde avec le reste du motif ; si le séparateur est / alors seul le parent est un élément approprié ; si le séparateur est / / , alors tout élément ancêtre peut être un élément approprié . </div>
<div class="p">Une séquence d' étape ( StepPatterns ) qui utilise l' axe fils concorde si le test de noeud ( NodeTest ) est vrai pour le noeud et si le noeud n' est pas un noeud d' attribut . </div>
<div class="p">Une séquence d' étapes ( StepPattern ) qui utilise l' axe des attributs concorde si le test de noeud ( NodeTest ) est vrai pour le noeud et si le noeud est un noeud attribut . </div>
<div class="p">Si [ ] est présent , alors la première expression du prédicat ( PredicateExpr ) dans une séquence d' étapes ( StepPattern est évalué en considérant que le noeud pour lequel une concordance est en train d' être établie est le noeud contextuel et que ses suivants correspondant au test de noeud ( NodeTest ) forment la liste des noeuds contextuels , à moins que le noeud en train d' être recherché ne soit un noeud d' attribut , auquel cas , la liste des noeuds contextuels correspond à tous les attributs ayant le même parent que l' attribut en train d' être recherché et qui concorde avec le test de nom ( NameTest ) . </div>
<div class="p">Par exemple : appendix//ulist / item [ position ( ) =1 ] correspond à un noeud si et seulement si tout ce qui suit est vrai : le test de noeud ( NodeTest ) item est vrai pour le noeud et le noeud n' est pas un attribut ; en d' autres termes , le noeud est un élément item L' évaluation du prédicat ( PredicateExpr ) position ( ) =1 est vraie en considérant le noeud comme noeud contextuel et les suivants du noeud ( qui sont des éléments item ) comme liste de noeuds contextuels Le noeud a un parent qui concorde avec le motif appendix//ulist ; Ceci est vrai si le parent est un élément ulist dont un des ancêtres est l' élément appendix . </div>
<div class="p">5.3 Définition de règles modèle Comme décrit dans ce qui suit , l' élément xsl : apply-templates traite d' une manière récursive les fils de l' élément source . </div>
<div class="p">5.4 Application des règles modèle NOTE : Typiquement , xsl : apply-templates est utilisé pour traiter uniquement les noeuds qui sont des descendants du noeud courant . </div>
<div class="p">Une telle utilisation de xsl : apply-templates ne peut engendrer une boucle de traitement infinie . </div>
<div class="p">Cependant , lorsque xsl : apply-templates est utilisé pour traiter les éléments qui ne sont pas des descendants du noeud courant , il y a une possibilité de boucle infinie . </div>
<div class="p">Par exemple : Les outils peuvent , dans certains cas , être capables de détecter de pareilles boucles , mais la possibilité qu' une feuille de styles entre dans une boucle infinie sans que le programme ne la détecte persiste . </div>
<div class="p">5.5 Résolution de conflits des règles modèle Il est possible qu' un noeud source concorde avec plusieurs règles modèle . </div>
<div class="p">La règle à utiliser est déterminée de la manière suivante : Premièrement , toutes les règles concordantes ayant une préséance d' import plus faible que la règle considérée ou que celles qui ont la préséance d' import plus forte sont éliminées . </div>
<div class="p">Ensuite , toutes les règles ayant une plus faible priorité que la règle considérée ou que les règles ayant la priorité la plus forte sont éliminées . </div>
<div class="p">La priorité d' une règle modèle est spécifiée par l' attribut priority de la règle . </div>
<div class="p">Sa valeur doit être un nombre réel ( négatif ou positif ) , conforme à la règle de production Number avec un signe moins ( - ) optionnel au début du nombre . La priorité par défaut est calculée comme suit : Si le motif contient plusieurs alternatives séparées par , alors il est traité comme si c' était un ensemble de règles modèle , une pour chaque alternative . </div>
<div class="p">Si le motif a la forme d' un nom qualifié ( QName ) précédé par un ChildOrAttributeAxisSpecifier ou a la forme d' une instruction de traitement processing-instruction ( Literal ) précédé par un ChildOrAttributeAxisSpecifier , alors la priorité est 0 . </div>
<div class="p">Si le motif a la forme d' un nom sans deux points ( NCName ) : * précédé d' un ChildOrAttributeAxisSpecifier , alors la priorité est - 0.25 . </div>
<div class="p">Autrement , si le pattern consiste uniquement en un test de noeud NodeTest précédé par un ChildOrAttributeAxisSpecifier , alors la priorité est - 0.5 . </div>
<div class="p">Sinon , la priorité est 0.5 . </div>
<div class="p">Ainsi le plus commun des types de motifs ( un motif qui teste un type particulier de noeuds avec un nom étendu particulier ) a une priorité 0 . </div>
<div class="p">Ensuite , le type de motif le moins spécifique ( un motif qui teste un type particulier de noeuds et un nom étendu avec une URI particulière indiquant son espace de noms ) a une priorité de - 0.25 . </div>
<div class="p">Les motifs les moins spécifiques ( motifs permettant de tester un type particulier de noeuds ) ont une priorité de - 0.5 . </div>
<div class="p">Les motifs les plus spécifiques que le motif le plus commun ont une priorité de 0.5 . </div>
<div class="p">Si après vérification des conditions ci-dessus il reste plus qu' une seule règle modèle qui concorde alors il y a une erreur . </div>
<div class="p">Un processeur XSLT peut signaler l' erreur ; s' il ne le fait pas , il doit la rattraper en choisissant , parmi les règles concordantes restantes , celle qui arrive en dernière dans la feuille de styles . </div>
<div class="p">5.6 Passer outre des règles modèles Les modèles peuvent être invoqués par leur nom . </div>
<div class="p">L' utilisation de l' attribut name de l' élément xsl : template permet de spécifier un nom de modèle . </div>
<div class="p">La valeur de l' attribut name est un nom qualifié ( QName ) , qui est développé tel que décrit au chapitre [ 2.4 Noms qualifiés ] . </div>
<div class="p">Quand l' élément xsl : template est qualifié par l' attribut name , il peut , sans que cela soit obligatoire , avoir également un attribut match . </div>
<div class="p">L' élément xsl : call-template permet d' appeler un modèle par son nom ; il a un attribut obligatoire name qui identifie le modèle à appeler . </div>
<div class="p">Au contraire de l' élément xsl : apply-templates , xsl : call-template ne modifie pas le noeud courant ou la liste courante de noeuds . </div>
<div class="p">Les attributs match , mode et priority d' un élément xsl : template n' ont pas d' effet si le modèle est invoqué par un élément xsl : call-template . </div>
<div class="p">De même , l' attribut name d' un élément xsl : template n' a pas d' effet si le modèle est invoqué par un élément xsl : apply-templates . </div>
<div class="p">Une erreur est produite si une même feuille de styles contient plus d' un modèle ayant à la fois le même nom et la même préséance d' import . 7 Création de l' arbre résultant Cette section décrit les instructions qui créent directement des noeuds dans l' arbre résultant . </div>
<div class="p">7.1 Création d' éléments et d' attributs 7.1.1 Eléments résultats littéraux Dans un modèle , un élément d' une feuille de style qui n' appartient pas à l' espace de noms XSLT et n' est pas un élément extension ( voir [ 14.1 Eléments extension ] ) est instancié pour créer un noeud élément avec le même nom étendu . le contenu de l' élément est un template qui est instancié pour donner le contenu de l' élément noeud créé . </div>
<div class="p">L' élément noeud créé aura les noeuds attributs qui étaient présents sur le noeud élément dans l' arbre de la feuille de style , plutôt que les attributs avec les noms dans l' espace de noms XSLT . Le noeud élément créé aura aussi une copie de l' espace de noms des noeuds qui étaient présents sur l' élément noeuds dans la feuille de style avec l' exception que tout espace de noms dont la valeur textuelle est l' espace de noms XSLT URI ( http : / / www . w3 . org / 1999 / XSL / Transform ) , un nom d' espace URI déclaré a une extension d' espace de noms ( voir [ 14.1 Éléments extension ] ) ou un espace de noms URI désigné comme un espace de noms exclu . </div>
<div class="p">Un espace de noms URI est désigné comme un espace de noms exclu en utilisant un attribut exclude-result-prefixes sur un élément xsl : stylesheet ou un attribut xsl : exclude-result-prefixes sur un élément résultat littéral . </div>
<div class="p">La valeur de ces deux attributs est une liste de préfixes d' espace de noms séparés par un espace blanc . </div>
<div class="p">L' espace de nom relié à chacun des préfixes est désigné comme un espace de noms exclu . </div>
<div class="p">C' est une erreur s' il n' y a pas d' espace de noms relié au préfixe sur un élément supportant l' attribut exclude-result-prefixes ou xsl : exclude-result-prefixes . </div>
<div class="p">L' espace de noms par défaut ( comme déclaré par xmlns ) peut-être désigné comme un espace de noms exclu en incluant # default dans la liste des préfixes d' espace de noms . </div>
<div class="p">La désignation d' un espace de noms comme par exemple un espace de noms exclu est effectif dans un sous arbre de la feuille de style relié à l' élément supportant l' attribut exclude-result-prefixes ou xsl : exclude-result-prefixes ; un sous arbre relié à un élément xsl : stylesheet n' inclue pas toutes les feuilles de style importées ou inclues par les enfants de cet élément . </div>
<div class="p">NOTE : Quand une feuille de style utilise une déclaration d' espace de noms seulement dans le but d' adresser un arbre source , en spécifiant le préfixe dans l' attribut exclude-result-prefixes , cela n' empêche pas les déclarations superflues d' espaces de noms dans l' arbre résultant . </div>
<div class="p">La valeur d' un attribut d' un élément résultat littéral est interprétée comme la valeur de l' attribut template : il peut contenir des expressions contenues entre accolades ( { } ) . </div>
<div class="p">Un espace de noms URI dans l' arbre d' une feuille de style est utilisé pour spécifier un espace de noms URI dans l' arbre résultant est appelé espace de noms URI littéral . </div>
<div class="p">Cela s' applique à : l' espace de noms URI est un nom étendu d' un élément résultat littéral dans la feuille de style l' espace de noms URI dans le nom étendu d' un attribut spécifié dans un élément résultat littéral dans la feuille de style la valeur textuelle d' un noeud d' espace de noms sur un élément résultat littéral d' une feuille de style génèrera une feuille de style XSLT à partir d' un document de la forme : NOTE : Il peut être aussi nécessaire d' utiliser des alias pour les espaces de noms plutôt que les espaces de noms XSLT URI . Par exemple , les éléments résultats littéraux appartenant à un espace de noms qui comportent des signatures digitales peuvent faire qu' une feuille de style XSLT soit mal comprise par un programme sécuritaire , en utilisant un alias pour l' espace de noms l' on peut éviter une telle confusion . </div>
<div class="p">7.1.2 Créer des éléments avec xsl : element le résultat ne sera pas la déclaration d' un espace de noms . </div>
<div class="p">En ajoutant un attribut à un élément remplace l' attribut existant de cet élément avec le même nom étendu . </div>
<div class="p">Les opération suivantes sont des erreurs : Ajouter un attribut à un élément après que des enfants lui aient été rajoutés , les implémentations peuvent signaler l' erreur ou ignorer l' attribut . </div>
<div class="p">Ajouter un attribut à un noeud qui ne soit pas un élément , les implémentations peuvent signaler l' erreur ou ignorer l' attribut . </div>
<div class="p">Créer des noeuds autres que des noeuds de texte durant l' instanciation du contenu de l' élément xsl : attribute ; les implémentations peuvent signaler l' erreur ou ignorer l' attribut . </div>
<div class="p">NOTE : Quand un xsl : attribute contient un noeud de texte avec un saut de ligne , alors la sortie XML doit contenir une référence de caractère . </div>
<div class="p">Par exemple , donnera comme résultat : ( ou tout autre référence de caractère équivalente ) . </div>
<div class="p">La sortie XML peut être C' est parceque XML 1.0 demande que les retours à la ligne dans les valeurs d' attributs soient traités comme des espaces , mais ne l' exige pas des références de caractère de retour à la ligne . </div>
<div class="p">Les valeurs d' attributs du modèle de données représentent la valeur de l' attribut après normalisation . </div>
<div class="p">Si un retour à la ligne se trouvant dans une valeur d' attribut de l' arbre était sorti comme un caractère de retour à la ligne plutôt que comme une référence de caractère , alors la valeur de l' attribut dans l' arbre créé en reparsant le fichier XML contiendrait un espace et nom un saut de ligne , ce qui signifirait que l' arbre n' a pas été produit correctement . </div>
<div class="p">7.1.4 Ensembles d' attributs nommés Des définitions multiples d' un ensemble d' attributs ayant le même nom étendu sont fusionnées . </div>
<div class="p">Un attribut d' une définition qui possède une préséance d' import plus élevée passe avant l' attribut d' une définition qui en aurait une plus faible . </div>
<div class="p">C' est une erreur quand il y a deux ensembles d' attributs ayant un même nom étendu et une même préséance d' import et que les deux contiennent le même attribut , à moins que ne soit précisé une définition de l' ensemble d' attribut qui confère à l' un d' eux une plus haute préséance d' import Un processeur XSLT peut signaler l' erreur , si il ne le fait pas , il doit rattraper l' erreur en choisissant parmi les définittions qui spécifient l' attribut que celle qui a la plus haute préséance d' import est la dernière à avoir été spécifiée dans la feuille de style . </div>
<div class="p">L' emplacement où les attributs d' un ensemble d' attributs sont spécifiés est significatif uniquement en fusionnant les attributs dans un ensemble d' attributs ; cela ne fait aucune différence de savoir quand l' ensemble d' attributs est utilisé . </div>
<div class="p">7.2 Créer du texte Un modèle peut aussi contenir des noeuds textuels . </div>
<div class="p">Chaque noeud textuel du modèle restant après que les espaces blancs aient été filtrés conformément à ce qui est spécifié au chapitre [ 3.4 Suppression d' espaces ] créera un noeud textuel de même valeur textuelle dans l' arbre résultant . </div>
<div class="p">Les noeuds textuels adjacents d' un arbre résultat seront automatiquement fusionnés . </div>
<div class="p">Noter que le texte est traité au niveau de l' arbre . </div>
<div class="p">Donc , le balisage de &amp; lt ; dans le modèle sera représenté dans l' arbre de la feuille de style par un noeud textuel incluant le caractère &lt; . </div>
<div class="p">Cela créera un noeud textuel dans l' arbre résultat qui contiendra &lt; , lequel sera représenté par l' entité &amp; lt ; ( ou une référence de caractère équivalente ) quand l' arbre résultat est mis sous la forme d' un document XML ( à moins que la méthode de sortie XML soit désactivée comme décrit dans [ 16.4 Désactivation de la production littérale des caractères en sortie ] ) . </div>
<div class="p">7.3 Créer des instructions de traitement créera l' instruction de traitement Ce n' est pas une erreur quand le résultat de l' intanciation n' est ni un NCName ni un PITarget . </div>
<div class="p">Un processeur XSLT peut signaler l' erreur ; si il ne le fait pas , il doit la rattraper en supprimant l' instruction de traitement de l' arbre résultant . </div>
<div class="p">NOTE : Cela signifie que l' élément xsl : processing-instruction ne peut pas être utilisé pour produire une déclaration XML . L' élément xsl : output devra être utilisé à la place ( voir [ 16 Sorties ] ) . </div>
<div class="p">C' est une erreur quand l' intanciation du contenu de xsl : processing-instruction crée un noeud autre qu' un noeud textuel . </div>
<div class="p">Un processeur XSLT peut signaler l' erreur mais si il ne le fait pas , il doit ignorer les noeuds posant problème ainsi que leur contenu . </div>
<div class="p">C' est une erreur si l' intanciation du contenu de xsl : processing-instruction contient la chaîne ? &gt; . </div>
<div class="p">Un processeur XSLT peut signaler l' erreur ; si il ne le fait pas , il doit rattraper l' erreur en insérant un espace après toute occurence de ? qui est suivie par un &gt; . </div>
<div class="p">7.4 Créer des commentaires Créera ce commentaire : C' est une erreur si l' instanciation du contenu de xsl : comment crée des noeuds autres que des noeuds textuels . </div>
<div class="p">Un processeur XSLT peut signaler l' erreur , si'l ne le fait pas , il doit la rattraper en ignorant le noeud posant problème ainsi que son contenu . </div>
<div class="p">C' est une erreur si le contenu résultant de l' instanciation de xsl : comment contient la chaîne </div>
<div class="p">ou si elle finit par - . </div>
<div class="p">Un processeur XSLT peut signaler l' erreur ; si il ne le fait pas , il doit rattraper l' erreur en insérant un espace après toute occurence de - suivie d' un autre carcatère - ou qui se trouve être à la fin du commmentaire . </div>
<div class="p">7.5 Copier au lieu de : L' élément xsl : value-of est instancié pour créer un noeud textuel de l' arbre résultant . </div>
<div class="p">L' attribut obligatoire select est une expression ; cette expression est évaluée et l' objet résultant est converti en une chaîne de caractères comme l' aurait fait la fonction string . </div>
<div class="p">La chaîne de caractères spécifie la valeur textuelle du noeud textuel créé . </div>
<div class="p">Si la chaîne est vide , le noeud textuel ne sera pas créé . </div>
<div class="p">Le noeud textuel créé sera fusionné avec tout autre noeud textuel adjacent . </div>
<div class="p">L' élément xsl : copy-of peut être utilisé pour copier un ensemble de noeuds vers l' arbre résultat sans les convertir en chaîne . </div>
<div class="p">Voir [ 11.3 Utiliser des valeurs de variables et de paramètres avec xsl : copy-of ] . </div>
<div class="p">Par exemple , les déclarations suivantes créent un paragraphe HTML à partir de l' élément person et de ses attributs given-name et family-name . </div>
<div class="p">Le paragraphe contiendra la valeur de l' attribut given-name du noeud courant suivie d' un espace et de la valeur de l' attribut family-name du noeud courant . </div>
<div class="p">L' exemple suivant crée un élément résultat img à partir de l' élément source photograph ; la valeur de l' attribut src de l' élément img est calculée à partir de la valeur de la variable image-dir et de la valeur textuelle de l' enfant href de l' élément photograph ; la valeur de l' attribut width de l' élément img est calculée à partir de la valeur de l' attribut width de l' enfant size de l' élément photograph : Avec le source : n' est pas autorisée . </div>
<div class="p">A la place , utiliser simplement : Si aucun attribut value n' est spécifié , alors l' élément xsl : number insère un nombre basé sur la position du noeud courant dans l' arbre source . </div>
<div class="p">Les attributs suivants contrôlent la manière dont le noeud courant doit être numéroté : L' attribut level spécifie les niveaux de l' arbre source qui doivent être considérés ; les valeurs possibles sont single , multiple ou any . </div>
<div class="p">La valeur par défaut est single . </div>
<div class="p">L' attribut count est un motif qui spécifie les noeuds à comptabiliser dans les niveaux spécifiés . </div>
<div class="p">Si l' attribut count n' est pas spécifié , alors sa valeur par défaut est le motif qui correspond à tous les noeuds de même type que le noeud courant et , si le noeud courant a un nom expansé , ayant le même nom expansé que le noeud courant . </div>
<div class="p">L' attribut from est un motif qui spécifie où commence l' énumération . </div>
<div class="p">De plus , les attributs décrits au chapitre [ 7.7.1 Attributs de conversion de nombres en chaînes de caractères ] sont utilisés dans les conversions de nombres en chaînes de caractères , comme lorsque l' attribut value est spécifié . </div>
<div class="p">L' élément xsl : number commence par construire une liste d' entiers positifs en utilisant les attributs level , count et from selon les règles suivantes : Quand level="single " , le premier des ancêtres dans l' axe ancêtre-ou-réflexif ( ancestor-or-self ) correspondant au motif spécifié par l' attribut count est recherché puis une liste contenant cet ancêtre et tous ses prédécesseurs correspondant eux -mêmes au motif précisé par l' attribut count est construite . </div>
<div class="p">Si le premier ancêtre n' existe pas , la liste construite est vide . </div>
<div class="p">Si l' attribut from est spécifié , alors , les seuls ancêtres recherchés sont ceux qui sont des descendants de l' ancêtre le plus proche correspondant au motif from . </div>
<div class="p">Les prédécesseurs ont ici la même signification que dans l' axe des prédécesseurs ( preceding-sibling axis ) . </div>
<div class="p">Quand level="multiple " , une liste de tous les ancêtres du noeud courant dans l' ordre du document est construite terminée par le noeud courant lui -même ; ensuite , les noeuds correspondant au motif count sont extraits de cette liste et chacun d' eux provoque la création d' une liste composée du noeud et de l' ensemble de ses prédécesseurs correspondant au motif count . </div>
<div class="p">Si l' attribut from est spécifié , alors les seuls ancêtres à être recherchés sont ceux qui sont des descendants de l' ancêtre le plus proche correspondant au motif from . </div>
<div class="p">Les prédécesseurs ont ici la même signification que dans l' axe des prédécesseurs ( preceding-sibling axis ) . </div>
<div class="p">Quand level="any " , une liste à un élément est constituée contenant le nombre de noeuds qui correspondent au motif count et appartiennent à l' ensemble formé du noeud courant et de tous les noeuds du document , quel que soit leur niveau , qui se trouvent avant le noeud courant dans l' ordre du document , à l' exclusion des noeuds d' espace de noms et d' attribut ( en d' autres termes , il s' agit de l' union des membres des axes prédécesseurs ( preceding ) et ancêtres-ou-réflexif ( ancestor-or-self ) . </div>
<div class="p">Si l' attribut from est spécifié , alors seuls les noeuds qui se trouvent après le premier noeud précédant le noeud courant et correspondant au motif from sont pris en considération . </div>
<div class="p">La liste des nombres est ensuite convertie en une chaîne de caractères en utilisant les attributs décrits au chapitre [ 7.7.1 Attributs de conversion de nombres en chaînes de caractères ] ; dans ce contexte , la valeur de chacun de ces attributs est interprétée comme un modèle de valeur d' attribut . </div>
<div class="p">Après conversion , la chaîne de caractères résultante est insérée dans l' arbre résultat . </div>
<div class="p">Les lignes suivantes calculent le nombre d' items d' une liste ordonnée : L' exemple suivant numérote les éléments HTML H4 avec un préfixe composé de 3 parties : Quand on numérote avec une séquence alphabétique , l' attribut lang spécifie quel alphabet de langue doit être utilisé ; il a la même gamme de valeurs que xml : lang [ XML ] ; si aucune valeur lang n' est spécifiée , la langage doit être déterminé de l' environnement système . </div>
<div class="p">Les développeurs de logiciels doivent documenter les langages supportés par leur implémentation de la numérotation . </div>
<div class="p">NOTE : les développeurs de logiciels ne doivent faire aucune supposition concernant la manière dont la numérotation fonctionne dans des cas particuliers de langages et doivent correctement étudier les langages qu' ils se proposent de supporter . </div>
<div class="p">Les conventions de numérotations étant différentes de l' anglais dans de nombreux langages . </div>
<div class="p">L' attribut letter-value permet de lever les ambiguïtés concernant les séquences de numérotation reposant sur des lettres . </div>
<div class="p">Dans de nombreux langages , il y a deux séquences communément utilisées de numérotations à base de lettres . </div>
<div class="p">L' une attribue des valeurs numériques aux lettres ordonnées selon l' alphabet , et l' autre attribue des valeurs numériques aux lettres selon d' autres critères traditionnels propre au langage . </div>
<div class="p">En anglais , cela correspondrait aux règles de numérotation a et i . </div>
<div class="p">Dans d' autres langages , le premier membre de chaque séquence est le même , faisant que la seule marque de formatage serait ambïgue . </div>
<div class="p">La valeur alphabetic permet de spécifier qu' il s' agit d' une séquence alphabétique ; La valeur traditional permet de préciser une autre séquence . </div>
<div class="p">Si l' attribut letter-value n' est pas précisé , alors la levée de l' ambiguïté dépend de l' implémentation . </div>
<div class="p">NOTE : Il est possible que deux processeurs XSLT conformes ne convertissent pas tout à fait un même nombre en une chaîne de caractères strictement identique . </div>
<div class="p">Il se peut que des processeurs XSLT ne supportent pas certains lanagages . </div>
<div class="p">De plus , il peut y avoir des variations dans la manière dont les conversions sont effectuées pour des langages spécifiques qui ne soient pas contrôlables par les attributs de xsl : number . </div>
<div class="p">Les futures versions de XSLT pourront fournir des attributs additionnels pour pouvoir contrôler ces variations . </div>
<div class="p">Les implémentations peuvent également utiliser sur l' élément xsl : number des attributs issus d' espaces de noms spécifiques à l' implémentation . </div>
<div class="p">L' attribut grouping-separator donne le séparateur utilisé comme séparateur de groupes ( par exemple les milliers ) des séquences numériques , et l' attribut optionnel grouping-size spécifie la taille ( habituellement 3 ) du regrouppement . </div>
<div class="p">Par exmple , grouping-separator= " , " et grouping-size="3 " produiraient des nombres de la forme 1 , 000 , 000 . </div>
<div class="p">Si un seul des deux attributs grouping-separator et grouping-size est spécifié , alors il est ignoré . </div>
<div class="p">Voici quelques exemples de spécifications de conversion : format="&amp;#x30A2 ; " spécifie une numérotation en Katakana format="&amp;#x30A4 ; " spécifie une numérotation Katakana dans l' ordre " iroha " format="&amp;#x0E51 ; " spécifie une numérotation en chiffres Thai format="&amp;#x05D0 ; " letter-value="traditional " spécifie une numérotation traditionnelle en Hébreu format="&amp;#x10D0 ; " letter-value="traditional " spécifie une numérotation en Géorgien format="&amp;#x03B1 ; " letter-value="traditional " spécifie une numérotation en Grec " classique " format="&amp;#x0430 ; " letter-value="traditional " spécifie une numérotation en vieux Slave 8 Répétition Il est utile de pouvoir spécifier directement le modèle pour les noeuds sélectionnés lorsque le résultat est une structure régulière connue . </div>
<div class="p">L' instruction xsl : for-each contient un modèle qui est instancié pour chaque noeud sélectionné par l' expression spécifiée en tant que valeur de l' attribut select . </div>
<div class="p">L' attribut select est obligatoire . </div>
<div class="p">Le résultat de l' évaluation de l' expression doit être un ensemble de noeuds . </div>
<div class="p">Le modèle est instancié avec le noeud sélectionné identifié comme le noeud courant , et avec la liste de tous les noeuds sélectionnés identifiée comme la liste courante de noeuds . </div>
<div class="p">À moins qu' une spécification d' ordre ne soit présente , les noeuds sont traités dans l' ordre induit par le document ( voir [ 10 Tri ] ) . </div>
<div class="p">Par exemple , Considérons un document XML avec la structure suivante : ce qui suit permet de créer un document HTML contenant une table contenant une ligne pour chaque élément customer 9 Traitement conditionnel XSLT propose deux instructions qui pemettent le traitement conditionnel dans un modèle : xsl : if et xsl : choose . </div>
<div class="p">L' instruction xsl : if sert à exprimer la condition simple si-alors ; L' instruction xsl : choose permet quant à elle un choix parmi plusieurs possibilités . </div>
<div class="p">9.1 Traitement conditionnel par xsl : if L' élément xsl : if a un attribut test qui spécifie une expression . </div>
<div class="p">Le contenu est un modèle . </div>
<div class="p">Après évaluation de l' expression , le résultat est converti en booléen comme si elle avait été évaluée par la fonction boolean . </div>
<div class="p">Si le résultat est vrai alors le contenu du modèle est instancié , sinon rien n' est créé . </div>
<div class="p">Dans l' exemple suivant , les noms dans un groupe de noms sont formatés sous la forme d' une liste de noms séparés par des virgules : L' exemple suivant colore en jaune une ligne de tableau sur 2 ( les lignes de rang pair ) : 9.2 Traitement conditionnel par xsl : choose 10 tri case-order peut avoir soit la valeur upper-first ou la valeur lower-first ; ceci n' est valable que lorsque data-type="text " , et indique que les lettres majuscules sont triées avant les lettres minuscules dans le cas upper-first et inversement dans le cas lower-first . </div>
<div class="p">Par exemple , si lang="en " , alors A a B b sont triées avec case-order="upper-first " et a A b B sont triées avec case-order="lower-first " . </div>
<div class="p">La valeur par défaut dépend de la langue . </div>
<div class="p">NOTE : Deux processeurs XSLT conformes peuvent ne pas faire exactement le même tri . </div>
<div class="p">Certains processeurs XSLT peuvent ne pas supporter certaines langues . </div>
<div class="p">Il peut aussi y avoir des variations possibles lors d' un tri dans n' importe quelle langue particulière qui n' est pas spécifiée par l' attribut de xsl : sort , par exemple , lorsque Hiragana ou Katakana est trié en Japonais dans un premier temps . </div>
<div class="p">Les versions de XSLT peuvent fournir des attributs additionnels afin de permettre un contrôle sur ces variations . </div>
<div class="p">Pour cela , les réalisations peuvent aussi utiliser des attributs appartenant à des espaces de noms spécifiques à l' implémentation en question pour xsl : sort . </div>
<div class="p">NOTE : Il est recommandé aux développeurs de consulter [ UNICODE TR10 ] pour des informations sur le tri internationalisé . </div>
<div class="p">Le tri doit être stable : dans une liste de noeuds triée , n' importe quel sous-liste ayant des clés de tri égales doit être ordonnée dans l' ordre du document . </div>
<div class="p">Considérons par exemple , une base de données répertoriant des employés et ayant la forme Alors , une liste d' employés triée par le nom peut être générée en utilisant 11 Variables et Paramètres &lt; ! </div>
<div class="p">Category : instruction </div>
<div class="p">&gt; &lt; xsl : variable name = qname select = expression &gt; &lt; ! </div>
<div class="p">Content : template </div>
<div class="p">&gt; &lt;/xsl:variable&gt; Si le contenu de l' élément de lien de variable est vide et cet élément n' a pas un attribut select , alors la valeur de la variable est une chaîne de caractères vide . </div>
<div class="p">Ainsi est équivalent à NOTE : Lorsqu' une variable est utilisée pour sélectionner des noeuds par position , éviter de faire : Cela cause l' affichage du premier élément item , car la variable n sera liée un fragment d' arbre résultat et non à un nombre . </div>
<div class="p">Utiliser plutôt ou NOTE : Un moyen pratique pour fixer la valeur d' un paramètre à l' ensemble de noeuds vide est : 11.3 Utilisation des valeurs des variables et des paramètres avec xsl : copy-of &lt; xsl : copy-of select = expression / &gt; L' élément xsl : copy-of , contrairement à xsl : value-of ( voir [ 7.6.1 Generating Text with xsl : value-of ] ) , peut être utilisé pour insérer un fragment d' arbre résultat dans un arbre résultat , sans avoir à commencer par le convertir en une chaîne de caractères . </div>
<div class="p">L' attribut select exigé contient une expression . </div>
<div class="p">Lorsque le résultat de l' évaluation de l' expression est fragment d' arbre résultat , alors le fragment complet est copié dans l' arbre résultat . </div>
<div class="p">Lorsque le résultat est un ensemble de noeuds , alors tous les noeuds de cet ensemble sont copiés dans l' arbre résultat dans le même ordre où ils apparaissent dans le document ; la copie d' un élément noeud copie les noeuds attributs , les noeuds espaces de noms et les enfants de l' élément noeud ainsi que l' élément noeud lui -même ; la copie d' un noeud racine se fait par la copie de ses enfants . </div>
<div class="p">Si le résultat n' est ni un ensemble de noeuds ni un fragment d' arbre résultat , alors il est doit être convertit en une chaîne de caractères et ensuite inséré dans l' arbre résultat de la même manière qu' avec xsl : value-of . </div>
<div class="p">11.4 Variables et Paramètres de haut niveau Les éléments xsl : variable et xsl : param sont tous deux autorisés à être utilisés comme éléments de haut niveau ( top-level ) . </div>
<div class="p">Un élément lien de variable de haut niveau déclare une variable globale visible partout . </div>
<div class="p">Un élément xsl : param de haut niveau déclare un paramètre pour la feuille de style ; XSLT ne définit pas le mécanisme permettant de transmettre les paramètres à la feuille de style . </div>
<div class="p">Une feuille de style ne peut contenir plus d' un lien à une variable de haut niveau ayant le même nom et la même préséance d' import . </div>
<div class="p">Au niveau le plus haut , l' expression ou le modèle spécifiant la valeur d' une variable est évalué dans le même contexte le traitement du noeud racine d' un document source : le noeud courant est le noeud racine du document source et la liste courante de noeuds est une liste contenant uniquement le noeud racine du document source . </div>
<div class="p">Si le modèle ou l' expression spécifiant la valeur d' une variable globale x fait référence à une variable globale y , alors la valeur de y doit être calculée avant la valeur de x . </div>
<div class="p">S' il était impossible de traiter toutes les variables globales de la sorte alors c' est une erreur ; en d' autres termes , si la définition est circulaire alors c' est une erreur . </div>
<div class="p">L' exemple suivant montre la déclaration d' une variable globale para-font-size , qui est référencée dans la valeur d' un attribut modèle . </div>
<div class="p">11.5 Les Variables et les Paramètres dans les modèles De même qu' il est possible d' utiliser dans les élément de haut niveau , xsl : variable et xsl : param sont aussi permis dans les modèles . </div>
<div class="p">Dans un modèle , xsl : variable est autorisé partout où une instruction l' est . </div>
<div class="p">Dans ce cas , le lien est visible pour tous les frères suivant ainsi que leurs descendants . </div>
<div class="p">Notez bien que le lien n' est pas visible par l' élément xsl : variable lui -même . xsl : param est permis lorsqu' il est fils au début d' un élément xsl : template . </div>
<div class="p">Dans ce cas précis , le lien est visible pour tous les frères suivant et à leurs descendants . </div>
<div class="p">Notez que le lien n' est pas visible par l' élément xsl : param lui -même . </div>
<div class="p">Un lien inhibe un autre lien si le lien se produit à un point où l' autre lien est visible , et les deux liens doivent avoir le même nom . </div>
<div class="p">Si un lien établit par un élément xsl : variable ou un élément xsl : param dans un modèle inhibe un autre lien établit aussi dans un modèle par un élément xsl : variable ou un élément xsl : param alors c' est une erreur . </div>
<div class="p">Par contre , lien un établit par un élément xsl : variable ou un élément xsl : param dans un modèle peut inhiber un autre lien établit par un élément de haut niveau xsl : variable ou un élément de haut niveau xsl : param . </div>
<div class="p">Ainsi , ce qui suit est erroné : &lt;xsl:template name="foo"&gt; &lt;xsl:param name="x" select="1"/&gt; &lt;xsl:variable name="x" select="2"/&gt; &lt;/xsl:template&gt; Cependant ce qui suit est autorisé : NOTE : L' équivalent Java le plus proche d' un élément xsl : variable dans un modèle est la déclaration avec initialisation d' une variable locale terminale . </div>
<div class="p">Par exemple , a la même sémantique que XSLT ne fournit pas un équivalent à l' opérateur d' initialisation de Java car ceci rend plus difficile une implémentation qui traite un document d' une manière autre que la manière de traitement par lots , partant du début jusqu' à la fin . </div>
<div class="p">11.6 Passage de paramètres aux modèles Le passage de paramètres aux modèle se fait par le moyen de l' élément xsl : with-param . </div>
<div class="p">L' attribut name obligatoire indique le nom du paramètre ( la variable dont la valeur doit être remplacée ) . </div>
<div class="p">La valeur de l' attribut name est un QName , qui est résolu comme décrit dans [ 2.4 Noms qualifiés ] . xsl : with-param est permis aussi bien dans xsl : call-template que dans xsl : apply-templates . </div>
<div class="p">La valeur du paramètre est spécifiée de la même manière que pour xsl : variable et xsl : param . </div>
<div class="p">Le noeud courant et la liste courante de noeuds utilisés pour calculer la valeur spécifiée par l' élément xsl : with-param sont les mêmes que ceux utilisés pour l' élément xsl : apply-templates ou pour l' élément xsl : call-template dans lequel il se apparaît . </div>
<div class="p">Ce n' est pas une erreur de passer un paramètre x à un modèle qui n' a pas d' élément xsl : param pour le paramètre x ; dans ce cas là , le paramètre x est tout simplement ignoré . </div>
<div class="p">L' exemple suivant défini un modèle nommé pour un numbered-block avec un argument pour contrôler le format du nombre . </div>
<div class="p">12 Fonctions additionnelles Cette section décrit les mécanismes d' ajout de fonctions spécifiques à la librairie des fonctions du noyau de XPath . </div>
<div class="p">Certaines de ces fonctions additionnelles se servent d' informations spécifiées par des éléments de premier niveau dans la feuille de style ; cette section décrit aussi ces éléments . </div>
<div class="p">12.1 Documents avec sources multiples Fonction : node-setdocument ( object , node-set ? ) La fonction document permet d' accéder aux documents XML autres que le document source principal . </div>
<div class="p">Lorsque la fonction document a exactement un argument et que cet argument est un ensemble de noeuds alors , le résultat est l' union , pour chaque noeud de l' ensemble de noeuds reçu en argument , du résultat de l' exécution de la fonction document avec comme premier argument la string-value du noeud , et comme deuxième argument un ensemble de noeuds dont l' unique élément est le noeud lui -même . </div>
<div class="p">Lorsque la fonction document a deux arguments et que le premier argument est un ensemble de noeuds alors , le résultat est la réunion , pour chaque noeud de l' ensemble de noeuds reçu en argument , du résultat de l' exécution de la fonction document avec comme premier argument la string-value du noeud et , comme deuxième argument , le deuxième argument passé à la fonction document . </div>
<div class="p">Si le premier argument de la fonction document n' est pas un ensemble de noeuds alors il sera convertit en une chaîne de caractères comme par l' exécution de la fonction string . </div>
<div class="p">Cette chaîne de caractères est traitée comme une référence à un URI ; la ressource identifiée par l' URI est extraite . </div>
<div class="p">Les données résultant de la fonction d' extraction sont analysées comme un document XML et un arbre est construit en concordance avec le modèle de données ( voir [ 3 Modèle de données ] ) . </div>
<div class="p">Si l' extraction de la ressource se solde par une erreur alors , le processeur XSLT peut signaler l' erreur ; s' il ne le fait pas , il doit récupérer sur l' erreur en retournant un ensemble vide de noeuds . </div>
<div class="p">Une erreur pouvant se produire à l' extraction résulte du fait que le processeur XSLT ne supporte pas le schéma utilisé par l' URI . Un processeur XSLT n' est sensé supporter aucun schéma particulier d' URI . Les schémas d' URI supportés par un processeur XSLT doivent être clairement indiqués dans sa documentation . </div>
<div class="p">Si la référence à l' URI ne contient pas un identificateur de fragment alors , la fonction retourne l' ensemble de noeuds contenant uniquement le noeud racine du document . </div>
<div class="p">Si la référence à l' URI contient un identificateur de fragment alors , la fonction retourne un ensemble de noeuds contenant les noeuds de l' arbre identifiés par l' identificateur du fragment de la référence à l' URI . La sémantique de l' identificateur de fragment dépend du type de média du résultat de l' extraction de l' URI . Si lors du traitement de l' identificateur de fragment , une erreur se produisait , alors le processeur XSLT peut signaler cette erreur ; dans le cas contraire , il doit récupérer l' erreur en retournant un ensemble vide de noeuds . </div>
<div class="p">Les erreurs possibles comportent : L' identificateur du fragment fait référence à quelque chose qui ne peut être représentée par une ensemble de noeuds XSLT ( telle qu' une chaîne de caractères dans un noeud texte ) . </div>
<div class="p">Le processeur XSLT ne supporte pas les identificateurs du fragment pour le type de média du résultat de récupération . </div>
<div class="p">Un processeur XSLT n' est pas supposé de supporter un type particulier de types de média . </div>
<div class="p">La documentation de chaque processeur XSLT doit indiquer pour quels type de médias le processeur supporte les identificateurs de fragments . </div>
<div class="p">Les données résultant de l' action d' extraction sont analysées comme un document XML sans tenir compte du type de média du résultat de l' extraction ; si le type média de haut niveau est text , alors il est analysé comme si le type média était text / xml ; autrement , il est analysé comme si le type média était application / xml . </div>
<div class="p">NOTE : Puisqu' il n' y a pas de type média xml de haut niveau , les données avec un type média autre que text / xml ou application / xml peuvent être XML . La référence à l' URI peut être relative . </div>
<div class="p">L' URI de base ( voir [ 3.2 URI base ] ) du noeud qui apparaît le premier dans le document et qui appartient à l' ensemble de noeuds du deuxième argument est utilisé comme URI de base pour résoudre les URI relatives et les transformer en URI absolues . Lorsque le deuxième argument est omis , le noeud de la feuille de style qui contient l' expression incluant un appel à la fonction document est utilisé comme noeud de substitution par défaut . </div>
<div class="p">Notez qu' une référence à une URI de taille nulle est une référence au document dont l' URI qui lui est relative est en cours de résolution ; ainsi document ( " " ) fait référence au noeud racine de la feuille de style ; la représentation en arbre de la feuille de style est exactement la même que si le document XML contenant la feuille de style était le document source initial . </div>
<div class="p">Deux documents sont traités comme le même document s' ils sont identifiés par le même URI . L' URI absolue est utilisé pour la comparaison dans laquelle chaque URI relative a été résolue et ne contient aucun identificateur de fragment . </div>
<div class="p">Un noeud racine est traité comme si c' était le même noeud qu' un autre noeud racine si les deux noeuds sont tous deux du même document . </div>
<div class="p">Ainsi , l' expression suivante est toujours vrai : La fonction document augmente la possibilité qu' un ensemble de noeuds puisse contenir des noeuds provenant de plusieurs documents . </div>
<div class="p">Avec un tel ensemble de noeuds , l' ordre du document relatif pour deux noeuds dans un même document est l' ordre du document normal définit par XPath [ XPath ] . </div>
<div class="p">L' ordre de deux noeuds relatif au document dans deux documents différents est déterminé un ordre dépendant de l' implémentation des documents contenant les deux noeuds . </div>
<div class="p">Il n' y a pas de contraintes sur la manière selon laquelle l' implémentation ordonne les documents autres que le fait que l' ordonnancement doit se faire du'une manière consistante : une implémentation doit toujours utiliser le même ordre pour le même ensemble de documents . </div>
<div class="p">12.2 Clés Les clés procurent le moyen de travailler avec des documents contenant une structure implicite de références croisées . </div>
<div class="p">Les types d' attributs ID , IDREF et IDREFS dans XML fournissent un mécanisme permettant les documents XML de rendre explicites leurs références croisées . </div>
<div class="p">La fonction id de XPath permet à XSLT de supporter ce mécanisme . </div>
<div class="p">Cela dit , ce mécanisme a un certain nombre de limitations : Les attributs ID doivent être déclarés comme dans une DTD . Si un attribut ID n' est déclaré que dans un sous ensemble externe de DTD alors , il ne sera reconnu en tant que tel que si le processeur XML tenait compte du sous ensemble externe de la DTD . Cependant , XML n' exige pas des processeurs XML de tenir compte des DTD externes . </div>
<div class="p">Ils peuvent bien choisir , à raison , de ne pas lire et considérer les DTDs externes , particulièrement si le document est déclaré avec l' attribut standalone="yes " . </div>
<div class="p">Un document peut contenir un seul ensemble d' IDs uniques . </div>
<div class="p">Il ne peut y avoir des ensembles séparés et indépendants d' IDs uniques . </div>
<div class="p">L' ID d' un élément ne peut être spécifié que dans un attribut ; il ne peut être spécifié par le contenu d' un élément ou par un élément fils . </div>
<div class="p">Un ID ne peut être autre qu' un nom XML . Il ne peut , par exemple pas , contenir des espaces . </div>
<div class="p">Un élément peut avoir au plus un ID . Un élément au plus peut avoir un ID particulier . </div>
<div class="p">À cause ces limitations , les documents XML peuvent parfois contenir une structure de références croisées qui n' est pas explicitement déclarée par les attributs ID / IDREF / IDREFS . Une clé est un triplet contenant : un noeud contenant la clé le nom de la clé ( un nom étendu ) la valeur de la clé ( une chaîne de caractères ) Pour chaque document , une feuille de style déclare un ensemble de clé à l' aide de l' élément xsl : key . </div>
<div class="p">Pour un élément de cet ensemble de clés ayant un noeud x , un nom y et une valeur z , nous disons que le noeud x a une clé dont le nom est y et la valeur est z . </div>
<div class="p">Ainsi , une clé est une sorte de ID généralisé qui n' est pas contraint par les mêmes limitations qu' un ID XML : Les clés sont déclarées dans les feuilles de style en utilisant les éléments xsl : key . </div>
<div class="p">Une clé a un nom ainsi qu' une valeur ; chaque nom de clé être considéré comme distinguant une espace d' identificateurs séparé et indépendant . </div>
<div class="p">La valeur d' une clé nommée peut être spécifiée à qui parait le plus commode ; par exemple , dans un attribut , dans un élément fils ou dans le contenu de l' élément . </div>
<div class="p">Une expression XPath sert à indiquer où trouver la valeur d' une clé nommée particulière . </div>
<div class="p">La valeur d' une clé n' est pas forcement un nom et peut être une chaîne de caractères arbitraire . </div>
<div class="p">Un document peut contenir plusieurs clés avec le même noeud , le même nom de clé mais ayant des valeurs différentes . </div>
<div class="p">Un document peut contenir plusieurs clés ayant le même nom , la même valeur mais des noeuds différents . &lt; xsl : key name = qname match = pattern use = expression / &gt; L' élément xsl : key sert à la déclaration de clés . </div>
<div class="p">Le nom de la clé est spécifié dans l' attribut name . </div>
<div class="p">La valeur de l' attribut name est un QName , qui est étendu comme indiqué dans [ 2.4 Noms qualifiés ] . </div>
<div class="p">L' attribut match est un Pattern ; un élément xsl : key informe sur les clés de n' importe quel noeud et qui concordent avec un motif spécifié par l' attribut match . </div>
<div class="p">L' attribut use est une expression spécifiant la valeur de la clé ; cette expression est évaluée une fois pour chaque noeud concordant avec le motif . </div>
<div class="p">Si le résultat est un ensemble de noeuds alors , pour chaque noeud de cet ensemble , le noeud concordant avec le motif a une clé dont le nom est celui spécifié et dont la valeur est celle de la chaîne de caractères du noeud de l' ensemble de noeuds ; autrement le résultat est convertit en une chaîne de caractères et le noeud qui concorde avec le motif a une clé dont le nom est celui spécifié et dont dont la valeur est égale à cette chaîne de caractères . </div>
<div class="p">Ainsi , un noeud x a une clé dont le nom est y et dont la valeur est z si et seulement s' il existe un élément xsl : key tel que : x concorde avec le motif spécifié par l' attribut match de l' élément xsl : key ; la valeur de l' attribut name de l' élément xsl : key est égale à y ; et Lorsque l' expression spécifiée par l' attribut use de l' élément xsl : key est évaluée avec , comme noeud courant , le noeud x et comme liste courante de noeuds la liste contenant uniquement le noeud x résultant dans un objet u , alors , ou bien z est égal au résultat de conversion de l' objet u en une chaîne de caractères comme par une appel à la fonction string , ou alors , u est une ensemble de noeuds et z est égal a la valeur de la chaîne de caractères d' un ou plusieurs noeuds dans u . </div>
<div class="p">Notez bien aussi qu' il est possible d' avoir plus d' un élément xsl : key concordant un noeud donné ; tous les éléments xsl : key concordants sont utilisés , même si leurs préséance d' import n' est pas la même . </div>
<div class="p">Si l' un des attributs use ou match contenait une VariableReference alors c' est une erreur . </div>
<div class="p">Fonction : node-setkey ( string , object ) La fonction key joue le même rôle pour les clés que celui de la fonction id pour les IDs . </div>
<div class="p">Le premier argument spécifie le nom de la clé . </div>
<div class="p">La valeur de cet argument doit être un QName , qui est étendu comme c' est décrit dans [ 2.4 Noms qualifiés ] . </div>
<div class="p">Lorsque le type du deuxième argument de la fonction key est un ensemble de noeuds alors , le résultat est la réunion des résultats de l' application de la fonction key à la valeur de la chaîne de caractères de chacun des noeuds de l' ensemble de noeuds reçu en deuxième argument par la fonction . </div>
<div class="p">Si le type du deuxième argument de la fonction key n' est pas un ensemble de noeuds alors l' argument est converti en une chaîne de caractères de la même manière que par l' appel de la fonction string ; elle retourne , sous forme d' un ensemble de noeuds contenant les noeuds du même document , un noeud contexte dont la valeur de la clé nommée est égale à cette chaîne de caractères . </div>
<div class="p">Étant donné , par exemple , la déclaration suivante : l' expression key ( " idkey " , @ref ) retourne le même ensemble de noeuds que id ( @ref ) , à condition que le seul attribut ID déclaré dans le document source XML est : et que l' attribut ref du noeud courant ne contient pas d' espaces . </div>
<div class="p">Considérons un document décrivant une librairie de fonction et utilisant un élément prototype pour définir les fonctions ainsi qu' un élément function pour faire référence aux noms des fonctions La feuille de style peut alors générer des hyperliens entre les références et les définition comme suit : La fonction key peut être utilisée pour récupérer une clé à partir d' un document autre que le document contenant le noeud contexte . </div>
<div class="p">Supposons par exemple , un document contenant des références bibliographiques sous la forme &lt;bibref&gt; XSLT &lt;/bibref&gt; , et qu' il y ait un document XML séparé bib . xml contenant la base de données bibliographiques dont les entrées sous de la forme : Alors , pour la transformation des éléments bibref la feuille de style peut contenir ce qui suit : 12.3 Formatage de nombres Fonction : stringformat-number ( number , string , string ? ) La fonction format-number converti son premier argument en une chaîne de caractères en utilisant comme format de conversion , la chaîne de caractères motif spécifiée par le deuxième argument et le format décimal indiqué par le troisième argument , ou le format décimal par défaut en cas d' absence du troisième argument . </div>
<div class="p">La chaîne de caractères motif de conversion doit respecter la syntaxe spécifiée par la classe DecimalFormat de JDK 1.1 . </div>
<div class="p">La chaîne de caractères motif doit être une chaîne localisée : le format décimal détermine quels sont les caractères ayant une signification particulière dans le motif ( à l' exception du caractère guillemet qui n' est pas localisé ) . </div>
<div class="p">Le motif de format ne doit pas contenir le symbole monétaire ( # x00A4 ) ; le support de cette caractéristique a été ajouté après la release initiale de JDK 1.1 . </div>
<div class="p">Le nom du format5 décimal doit être un QName , qui est étendu comme décrit dans [ 2.4 Noms qualifiés ] . </div>
<div class="p">Si la feuille de style ne contient pas une déclaration du format décimal avec expanded-name spécifié alors c' est une erreur . </div>
<div class="p">NOTE : Les implémentations ne doivent pas forcément utiliser l' implémentation de JDK 1.1 implémentation , et les implémentation ne doivent pas être forcément réalisées en Java . </div>
<div class="p">NOTE : Les feuilles de style peuvent utiliser d' autres moyens de XPath pour contrôler l' arrondissement des nombres . &lt; xsl : decimal-format name = qname decimal-separator = char grouping-separator = char infinity = string minus-sign = char NaN = string percent = char per-mille = char zero-digit = char digit = char pattern-separator = char / &gt; L' élément xsl : decimal-format déclare un format décimal qui contrôle l' interprétation d' un motif de format utilisé par la fonction format-number . </div>
<div class="p">S' il y a un attribut name alors , l' élément déclare un format décimal nommé ; autrement , il déclare le format décimal par défaut . </div>
<div class="p">La valeur de l' attribut name est un QName , qui est étendu comme décrit dans [ 2.4 Noms qualifiés ] . </div>
<div class="p">A moins qu' un format décimal ne soit déclaré chaque fois avec la même valeur pour tous les attributs ( en tenant compte de n' importes quelles valeurs par défaut ) , la déclaration multiple ( même avec des préséances d' import différentes ) , du format décimal par défaut ou d' un format décimal nommé est une erreur . </div>
<div class="p">Les autres attributs de l' élément xsl : decimal-format correspondent aux méthodes de la classe DecimalFormatSymbols de JDK 1.1 . </div>
<div class="p">Pour chaque paire de méthodes get / set il existe un attribut défini pour l' élément xsl : decimal-format . </div>
<div class="p">Les attributs suivants permettent de contrôler aussi bien l' interprétation des caractères dans le motif de format que de spécifier les caractères pouvant apparaître dans le résultat de formatage du nombre : decimal-separator indique le caractère utilisé pour le symbole des décimales ; la valeur par défaut est le caractère point ( . ) grouping-separator indique le caractère utilisé comme séparateur de groupes ( e . g . milliers ) ; la valeur par défaut est le caractère virgule ( , ) percent indique le caractère utilisé pour le signe pour-cent ; la valeur par défaut est le caractère pour-cent ( % ) per-mille indique le caractère utilisé pour le signe pour-mille ; la valeur par défaut est le caractère Unicode pour-mille ( # x2030 ) zero-digit indique le caractère utilisé pour le chiffre zéro ; la valeur par défaut est le chiffre zéro ( 0 ) Les attributs suivants contrôlent l' interprétation des caractères dans le motif de format : digit indique le caractère utilisé pour un chiffre dans le motif de format ; la valeur par défaut est le caractère dièse ( # ) pattern-separator indique le caractère utilisé dans un motif , pour séparer les sous-motifs représentant des nombres positifs des sous motifs représentant des nombres négatifs ; la valeur par défaut est le caractère point-virgule ( ; ) Les attributs suivants indiquent les caractères ou les chaînes de caractères pouvant apparaître dans le résultat de formatage d' un nombre : infinity indique la chaîne de caractères utilisée pour représenter l' infinité ; la valeur par défaut est la chaîne de caractères Infinity NaN indique la chaîne de caractères utilisée pour représenter la valeur de NaN ( Not a Number ) ; la valeur par défaut est la chaîne de caractères NaN minus-sign indique le caractère utilisé comme signe moins par défaut ; la valeur par défaut est la caractère tiret-moins ( - , # x2D ) 12.4 Fonctions additionnelles diverses Fonction : node-setcurrent ( ) La fonction current retourne un ensemble de noeuds ayant pour seul élément le noeud courant . </div>
<div class="p">Pour une expression indépendante ( ne se produisant pas dans une autre expression ) , le noeud courant est toujours le même que le noeud contexte . </div>
<div class="p">Ainsi , a la même signification que Cependant dans des crochets , le noeud courant est habituellement différent du noeud contexte . </div>
<div class="p">Par exemple , traite tous les éléments item qui ont un élément glossary parent et qui ont un attribut name dont la valeur est égale à la valeur de l' attribut ref du noeud courant . </div>
<div class="p">Ceci est différent de qui signifie la même chose que permettant de traiter tous les éléments item ayant un élément glossary parent et ayant un attribut name et un attribut ref ayant la même valeur . </div>
<div class="p">L' utilisation de la fonction current dans un motif est une erreur . </div>
<div class="p">Fonction : stringunparsed-entity-uri ( string ) La fonction unparsed-entity-uri retourne l' URI de l' entité non valide avec un nom spécifié dans le même document que le noeud contexte ( voir [ 3.3 Entités non valides ] ) . </div>
<div class="p">Si une pareille entité n' existe pas alors la fonction retourne une chaîne de caractères vide . </div>
<div class="p">Fonction : stringgenerate-id ( node-set ? ) La fonction generate-id retourne une chaîne de caractères qui identifie d' une manière unique le noeud dans l' ensemble de noeuds reçu en argument qui est le premier selon l' ordre du document . </div>
<div class="p">L' identificateur unique doit être composé de caractères ASCII alphanumériques et doit commencer par un caractère alphabétique . </div>
<div class="p">Ainsi , la chaîne de caractères est syntaxiquement parlant un nom XML . Une implémentation est libre de générer un identificateur de la façon qui lui est la plus appropriée de telle manière qu' un même identificateur est toujours généré pour le même noeud et différents identificateurs sont toujours générés à partir de noeuds différents . </div>
<div class="p">Une implémentation n' est pas obligée de générer les mêmes identificateurs chaque fois qu' un document subi une transformation . </div>
<div class="p">Rien ne garanti identificateur unique généré sera est distinct de n' importe quel IDs unique spécifié dans le document source . </div>
<div class="p">Si l' ensemble de noeuds reçu en argument est vide la fonction retourne la chaîne de caractères vide . </div>
<div class="p">Si l' argument est omis , il est remplacé par le noeud contexte . </div>
<div class="p">Fonction : objectsystem-property ( string ) L' argument de cette fonction doit être évalué par une chaîne de caractères de type QName . </div>
<div class="p">Le QName est étendu en un nom utilisant la déclaration de l' espace de noms dans la portée de l' expression . </div>
<div class="p">La fonction system-property retourne un objet représentant la valeur de la propriété système identifiée par le nom . </div>
<div class="p">Si une telle propriété système n' existe pas alors la chaîne de caractères vide est retournée . </div>
<div class="p">Les implémentations doivent fournir les propriétés système suivantes qui sont toutes dans l' espace de noms XSLT : xsl : version , il s' agit d' un nombre qui indique la version de XSLT supportée par le processeur ; Cette valeur est 1.0 pour les processeurs XSLT implémentant la version de XSLT spécifiée dans ce document xsl : vendor , c' est une chaîne de caractères identifiant le fabriquant du processeur XSLT xsl : vendor-url , une chaîne de caractères qui contient une URL identifiant le fabriquant du processeur XSLT ; cette URL est d' une manière générale , la page d' accueil ( home page ) du site Web du fabriquant . </div>
<div class="p">13 Messages &lt; xsl : message terminate = " yes " " no " &gt; &lt; ! </div>
<div class="p">Content : template </div>
<div class="p">&gt; &lt;/xsl:message&gt; L' instruction xsl : message permet d' envoyer un message d' une manière qui dépend du processeur XSLT . Le contenu de l' instruction xsl : message est un modèle . </div>
<div class="p">L' instruction xsl : message est instanciée par l' instanciation du contenu afin de créer un fragment XML . Le fragment XML est le contenu du message . </div>
<div class="p">NOTE : xsl : message peut être implémenté par un processeur XSLT de telle sorte qu' il déclenche une dialogue popup d' alerte , ou en écrivant dans un fichier log . </div>
<div class="p">Si la valeur de l' attribut terminate est yes alors , le processeur XSLT doit terminer son traitement après l' envoi du message . </div>
<div class="p">La valeur par défaut est no . </div>
<div class="p">Pour la localisation des messages , un moyen pratique consiste à stocker l' information localisée ( texte des messages , etc . ) dans un document XML qui devient un fichier d' entrée additionnel pour la feuille de style . </div>
<div class="p">Supposons par exemple que les messages pour une langue L sont stockés dans un fichier XML resources / L. xml sous la forme : La feuille de style doit alors utiliser l' approche suivante pour localiser les messages : 14 Extensions XSLT autorise 2 sortes d' extension , l' une s' applique aux éléments , l' autre aux fonctions . </div>
<div class="p">Cette version de XSLT ne fournit aucun mécanisme de définition des implémentations d' extension . </div>
<div class="p">Aussi , une feuille de styles XSLT qui se veut portable entre différentes implémentations de XSLT ne peut -elle pas dépendre d' extensions spécifiques . </div>
<div class="p">XSLT fournit des mécanismes qui permettent à une feuille de styles XSLT de déterminer si le processeur XSLT qui la traite est capable de traiter des extensions particulières , et de spécifier ce qui doit arriver quand les extensions ne sont pas disponibles . </div>
<div class="p">Si une feuille de styles XSLT est écrite en faisant attention à l' utilisation de ces mécanismes , alors il lui est possible de tirer partie des extensions tout en restant portable sur n' importe quelle implémentation de XSLT . 14.1 Eléments extension Le mécanisme d' extension d' éléments permet de désigner des espaces de noms comme étant des espaces de noms d' extension . </div>
<div class="p">Lorsqu' un espace de noms est qualifié d' espace de noms d' extension , et qu' un élément dont le nom fait partie de cet espace est utilisé dans un modèle , alors cet élément est traité comme une instruction plutôt que comme un élément résultat littéral . </div>
<div class="p">L' espace de nom détermine alors la sémantique de l' instruction . </div>
<div class="p">NOTE : Puisqu' un élément fils d' un élément xsl : stylesheet n' apparaît pas dans le modèle , les éléments de haut niveau non-XSLT ne sont pas des extensions d' éléments telles que définies ici , et rien dans cette section ne s' applique à eux . </div>
<div class="p">On qualifie un espace de noms d' espace de noms d' extension en utilisant soit l' attribut extension-element-prefixes de l' élément xsl : stylesheet soit l' attribut xsl : extension-element-prefixes sur un élément résultat littéral ou un élément extension . </div>
<div class="p">La valeur de ces attributs est une liste de préfixes d' espaces de noms séparés par des espaces . </div>
<div class="p">L' espace de nom lié à chacun de ces préfixes se nomme espace de noms d' extension . </div>
<div class="p">Une erreur doit être signalée si aucun espace de noms n' est rattaché au préfixe utilisé par l' élément porteur de l' attribut extension-element-prefixes ou xsl : extension-element-prefixes . </div>
<div class="p">L' espace de noms par défaut ( tel que déclaré par xmlns ) peut être désigné comme un espace de noms d' extension , en incluant # default dans la liste des préfixes d' espaces de noms . </div>
<div class="p">La désignation d' un espace de noms comme espace de noms d' extension est effective à l' intérieur du sous arbre de la feuille de styles dont la racine est l' élément porteur de l' attribut extension-element-prefixes ou de l' attribut xsl : extension-element-prefixes . </div>
<div class="p">Les sous-arbres qui ont pout racine l' élément xsl : stylesheet , alors il n' inclue aucune des feuilles de style importées ou incluses de cet élément xsl : stylesheet . </div>
<div class="p">Si le processeur XSLT ne dispose pas d' implémentation pour un élément extension particulier , alors la fonction element-available doit retourner la valeur faux pour le nom de l' élément . </div>
<div class="p">Quand un tel élément extension est instancié , le processeur XSLT doit exécuter un retour pour l' élément tel que spécifié en [ 15 Reprise ] . </div>
<div class="p">Un processeur XSLT ne doit pas signaler d' erreur simplement parce qu' un modèle contient une extension d' élément pour laquelle il n' y aurait aucune implémentation disponible . </div>
<div class="p">Si le processeur XSLT dispose d' une implémentation pour un élément extension particulier , alors la fonction element-available doit retourner la valeur vraie pour le nom de l' élément . </div>
<div class="p">14.2 Fonction extension Si , dans une expression d' appel de fonction ( FunctionCall ) , un nom de fonction ( FunctionName ) n' est pas conforme à un sans deux points ( NCName ) ( c' est à dire s' il contient le caractère deux points ) , alors il est traité comme un appel à une fonction d' extension . </div>
<div class="p">Le nom de la fonction ( FunctionName ) est étendu en un nom utilisant la déclaration d' espace de noms trouvé dans son contexte d' évaluation . </div>
<div class="p">Si le processeur XSLT n' a pas d' implémentation particulière pour un nom d' fonction d' extension , alors la fonction " fonctions disponibles " ( function-available ) doit retourner la valeur faux pour ce nom de fonction . </div>
<div class="p">Si une telle fonction d' extension survient dans une expression et si l' fonction d' extension est en cours d' appel , le processeur XSLT doit signaler une erreur . </div>
<div class="p">Un processeur XSLT ne doit pas signaler d' erreur simplement parce qu' une expression contient une fonction extension inconnue . </div>
<div class="p">Si le processeur XSLT dispose de l' implémentation d' une fonction d' extension particulière , alors la fonction function-available ( fonction-disponible ) doit retourner la valeur vrai pour ce nom de fonction . </div>
<div class="p">Lorsque cette extension est appelée , alors le processeur XSLT doit exécuter l' implémentation correspondante en lui passant les arguments effectifs . </div>
<div class="p">Le résultat retourné par l' implémentation est renvoyé comme résultat de l' appel de la fonction . </div>
<div class="p">15 Reprise alors la méthode de sortie par défaut est html ; Sinon , la méthode est xml . </div>
<div class="p">La méthode de sortie par défaut doit être utilisée s' il n' y a pas d' élément xsl : output ou si aucun des éléments xsl : output ne spécifie une valeur pour l' attribut method . </div>
<div class="p">Les autres attributs de l' élément xsl : output sont des paramètres de la méthode de sortie qui sont : version spécifie la version de la méthode de sortie . indent spécifie si le processeur XSLT est autorisé à rajouter des espaces blancs additionnels pendant qu' il génère l' arbre résultat ; la valeur ne peut être que yesou no . encoding spécifie le système de codage de caractères préférentiel que le processeur XSLT doit utiliser pour représenter des séquences de caractères en tant que séquences d' octets ; la valeur de cet attribut doit être traîtée sans tenir compte de la casse ; la valeur ne peut contenir que des caractères compris entre # x21 et # x7E ( c' est à dire les caractères imprimables de l' ASCII ) ; la valeur doit soit être un jeu de caractères charset enregistré auprès de l' IANA [ IANA ] , [ RFC2278 ] soit commencer par X - . media-type spécifie le type de support ( type de contenu MIME ) des données issues de l' arbre résultat ; le paramètre charset ne doit pas être spécifié explicitement ; au lieu de cela , quand le type de support de plus haut niveau est text , un paramètre charset doit être rajouté en conformité avec le codage des caractères en vigueur pour la méthode de sortie . doctype-system spécifie l' identifiant système qui doit être utilisé dans la déclaration de type de document . doctype-public spécifie l' identifiant public qui doit être utilisé dans la déclaration de type de document . omit-xml-declaration spécifie si le processeur XSLT doit produire une déclaration XML ; la valeur est obligatoirement yes ou no standalone spécifie si le processeur XSLT doit générer une déclaration de document autonome ; la valeur doit être yes ou no cdata-section-elements spécifie une liste de noms d' éléments dont les fils de type noeud texte doivent être produit en tant que section CDATA dans l' arbre résultat . </div>
<div class="p">Le sémantique détaillée de chaque attribut sera décrite séparemment pour chaque méthode de sortie à laquelle l' attribut est applicable . </div>
<div class="p">Si la sémantique de l' attribut n' est pas décrite pour une méthode de sortie , alors cela signifie que cette méthode ne lui est pas applicable . </div>
<div class="p">Une feuille de styles peut contenir plusieurs éléments xsl : output et peut inclure ou importer des feuilles de style qui contiennent aussi des éléments xsl : output . </div>
<div class="p">Tous les éléments xsl : output intervenant dans une feuille de styles sont fusionnés au sein d' un seul élément effectif xsl : output . </div>
<div class="p">La valeur effective de l' attribut cdata-section-elements est l' union des valeurs spécifiées . </div>
<div class="p">Pour les autres attributs , la valeur effective est la valeur spécifiée ayant la plus grande priorité d' importation . </div>
<div class="p">La présence de plus d' une telle valeur pour un attribut est une erreur . </div>
<div class="p">Un processeur XSLT peut signaler l' erreur ; s' il ne le fait pas , il doit traiter l' erreur en utilisant la valeur qui apparaît en dernier dans la feuille de styles . </div>
<div class="p">Les valeurs des attributs sont prises par défaut après que les éléments xsl : output aient été fusionnés ; différentes méthodes de sortie peuvent avoir différentes valeur par défaut pour un attribut . </div>
<div class="p">16.1 La méthode de sortie XML La méthode de sortie xml produit l' arbre résultat sous la forme d' une entité générale XML bien formée et correcte . </div>
<div class="p">Si le noeud racine de l' arbre résultat a un unique fils et aucun autre fils de type texte , alors l' entité devrait aussi être bien formée . </div>
<div class="p">Si l' entité est référencée dans un document XML simple comme dans l' exemple suivant , dans lequel entity-URI est l' URI de l' entité , alors le document englobant doit être globalement un document XML bien formé conforme aux Recommandations des Espaces de Noms XML [ Noms XML ] . </div>
<div class="p">De plus , le résultatdoit être tel que si un nouvel arbre était produit à partir du document englobant pris comme document XML conformément aux spécifications faites en [ 3 Modèle de données ] , puis en enlevant l' élément document et en faisant de ses enfants des enfants de l' élément racine , alors le nouvel arbre serait le même que l' arbre résultat , aux possibles exceptions suivantes près : L' ordre des attributs pourrait être différent dans les deux arbres . </div>
<div class="p">Le nouvel arbre pourrait contenir des noeuds d' espaces de noms qui n' étaient pas présents dans l' arbre résultat initial . </div>
<div class="p">NOTE : Un processeur XSLT pourrait avoir besoin de rajouter des déclarations d' espaces de noms pendant la génération au format XML , de l' arbre résultat . </div>
<div class="p">Si le processeur XSLT avait généré une déclaration de type de document à cause de l' attribut doctype-system , alors les conditions ci-dessus s' appliquent à l' entité dans laquelle la déclaration de type de document générée aura été enlevée . </div>
<div class="p">L' attribut version spécifie la version de XML à considérer pour produire l' arbre résultat . </div>
<div class="p">Si le processeur XSLT ne supporte pas cette version de XML , il doit utiliser une version de XML qu' il supporte . </div>
<div class="p">La version mentionnée dans la déclaration XML ( si la déclaration XML est produite ) doit correspondre à la version de XML que le processeur aura utilisé pour produire l' arbre résultat . </div>
<div class="p">La valeur de l' attribut version doit être conforme à la règle de production VersionNum définie dans les Recommandations XML ( XML Recommendation [ XML ] ) . </div>
<div class="p">La valeur par défaut est 1.0 . </div>
<div class="p">L' attribut encoding spécifie le codage préférentiel à utiliser pour produire l' arbre résultat . </div>
<div class="p">Des processeurs XSLT sont requis pour respecter les valeurs de UTF-8 et UTF-16 . </div>
<div class="p">Pour les autres valeurs , si le processeur XSLT ne supporte pas le codage spécifié il peut généré une erreur ; s' il ne signale pas d' erreur il doit utiliser UTF-8 ou UTF-16 à la place . </div>
<div class="p">Le processeur XSLT ne doit pas utiliser d' encodage dont le nom n' est pas conforme à la règle de production des noms d' encodage ( EncName ) de la Recommandation XML ( XML Recommendation [ XML ] ) . </div>
<div class="p">Si aucun attribut encoding n' est spécifié , alors le processeur XSLT doit utiliser soit UTF-8 soit UTF-16 . l est possible que l' arbre résultat contienne un caractère qui ne puisse pas être représenté dans le système d' encodage que le processeur XSLT utilise . </div>
<div class="p">Dans ce cas , si le caractère apparaît dans un contexte où XML reconnaît les références de caractères ( c' est à dire dans la valeur d' un noeud d' attribut ou d' un noeud textuel ) , alors le caractère produit devra l' être sous la forme d' une référence de caractère ; sinon ( par exemple , si le caractère se produit dans le nom d' un élément ) le processeur XSLT doit signaler une erreur . </div>
<div class="p">Si la valeur de l' attribut indent est Yes , alors la méthode de sortie xml peut produire des espaces blancs en plus de ceux de l' arbre résultat ( peut-être basé sur les espaces blancs épurés soit du document source soit de la feuille de styles ) dans le but d' indenter le résultat proprement ; si l' attribut indent a la valeur no , il ne doit produire aucun espace blanc additionnel . </div>
<div class="p">La valeur par défaut est no . </div>
<div class="p">La méthode de sortie xml doit utiliser un algorithme pour rajouter les espaces blancs additionnels qui garantisse que le résultat , si les espaces blancs venaient à être supprimé de la sortie en utilisant le processus décrit en [ 3.4 Suppression des espaces blancs ] et en réduisant l' ensemble des éléments conservant les espaces blancs au seul cas xsl : text , serait le même , que les espaces blancs additionnels soit mis dans la sortie ou qu' ils ne le soient pas . </div>
<div class="p">NOTE : Il n' est normalement pas fiable d' utiliser indent="yes " avec des types de documents qui contiennent des types d' éléments à contenu mixte . </div>
<div class="p">L' attribut cdata-section-elements contient une liste de noms qualifiés séparés par des espaces blancs . </div>
<div class="p">Chaque nom qualifié est expansé pour former un nom expansé en utilisant les déclarations d' espaces de noms en vigueur sur l' élément xsl : output dans lequel le nom qualifié apparaît ; s' il existe un espace de noms par défaut , il sera utilisé pour les noms qualifiés qui n' ont pas de préfixe . </div>
<div class="p">L' expansion est réalisée avant que la fusion des éléments multiples xsl : output en un seul élément xsl : output ait lieu . </div>
<div class="p">Si le nom expansé d' un parent d' un noeud textuel est un membre de la liste , alors le noeud textuel doit être sorti en tant que paragraphe de type CDATA . Par exemple , Un processeur XSLT doit signaler toute erreur à l' exception de celles qui dans ce document , sont explicitement autorisées à ne pas être signalées . un processeur XSLT n' est pas obligé de récupérer toutes les erreurs bien que cela puisse se réveler nécessaire . </div>
<div class="p">Un processeur XSLT conforme peut imposer des limites sur les ressources de traitement consommées par le traitement d' une feuille de styles . </div>
<div class="p">18 Notation La spécification de chaque type d' élément défini pour XSLT est précédée par un résumé de sa syntaxe sous la forme d' un modèle pour les éléments de ce type d' élément . </div>
<div class="p">La signification de la notation syntaxique résumée est comme suit : Un attribut est requis si et seulement si son nom est en gras . </div>
<div class="p">La chaîne de caractères écrite à la place de la valeur d' attribut spécifie les valeurs d' attributs autorisées pour l' attribut . </div>
<div class="p">Si cette chaîne est encadrée par des accolades , elle représente alors une forme architecturale de la valeur d' attribut , et les valeurs d' attributs autorisées sont celles obtenues lors de l' instanciation de cette forme architecturale . </div>
<div class="p">Le connecteur représente le ou , les valeurs listées séparées par ce connecteur sont mutuellement exclusive . </div>
<div class="p">Une chaîne entre cotes signifie que la valeur de l' attribut doit être égale à cette chaîne spécifique . </div>
<div class="p">Un nom sans cote , en italique est une spécification d' un type particulier de valeur d' attribut . </div>
<div class="p">Si l' élément ne doit pas avoir un contenu vide , alors il contient un commentaire spécifiant le contenu autorisé . </div>
<div class="p">Le contenu autorisé est spécifié de la même manière pour une déclaration de type d' élément en XML ; template signifie que n' importe quel combinaison de noeuds textuels , éléments résultat littéraux , éléments d' extension , et des éléments XSLT de la catégorie instruction est autorisée ; top-level-element signifie que toute combinaison d' éléments XSLT de la catégorie top-level-element est autorisée . </div>
<div class="p">L' élément est préfacé par des commentaires indiquant s' il appartient à la catégorie instruction ou top-level-element ou aux deux . </div>
<div class="p">La catégorie d' un élément ne fait que signaler s' il est autorisé dans les contenus dont les modèles de contenus sont du type modèle ou éléments de hauts niveaux . </div>
<div class="p">Annexes C Fragment de la DTD des feuilles de style XSLT ( Non-Normatif ) NOTE : Ce fragment de DTD n' est pas normatif parce que les DTDs de XML 1.0 ne supportent pas les espaces de noms XML et donc ne peuvent pas décrire correctement la structure autorisée d' une feuille de styles XSLT . L' entité suivante peut être autorisée pour construire une DTD pour des feuilles de style XSLT qui crée des instances d' une DTD résultat particulière . </div>
<div class="p">Avant de référencer l' entité , la DTD de la feuille de styles doit définir une entité paramètre result-elements qui liste les types d' éléments résultat autorisés . </div>
<div class="p">Par exemple : F Changements depuis la recommandation proposée ( Non-Normatif ) Les points suivants sont les changements faits depuis la recommandation proposée : L' attribut xsl : version est requis sur un élément résultat littéral utilisé comme feuille de style ( voir [ 2.3 Feuille de style sous la forme d' un élément littéral résultat ] ) . </div>
<div class="p">L' attribut data-type de l' élément xsl : sort peut utiliser un nom préfixé pour spécifier un type de données non spécifié par XSLT ( voir [ 10 Ordonnancement ] ) . </div>
<div class="p">G Fonctionalités à l' étude pour une future version de XSLT ( Non-Normatif ) Les fonctionalités suivantes sont en cours d' évaluation pour les versions de XSLT au delà de la verison 1.0 : une expression conditionnelle ; le support des types de données et des archétypes des schémas XML ; le support de quelquechose équivalent aux règles qui étaient présentes dans la première version soumise de XSL ; un attribut pour contrôler l' espace de noms par défaut pour les noms apparaîssants dans les attributs XSLT ; le support des références d' entités ; le support des DTD dans le modèle de données ; le support des notations dans le modèle de données ; un moyen pour obtenir d' un élément la liste des éléments qui le référencent ( par exemple par un attribut IDREF ) ; un moyen plus facile pour obtenir un ID ou une clé d' un autre document ; le support des expressions régulières pour établir des correspondances avec tout ou partie des noeuds textuels , valeurs d' attributs , noms d' attributs et les noms des types d' éléments ; les comparaisons indépendantes de la casse ; la normalisation des chaînes de caractères avant leur comparaison , par exemple pour la compatibilité des caractères ; une fonction string resolve ( node-set ) dont l' argument sera une URI relative que la fonction trasformera en URI absolue en s' appuyant sur l' URI de base du noeud ; les documents résultat multiples ; l' utilisation du noeud courant comme valeur par défaut de l' attribut select de l' élément xsl : value-of ; un attribut sur l' élément xsl : attributepour contrôler comment la valeur d' attribut est normalisée ; des attributs additionels sur l' élément xsl : sort pour fournir plus de contrôles sur les tris , comme par exemple les scripts d' ordonnancements relatifs ; un moyen de mettre un texte identifié par une URI dans l' arbre résultat ; autoriser les unions dans les étapes de localisation ( par exemple foo/(bar baz ) ) ; autoriser sur les fragments de l' arbre résultat toutes les opérations qui sont autorisées sur les ensembles de noeuds ; un moyen pour regrouper ensemble les noeuds consécutifs ayant des sous-éléments ou des attributs dupliqués ; des fonctions pour manipuler l' attribut style de HTML plus facilement . </div>
</body>
</html>
